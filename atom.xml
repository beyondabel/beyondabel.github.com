<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel之家]]></title>
  <link href="http://beyondabel.github.io/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2014-01-09T23:35:39+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISwitch详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/11/uiswitch/"/>
    <updated>2014-01-11T12:34:31+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/11/uiswitch</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISwitch继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）,您可以使用UISwitch类来创建和管理使用开/关按钮。例如，在对选项，如飞行模式和蓝牙设置应用程序。这些对象被称为交换机。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
</code></pre>

<p><strong>1、基本属性及方法</strong>
// 开关是否打开</p>

<pre><code>BOOL on;
</code></pre>

<p>// 这个frame会被忽略，他会强制设置大小</p>

<pre><code>- (id)initWithFrame:(CGRect)frame;
</code></pre>

<p>// 打开/关闭调用函数(animated：是否使用动画)</p>

<pre><code>- (void)setOn:(BOOL)on animated:(BOOL)animated;
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 开关打开时颜色</p>

<pre><code>UIColor *onTintColor;
</code></pre>

<p><strong>3、iOS6新增</strong>
// 背影颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 开关的圆形滑钮的颜色</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 开关打开时自定义图片</p>

<pre><code>UIImage *onImage;
</code></pre>

<p>// 开关关闭时自定义图片</p>

<pre><code>UIImage *offImage;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISlider详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/11/uislider/"/>
    <updated>2014-01-11T12:34:24+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/11/uislider</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISlider继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。UISlider对象是用来从一个连续的数值范围内选择单个值的可视化控制。滑块总是显示为水平条形图。一个指标，注意到滑块的当前值，并且可以由用户进行移动来改变该设置。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、设置初始值
2、改变UISlider的外观
3、供子类重写的方法
</code></pre>

<p><strong>1、设置初始值</strong></p>

<p>// 指定初始值</p>

<pre><code>float value;
</code></pre>

<p>// 指定可变最小值</p>

<pre><code>float minimumValue;
</code></pre>

<p>// 指定可变最大值</p>

<pre><code>float maximumValue;
</code></pre>

<p><strong>2、改变UISlider的外观</strong></p>

<p>//  设置滑轮左边图片</p>

<pre><code>UIImage *minimumValueImage;
</code></pre>

<p>// 设置滑轮右边图片</p>

<pre><code>UIImage *maximumValueImage;
</code></pre>

<p>//  （默认YES）</p>

<pre><code>BOOL continuous;
</code></pre>

<p>//  滑轮左边颜色如果设置了左边的图片就不会显示（iOS 5.0）</p>

<pre><code>UIColor *minimumTrackTintColor;
</code></pre>

<p>// 滑轮右边颜色如果设置了右边的图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *maximumTrackTintColor;
</code></pre>

<p>// 设置了滑轮的颜色如果设置了滑轮的样式图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 动态设置滑动值</p>

<pre><code>- (void)setValue:(float)value animated:(BOOL)animated;
</code></pre>

<p>// 定制自己的滑块图片</p>

<pre><code>- (void)setThumbImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置左边的图片</p>

<pre><code>- (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置右边的图片</p>

<pre><code>- (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>//  根据状态返回滑动图片</p>

<pre><code>- (UIImage *)thumbImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态左边的图片</p>

<pre><code>- (UIImage *)minimumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态右边的图片</p>

<pre><code>- (UIImage *)maximumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 当前的滑动图片（只读）</p>

<pre><code>UIImage* currentThumbImage;
</code></pre>

<p>// 当前左边的图片（只读）</p>

<pre><code>UIImage* currentMinimumTrackImage;
</code></pre>

<p>// 当前右边的图片（只读）</p>

<pre><code>UIImage* currentMaximumTrackImage;
</code></pre>

<p><strong>3、供子类重写的方法</strong></p>

<p>// 以下四种方法用于子类覆盖,用来自定义thumb、track的CGRect</p>

<pre><code>- (CGRect)minimumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)maximumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)trackRectForBounds:(CGRect)bounds;
- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISegmentedControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/10/uisegmentedcontrol/"/>
    <updated>2014-01-10T12:34:00+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/10/uisegmentedcontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISegmentedControl对象是一个水平控制使多个区段，每个区段用作离散的按钮。分段控件提供了一次小型的手段组合在一起的一些控制。</p>

<p>UISegmentedControl继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）.</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS 5.0新增
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化UISegmentedControl（items可以是NSString类型或者UIImages）</p>

<pre><code>- (id)initWithItems:(NSArray *)items;
</code></pre>

<p>//设置样式 （该样式只在ios2.0~7.0有效果）</p>

<pre><code>UISegmentedControlStyle segmentedControlStyle;
</code></pre>

<p>//设置在点击后是否恢复原样（默认是NO）</p>

<pre><code>BOOL momentary;
</code></pre>

<p>// 设置总选项数</p>

<pre><code>NSUInteger numberOfSegments;
</code></pre>

<p>//是否根据segment的内容改变segment的宽度 (只使用ios5.0，默认为NO)</p>

<pre><code>BOOL apportionsSegmentWidthsByContent;
</code></pre>

<p>//在指定的索引插入一个选项并设置题目</p>

<pre><code>- (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//在指定的索引插入一个选项并设置图片</p>

<pre><code>- (void)insertSegmentWithImage:(UIImage *)image  atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除指定索引的选项</p>

<pre><code>- (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除所有的选项</p>

<pre><code>- (void)removeAllSegments;
</code></pre>

<p>//设置指定索引题目</p>

<pre><code>- (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的标题</p>

<pre><code>- (NSString *)titleForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引的图片</p>

<pre><code>- (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的图片</p>

<pre><code>- (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项的宽度（默认是0）</p>

<pre><code>- (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的宽度</p>

<pre><code>- (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置选项中图片等的左上角的位置</p>

<pre><code>- (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取选项中图片等的左上角的位置</p>

<pre><code>- (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项不可选</p>

<pre><code>- (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//判断指定索引选项是否可选</p>

<pre><code>- (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置默认选项索引</p>

<pre><code>NSInteger selectedSegmentIndex; 
</code></pre>

<p>//设置UISegmentedControl的颜色</p>

<pre><code>UIColor *tintColor; 
</code></pre>

<p><strong>2、iOS 5.0新增</strong></p>

<p>//设置在某个状态下的背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>//获取在某个状态下的背景图片</p>

<pre><code>- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics   
</code></pre>

<p>//设置分割线背景图片</p>

<pre><code>- (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetCT
</code></pre>

<p>//获取分割线背景图片</p>

<pre><code>- (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMeE 
</code></pre>

<p>//设置文字显示样式</p>

<pre><code>- (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
</code></pre>

<p>//获取文字显示样式</p>

<pre><code>- (NSDictionary *)titleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//设置选项中内容的调整位置</p>

<pre><code>- (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics; 
</code></pre>

<p>//获取选项中内容的调整位置</p>

<pre><code>- (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIPageControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/09/uipagecontrol/"/>
    <updated>2014-01-09T12:33:46+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/09/uipagecontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIPageControl继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。您可以使用UIPageControl类来创建和管理页面控件。一个页面控件显示一个水平一系列的点，每个对应一个页面应用程序的文档（或其他数据模型实体）中。当前浏览的页面是由一个白色的圆点表示。</p>

<p>当用户点击一个页面控件移动到下一页或上一页，控制处理由委托发送UIControlEventValueChanged事件。然后委托可以评估当前属性来确定要显示的页面。网页控制在任何一个方向前进只有一个页面。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS6.0新增
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 指定页面个数（默认为0）</p>

<pre><code>NSInteger numberOfPages;
</code></pre>

<p>// 当前选中的页面（默认为0，范围为0 ～ numberOfPages-1）</p>

<pre><code>NSInteger currentPage;
</code></pre>

<p>// 如果在numberOfPages为1的情况下隐藏指示器，可以将hideForSinglePage的值设为YES。默认情况下，即使只有一个页面，指示器也会显示进来。</p>

<pre><code>BOOL hidesForSinglePage;
</code></pre>

<p>// 如果你希望直到有时间执行完你的操作之后，才更新当前指示器当前指示页，可以将 defersCurrentPageDisPlay 设为YES。这样的话你必须调用控件的 updateCurentPageDisPlay 来更新当前页</p>

<pre><code>BOOL defersCurrentPageDisplay;
</code></pre>

<p>// 更新当前页</p>

<pre><code>- (void)updateCurrentPageDisplay;
</code></pre>

<p>// 返回接受者的边界大小，与容纳被给的页面数有关</p>

<pre><code>- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;
</code></pre>

<p><strong>2、iOS6.0新增</strong>
// 未选中的点的颜色</p>

<pre><code>UIColor *pageIndicatorTintColor;
</code></pre>

<p>// 当前点颜色</p>

<pre><code>UIColor *currentPageIndicatorTintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIDatePicker详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/09/uidatepicker/"/>
    <updated>2014-01-09T12:33:27+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/09/uidatepicker</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>该的UIDatePicker类实现使用多个车轮转动，以允许用户选择日期和时间的对象。UIDatePicker iPhone的例子是定时器和时钟应用程序的闹钟（设置闹钟）窗格。您也可以使用日期选择器作为一个倒数计时器。</p>

<p>如果配置正确，一个的UIDatePicker对象发送一个动作消息，当一个用户完成旋转的轮子之一更改日期或时间，相关的控制事件是UIControlEventValueChanged 。一个的UIDatePicker对象呈现倒数计时，但没有实现它，应用程序必须设立的NSTimer对象，并为他们倒计数更新秒。</p>

<p>UIDatePicker不是从UIPickerView的继承，而是继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。，但它管理的自定义选择器视图对象作为一个子视图。</p>

<!--more-->


<pre><code>typedef enum {
    //根据区域设置,显示小时,分钟,并指定AM/PM(例如:6|53|PM)
    UIDatePickerModeTime,
    //根据区域设置,显示月,日,年(例如:November|15|2007)
    UIDatePickerModeDate, 
    //根据区域设置,显示日期(星期,月,日),小时,分钟,并指定AM/PM(例如:Wed Nov 15|6|53|PM)
    UIDatePickerModeDateAndTime,
    //显示小时,分钟(例如:1|53)  
    UIDatePickerModeCountDownTimer
} UIDatePickerMode;
</code></pre>

<p>// 设置UIDatePicker的显示模式(默认为UIDatePickerModeDateAndTime)</p>

<pre><code>UIDatePickerMode datePickerMode; 
</code></pre>

<p>//设置为语言显示</p>

<pre><code>NSLocale   *locale;   
</code></pre>

<p>// 设置日历</p>

<pre><code>NSCalendar *calendar;
</code></pre>

<p>// 设置时区</p>

<pre><code>NSTimeZone *timeZone; 
</code></pre>

<p>// 设置当前显示时间</p>

<pre><code>NSDate *date;
</code></pre>

<p>//如果animated为YES,时间轮会自动显示新的时间</p>

<pre><code>- (void)setDate:(NSDate *)date animated:(BOOL)animated;        
</code></pre>

<p>// 设置显示最小时间</p>

<pre><code>NSDate *minimumDate;
</code></pre>

<p>// 设置显示最大时间（此处为当前时间）</p>

<pre><code>NSDate *maximumDate;
</code></pre>

<p>//用于UIDatePickerModeCountDownTimer,否则忽略.默认为0.0.最大限制为23:59 (86,399秒)</p>

<pre><code>NSTimeInterval countDownDuration;
</code></pre>

<p>//设置分钟之间的间隔.间隔必须均匀的分为60.默认为1.最小为1,最大为30</p>

<pre><code>NSInteger      minuteInterval;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIButton详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/08/uibutton/"/>
    <updated>2014-01-08T12:33:18+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/08/uibutton</id>
    <content type="html"><![CDATA[<p>引言</p>

<p>UIButton的类是一个UIControl子类，它实现了在触摸屏上的按钮。触摸一个按钮拦截事件和动作消息发送到目标对象时，它的挖掘。设定的目标和行动方法都继承自UIControl。这个类提供了方法来设置标题，图像，按钮等外观属性。通过使用set方法，你可以指定一个不同的外观为每个按钮状态。</p>

<!--more-->


<p>目录</p>

<p>// 初始化 button 样式</p>

<pre><code>+ (id)buttonWithType:(UIButtonType)buttonType;
</code></pre>

<p>// 每边（左，右，顶部和底部）可以有不同的值。使用UIEdgeInsetsMake功能设置图片和文字的位置(默认为UIEdgeInsetsZero)</p>

<pre><code>UIEdgeInsets contentEdgeInsets; 
</code></pre>

<p>// 设置标题、图片的边缘值（默认UIEdgeInsetsZero）</p>

<pre><code>UIEdgeInsets titleEdgeInsets;                
</code></pre>

<p>// 决定是否点击按钮会导致其发光</p>

<pre><code>BOOL         reversesTitleShadowWhenHighlighted; 
</code></pre>

<p>// 图像插图或一开始就为每个边缘</p>

<pre><code>UIEdgeInsets imageEdgeInsets;                
</code></pre>

<p>// 决定是否按钮时，突出显示图像的变化。</p>

<pre><code>BOOL         adjustsImageWhenHighlighted;    
</code></pre>

<p>// 决定是否形象的变化时，该按钮被禁用</p>

<pre><code>BOOL         adjustsImageWhenDisabled;       
</code></pre>

<p>// 决定是否点击按钮会导致其发光</p>

<pre><code>BOOL         showsTouchWhenHighlighted;      
</code></pre>

<p>// 设置背景颜色(iOS 5.0)</p>

<pre><code>UIColor     *tintColor;
</code></pre>

<p>// button样式(只读)</p>

<pre><code>UIButtonType buttonType;
</code></pre>

<p>// 设置某个状态下的title</p>

<pre><code>- (void)setTitle:(NSString *)title forState:(UIControlState)state;                    
</code></pre>

<p>// 设置某个状态下的title颜色</p>

<pre><code>- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的阴影颜色</p>

<pre><code>- (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的图片</p>

<pre><code>- (void)setImage:(UIImage *)image forState:(UIControlState)state;                      
</code></pre>

<p>// 设置某个状态下的背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的title属性（iOS 6.0）</p>

<pre><code>- (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state; 
</code></pre>

<p>// 返回一个按钮的状态中使用的字体内容。</p>

<pre><code>- (NSString *)titleForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的字体颜色。</p>

<pre><code>- (UIColor *)titleColorForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的阴影颜色。</p>

<pre><code>- (UIColor *)titleShadowColorForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的图像。</p>

<pre><code>- (UIImage *)imageForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的背景图像</p>

<pre><code>- (UIImage *)backgroundImageForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的内容属性（iOS 6.0）</p>

<pre><code>- (NSAttributedString *)attributedTitleForState:(UIControlState)state;
</code></pre>

<p>// 当前状态的title(只读)</p>

<pre><code>NSString *currentTitle;
</code></pre>

<p>// 当前状态的title字体颜色(只读)</p>

<pre><code>UIColor  *currentTitleColor;
</code></pre>

<p>// 当前状态的阴影(只读)</p>

<pre><code>UIColor  *currentTitleShadowColor;
</code></pre>

<p>// 当前状态的图片(只读)</p>

<pre><code>UIImage  *currentImage;
</code></pre>

<p>// 当前状态的背景图片(只读)</p>

<pre><code>UIImage  *currentBackgroundImage;
</code></pre>

<p>// 当前状态的title的内容属性(只读 iOS 6.0)</p>

<pre><code>NSAttributedString *currentAttributedTitle;
</code></pre>

<p>// UIButton的titleLabel(只读)</p>

<pre><code>UILabel     *titleLabel;
</code></pre>

<p>// UIButton的contentImageView(只读)</p>

<pre><code>UIImageView *imageView;
</code></pre>

<p>// 返回矩形的接收绘制其背景。</p>

<pre><code>- (CGRect)backgroundRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 返回矩形的接收提请其全部内容。</p>

<pre><code>- (CGRect)contentRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 返回title的绘制范围</p>

<pre><code>- (CGRect)titleRectForContentRect:(CGRect)contentRect;
</code></pre>

<p>// 返回图片的绘制范围</p>

<pre><code>- (CGRect)imageRectForContentRect:(CGRect)contentRect;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITableView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/07/uitableview/"/>
    <updated>2014-01-07T12:33:02+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/07/uitableview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UITableView简单来说是一个表视图，继承于UIScrollView，用于显示和编辑信息的分层列表。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、tableView的基本属性及方法
2、访问tableView的画图区
3、访问cells和sections
4、滚动tableView
5、插入、删除、移动行和sections
6、管理和编辑cell
7、管理sections
8、配置
9、iOS5.0新增
10、iOS6.0新增
11、iOS7.0
12、UITableViewDataSource协议
    12.1必须实现
    12.2可选
        12.2.1编辑模式
    12.2.2数据操作  
13、UITableViewDelegate协议（可选）
    13.1定制化
    13.2iOS6新增
    13.3可变高度支持
    13.4iOS7.0新增
    13.5header 和 footer Section 信息
    13.6附属公开的接口
    13.7选择
    13.8编辑
    13.9移动
    13.10缩格
    13.11复制/粘贴
</code></pre>

<p><strong>1、tableView的基本属性及方法</strong></p>

<p>// 初始化</p>

<pre><code>- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;
</code></pre>

<p>// 设置tableView的样式（只读）</p>

<pre><code>UITableViewStyle style;
</code></pre>

<p>// 设置数据资源代理</p>

<pre><code>id &lt;UITableViewDataSource&gt; dataSource;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UITableViewDelegate&gt; delegate;
</code></pre>

<p>// 设置每个row的高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat rowHeight;
</code></pre>

<p>// 设置sectionHeader高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionHeaderHeight;   
</code></pre>

<p>// 设置sectionFooter高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionFooterHeight;   
</code></pre>

<p>//  设置tableView的背景view</p>

<pre><code>UIView *backgroundView;
</code></pre>

<p>// 刷新tableView</p>

<pre><code>- (void)reloadData;
</code></pre>

<p>// 刷新tableView中的section</p>

<pre><code>- (void)reloadSectionIndexTitles;
</code></pre>

<p>// sections的数量</p>

<pre><code>- (NSInteger)numberOfSections;
</code></pre>

<p>// 下标为section中的row数量</p>

<pre><code>- (NSInteger)numberOfRowsInSection:(NSInteger)section;
</code></pre>

<p><strong>2、访问tableView的画图区</strong></p>

<p>// 返回指定section的矩形</p>

<pre><code>- (CGRect)rectForSection:(NSInteger)section; 
</code></pre>

<p>// 返回indexPath指定行的矩形</p>

<pre><code>- (CGRect)rectForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的footer矩形</p>

<pre><code>- (CGRect)rectForFooterInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的header矩形</p>

<pre><code>- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>3、访问cells和sections</strong></p>

<p>// 通过cell得到这个cell在tableView的位置</p>

<pre><code>- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;
</code></pre>

<p>// 根据一个几何点返回indexPath,如果超过边界返回nil</p>

<pre><code>- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;
</code></pre>

<p>// 根据一个几何的矩形返回矩形所覆盖的行,返回是一个indexPath数组</p>

<pre><code>- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;         
</code></pre>

<p>//  根据IndexPath返回cell</p>

<pre><code>- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;            
</code></pre>

<p>//</p>

<pre><code>- (NSArray *)visibleCells;
- (NSArray *)indexPathsForVisibleRows;
</code></pre>

<p><strong>4、滚动tableView</strong></p>

<p>// 滚动到指定位置</p>

<pre><code>- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<p>//  同上</p>

<pre><code>- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<p><strong>5、插入、删除、移动行和sections</strong></p>

<p>// 和endUpdates一起用，让插入、删除、选择操作同时动画，没用过</p>

<pre><code>- (void)beginUpdates;
</code></pre>

<p>//</p>

<pre><code>- (void)endUpdates;
</code></pre>

<p>//根据indexPath数组插入行</p>

<pre><code>- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//根据indexPath数组删除行</p>

<pre><code>- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动一行到另一行</p>

<pre><code>- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//插入sections</p>

<pre><code>- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//删除sections</p>

<pre><code>- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动section</p>

<pre><code>- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p><strong>6、管理和编辑cell</strong></p>

<p>// YES进入编辑模式，tableview cell会出现插入、删除、重排序的控件</p>

<pre><code>BOOL editing;
</code></pre>

<p>// 设置进入退出编辑模式</p>

<pre><code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<p><strong>7、管理sections</strong></p>

<p>//是否允许用户选取一行</p>

<pre><code>BOOL allowsSelection;
</code></pre>

<p>//返回选定行的indexPath,单行</p>

<pre><code>- (NSIndexPath *)indexPathForSelectedRow;
</code></pre>

<p>// 根据indexPath选择一行</p>

<pre><code>- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;
</code></pre>

<p>// 根据indexPath取消选择这一行</p>

<pre><code>- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;
</code></pre>

<p><strong>8、配置</strong></p>

<p>// 指定当tableView中多少行的时候开始显示IndexList，默认的设置是NSIntegerMax，即默认是不显示indexList的</p>

<pre><code>NSInteger sectionIndexMinimumDisplayRowCount;
</code></pre>

<p>// 分隔线的样式(默认为UITableViewCellSeparatorStyleSingleLine)</p>

<pre><code>UITableViewCellSeparatorStyle separatorStyle;
</code></pre>

<p>// cell之间的分割线</p>

<pre><code>UIColor *separatorColor;              
</code></pre>

<p>// 设置headerView</p>

<pre><code>UIView *tableHeaderView;                            
</code></pre>

<p>// 设置footerView</p>

<pre><code>UIView *tableFooterView;                            
</code></pre>

<p>// 必须要实现的方法，与tableView同生同死</p>

<pre><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;  
</code></pre>

<p><strong>9、iOS5.0新增</strong></p>

<p>// 移动section</p>

<pre><code>- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;
</code></pre>

<p>// 移动一行到另一行</p>

<pre><code>- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;
</code></pre>

<p>// 返回选定行的indexPath数组，多行</p>

<pre><code>- (NSArray *)indexPathsForSelectedRows;
</code></pre>

<p>//</p>

<pre><code>- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;
</code></pre>

<p>//  编辑模式时是否可选取一行</p>

<pre><code>BOOL allowsSelectionDuringEditing;
</code></pre>

<p>//  是否选取多行，缺省为NO(iOS 5.0)</p>

<pre><code>BOOL allowsMultipleSelection;
</code></pre>

<p>//  编辑模式时可否选取多行</p>

<pre><code>BOOL allowsMultipleSelectionDuringEditing;
</code></pre>

<p><strong>10、iOS6.0新增</strong></p>

<p>// 我想在numberOfRowsInSection方法内获取该section的header View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;
</code></pre>

<p>// 我想在numberOfRowsInSection方法内获取该section的footer View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;
</code></pre>

<p>// 设置索引号颜色</p>

<pre><code>UIColor *sectionIndexColor;
</code></pre>

<p>// 设置索引号背景颜色</p>

<pre><code>UIColor *sectionIndexTrackingBackgroundColor;
</code></pre>

<p>// 注册（没有测试有什么用)</p>

<pre><code>- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier; 
- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier;
- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;
- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;
</code></pre>

<p><strong>11、iOS7.0</strong></p>

<p>// 预设SectionFooter的高度</p>

<pre><code>CGFloat estimatedSectionFooterHeight;
UIEdgeInsets separatorInset;
UIColor *sectionIndexBackgroundColor;
</code></pre>

<p>// 预设row的高度</p>

<pre><code>CGFloat estimatedRowHeight;     
</code></pre>

<p>// 预设SectionHeader的高度</p>

<pre><code>CGFloat estimatedSectionHeaderHeight; 
</code></pre>

<p><strong>12、UITableViewDataSource协议</strong></p>

<p><strong>12.1必须实现</strong>
// 返回每个section中row的数量</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
</code></pre>

<p>// 返回每个UITableViewCell</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>12.2可选</strong></p>

<p>// 返回section的个数</p>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;              
</code></pre>

<p>//  section headerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section; 
</code></pre>

<p>// section footerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>12.2.1编辑模式</strong></p>

<p>// 设置可编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>12.2.1.1移动</strong></p>

<p>// 设置是否可移动</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 设置索引号</p>

<pre><code>- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView
</code></pre>

<p>// 点击索引触发</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index;
</code></pre>

<p><strong>12.2.2数据操作</strong></p>

<p>// 插入/删除指定数据</p>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 重新排序/移动数据操作</p>

<pre><code>- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
</code></pre>

<p><strong>13、UITableViewDelegate协议（可选）</strong></p>

<p><strong>13.1定制化</strong></p>

<p>// cell将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.2iOS6新增</strong></p>

<p>// HeaderView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// cell结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;
</code></pre>

<p>// HeaderView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p><strong>13.3可变高度支持</strong></p>

<p>// 根据indexPath返回row的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 根据indexPath返回HeaderView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据indexPath返回FooterView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.4iOS7.0新增</strong></p>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的cell的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Header的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Footer的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.5header 和 footer Section 信息</strong></p>

<p>// 根据section创建header section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据section创建footer section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.6附属公开的接口</strong></p>

<p>// 回调设置辅助按钮被点击后的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.7选择</strong></p>

<p>// 回调设置某行是否当被点击后处于高亮状态</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行处于高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行失去高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调某行将要被选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行将要被取消选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经被选中点击的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经取消选中的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.8编辑</strong></p>

<p>// 回调设置某行进入了哪种编辑模式</p>

<pre><code>- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置某行进入删除模式的删除按钮名字</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 是否允许对row进行编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 开始编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 结束编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.9移动</strong></p>

<p>// 移动Row时会把触发，在交换Row位置的时候，必须同时交换DataSource中数据的位置。</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;               
</code></pre>

<p><strong>13.10缩格</strong></p>

<p>// 设置内容缩进</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.11复制/粘贴</strong></p>

<p>// 回调设置某行被长按是否出现菜单栏</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置菜单栏是否显示哪些菜单栏选项</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>

<p>// 回调点击菜单栏选项触发的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIWebView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiwebview/"/>
    <updated>2014-01-05T12:32:39+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiwebview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>在您的应用程序中，您可以使用UIWebView嵌入网页内容。要做到这一点，你只需创建一个UIWebView对象，将其附加到一个窗口，并发送一个请求来加载网页内容。您也可以使用此类前进和后退的网页的历史记录，甚至可以通过编程设置一些网页内容属性。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
4、iOS7新增
5、UIWebViewDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 设置代理</p>

<pre><code>id&lt;UIWebViewDelegate&gt; delegate;
</code></pre>

<p>//  加载一个url地址</p>

<pre><code>- (void)loadRequest:(NSURLRequest *)request;
</code></pre>

<p>// 加载一个html的string</p>

<pre><code>- (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL;
</code></pre>

<p>//</p>

<pre><code>- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>

<p>// 获取web的请求</p>

<pre><code>NSURLRequest *request;
</code></pre>

<p>// 重新加载</p>

<pre><code>- (void)reload; 
</code></pre>

<p>// 停止加载</p>

<pre><code>- (void)stopLoading;
</code></pre>

<p>// 返回</p>

<pre><code>- (void)goBack;
</code></pre>

<p>// 前进</p>

<pre><code>- (void)goForward;
</code></pre>

<p>// 是否能返回(只读)</p>

<pre><code>BOOL canGoBack;
</code></pre>

<p>// 是否能前进（只读)</p>

<pre><code>BOOL canGoForward;
</code></pre>

<p>// 是否正在加载（只读）</p>

<pre><code>BOOL loading;
</code></pre>

<p>// 添加javascript</p>

<pre><code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
</code></pre>

<p>// 默认值为NO，用户不可以放大或缩小页面；如果设置为YES，页面可以通过放大缩小去适应，用户也可以通过手势来放大和缩小</p>

<pre><code>BOOL scalesPageToFit;
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。</p>

<pre><code>BOOL detectsPhoneNumbers;
</code></pre>

<p>//  把网页上内容转换成可点击的链接类型</p>

<pre><code>UIDataDetectorTypes dataDetectorTypes;
</code></pre>

<p>// 这个值决定了用内嵌HTML5播放视频还是用本地的全屏控制。为了内嵌视频播放，不仅仅需要在这个页面上设置这个属性，还必须的是在HTML中的video元素必须包含webkit-playsinline属性。(iPhone默认为NO, iPad默认为YES)</p>

<pre><code>BOOL allowsInlineMediaPlayback;
</code></pre>

<p>// 在iPhone和iPad上默认使YES。这个值决定了HTML5视频可以自动播放还是需要用户去启动播放</p>

<pre><code>BOOL mediaPlaybackRequiresUserAction; 
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 获取webView中的scrollView(只读)</p>

<pre><code>UIScrollView *scrollView;
</code></pre>

<p>// 这个值决定了从这个页面是否可以Air Play(默认YES)</p>

<pre><code>BOOL mediaPlaybackAllowsAirPlay; 
</code></pre>

<p><strong>3、iOS6新增</strong></p>

<p>// 这个值决定了网页内容的渲染是否在把内容全部加载到内存中再去处理。如果设置为YES，只有网页内容加载到内存里了才会去渲染(默认值为NO)</p>

<pre><code>BOOL suppressesIncrementalRendering; 
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。(默认为YES)</p>

<pre><code>BOOL keyboardDisplayRequiresUserAction;
</code></pre>

<p><strong>4、iOS7新增</strong></p>

<p>// 随意翻阅模式</p>

<pre><code>UIWebPaginationMode paginationMode;
UIWebPaginationBreakingMode paginationBreakingMode;
CGFloat pageLength;
CGFloat gapBetweenPages;
</code></pre>

<p>当在原生应用中，使用 UIWebView 实现丰富内容时，或者对于原生 webapp，我们可以为了电子书阅读体验使用 Paginate （随意翻阅）特性，避免垂直滚动条（类似 Windows 8 应用体验）。如果应用显示动态内容，这一特性是完美的，我们不能预先优化分页。有不同的 Objective-C 属性配置分页过程。要启用它，需要这么做：</p>

<pre><code>myWebView.paginationMode = UIWebPaginationModeLeftToRight;
myWebView.paginationBreakingMode = UIWebPaginationBreakingModePage;
myWebView.gapBetweenPages = 50; 
</code></pre>

<p>// 获取页码总数(只读)</p>

<pre><code>NSUInteger pageCount;
</code></pre>

<p><strong>5、UIWebViewDelegate协议（可选）</strong></p>

<p>//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。</p>

<pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
</code></pre>

<p>// 开始加载的时候执行该方法。</p>

<pre><code>- (void)webViewDidStartLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载完成的时候执行该方法。</p>

<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载出错的时候执行该方法。</p>

<pre><code>- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISearchBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uisearchbar/"/>
    <updated>2014-01-05T12:32:30+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uisearchbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong>
UISearchBar类实现一个文本字段控制基于文本的搜索，它是继承于UIView(有关UIView的介绍请到《视图鼻祖之UIView详解》)。控制输入文字，一个搜索按钮，书签按钮和取消按钮提供了一个文本字段。该对象的UISearchBar实际上并不执行任何搜查。您可以使用委托符合UISearchBarDelegate协议对象，实现这些输入文字和点击按钮的事件。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性和方法
2、iOS5新增
3、iOS7新增
4、UISearchBarDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性和方法</strong></p>

<p>// 设置控件样式（默认UIBarStyleDefault）</p>

<pre><code>UIBarStyle              barStyle;              
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UISearchBarDelegate&gt; delegate;              
</code></pre>

<p>// 控件上面显示的文字</p>

<pre><code>NSString               *text;                  
</code></pre>

<p>// 显示在顶部的单行文字，通常作为一个提示行</p>

<pre><code>NSString               *prompt;                
</code></pre>

<p>// 半透明的提示文字，输入搜索内容会消失</p>

<pre><code>NSString               *placeholder;           
</code></pre>

<p>// 是否在控件的右端显示一个书的按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsBookmarkButton;   
</code></pre>

<p>// 是否显示cancel按钮</p>

<pre><code>BOOL                    showsCancelButton; 
- (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated;    
</code></pre>

<p>// 是否在控件的右端显示搜索结果按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsSearchResultsButton; 
</code></pre>

<p>// 搜索结果按钮是否被选中</p>

<pre><code>BOOL searchResultsButtonSelected; 
</code></pre>

<p>// bar的颜色(具有渐变效果)</p>

<pre><code>UIColor *tintColor;
UIColor *barTintColor(iOS7.0);

UISearchBarStyle searchBarStyle (iOS7.0);
</code></pre>

<p> // 指定控件是否会有透明效果</p>

<pre><code>BOOL translucent;
</code></pre>

<p>// 设置在什么情况下自动大写（默认UITextAutocapitalizationTypeNone）</p>

<pre><code>UITextAutocapitalizationType autocapitalizationType;  
</code></pre>

<p>// 对于文本对象自动校正风格 （默认UITextAutocorrectionTypeDefault）</p>

<pre><code>UITextAutocorrectionType     autocorrectionType;      
</code></pre>

<p>//  （默认UITextSpellCheckingTypeDefault）</p>

<pre><code>UITextSpellCheckingType      spellCheckingType;       
</code></pre>

<p>// 键盘样式 （默认UIKeyboardTypeDefault）</p>

<pre><code>UIKeyboardType               keyboardType;            
</code></pre>

<p>// 搜索栏下部的选择栏，数组里面的内容是按钮的标题</p>

<pre><code>NSArray   *scopeButtonTitles;
</code></pre>

<p>// 搜索栏下部的选择栏按钮的个数</p>

<pre><code>NSInteger  selectedScopeButtonIndex; 
</code></pre>

<p>// 控制搜索栏下部的选择栏是否显示出来</p>

<pre><code>BOOL       showsScopeBar; 
</code></pre>

<p>// 提供一个遮盖视图</p>

<pre><code>UIView *inputAccessoryView;
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 设置背景图片</p>

<pre><code>UIImage *backgroundImage;
</code></pre>

<p>// 设置scope的背景颜色</p>

<pre><code>UIImage *scopeBarBackgroundImage;


- (void)setSearchFieldBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state;
- (UIImage *)searchFieldBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下search的ico图片</p>

<pre><code>- (void)setImage:(UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 获取某个状态下的ico图片</p>

<pre><code>- (UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下scopeBarButton的背景图片</p>

<pre><code>- (void)setScopeBarButtonBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; 
</code></pre>

<p>// 获取某个状态下scopeBarButton的背景图片</p>

<pre><code>- (UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
- (UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
- (NSDictionary *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchFieldBackgroundPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchTextPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>- (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon;
- (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon;
</code></pre>

<p><strong>3、iOS7新增</strong></p>

<p>//</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;  
</code></pre>

<p>//</p>

<pre><code>- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p><strong>4、UISearchBarDelegate协议（可选）</strong></p>

<p>// 是否允许编辑，如果返回为NO则不能成为第一响应者</p>

<pre><code>- (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar;                      
</code></pre>

<p>// 开始编辑</p>

<pre><code>- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar;                     
</code></pre>

<p>// 是否允许结束编辑</p>

<pre><code>- (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar;                        
</code></pre>

<p>// 结束编辑</p>

<pre><code>- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar;                       
</code></pre>

<p>// 文本内容改变时调用</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText;   
</code></pre>

<p>// 如果允许继续输入，那么返回YES，否则返回NO。（可以对字数进行限制）</p>

<pre><code>- (BOOL)searchBar:(UISearchBar *)searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text; 
</code></pre>

<p>// 当搜索按钮被点击的时候</p>

<pre><code>- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar;                     
</code></pre>

<p>//</p>

<pre><code>- (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar;                   
</code></pre>

<p>// cancel按钮点击时调用</p>

<pre><code>- (void)searchBarCancelButtonClicked:(UISearchBar *) searchBar;                    
</code></pre>

<p>// ResultsList按钮被点击时调用</p>

<pre><code>- (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar; 
</code></pre>

<p>// 还有一个很重要的事情，设了按钮就要给他们安排功能。所以说，我们要实现这个代理UISearchBarDelegate里的这个方法searchBar:selectedScopeButtonIndexDidChange:告诉表格，你选择的范围是啥。</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIScrollView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiscrollview/"/>
    <updated>2014-01-05T12:32:18+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiscrollview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 监控目前滚动的位置(默认CGPointZero)</p>

<pre><code>CGPoint                      contentOffset; 
- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;
</code></pre>

<p>// 滚动范围的大小(默认CGSizeZero)</p>

<pre><code>CGSize                       contentSize; 
</code></pre>

<p>// 视图在scrollView中的位置(UIEdgeInsetsZero)</p>

<pre><code>UIEdgeInsets                 contentInset;                   
</code></pre>

<p>// 设置协议</p>

<pre><code>id&lt;UIScrollViewDelegate&gt;      delegate;                       
</code></pre>

<p>// 指定控件是否只能在一个方向上滚动(默认为NO)</p>

<pre><code>BOOL directionalLockEnabled;         
</code></pre>

<p>// 控制控件遇到边框是否反弹(默认为YES)</p>

<pre><code>BOOL                         bounces;                        
</code></pre>

<p>// 控制垂直方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceVertical;           
</code></pre>

<p>// 控制水平方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceHorizontal;         
</code></pre>

<p>// 控制控件是否整页翻动(默认为NO)</p>

<pre><code>BOOL          pagingEnabled;                  
</code></pre>

<p>// 控制控件是否能滚动</p>

<pre><code>BOOL          scrollEnabled;                  
</code></pre>

<p>// 控制是否显示水平方向的滚动条</p>

<pre><code>BOOL                         showsHorizontalScrollIndicator; 
</code></pre>

<p>// 控制是否显示垂直方向的滚动条</p>

<pre><code>BOOL                         showsVerticalScrollIndicator;   
</code></pre>

<p>// 指定滚动条在scrollerView中的位置</p>

<pre><code>UIEdgeInsets                 scrollIndicatorInsets;          
</code></pre>

<p>// 设定滚动条的样式</p>

<pre><code>UIScrollViewIndicatorStyle   indicatorStyle;                 
</code></pre>

<p>// 改变scrollerView的减速点位置</p>

<pre><code>CGFloat                      decelerationRate;
</code></pre>

<p>// UITableView 在EnablePage状态下滚动到指定的页面上</p>

<pre><code>- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>//  这个很有用，闪一下滚动条，暗示是否有可滚动的内容。可以在ViewDidAppear或[table reload]之后调用。</p>

<pre><code>- (void)flashScrollIndicators; 
</code></pre>

<p>// 监控当前目标是否正在被跟踪(只读)</p>

<pre><code>BOOL tracking;
</code></pre>

<p>//  监控当前目标是否正在被拖拽(只读)</p>

<pre><code>BOOL dragging;
</code></pre>

<p>// 监控当前目标是否正在减速(只读)</p>

<pre><code>BOOL decelerating;    
</code></pre>

<p>// 控制视图是否延时调用开始滚动的方法</p>

<pre><code>BOOL delaysContentTouches;       
</code></pre>

<p>// 控制控件是否接触取消touch的事件</p>

<pre><code>BOOL canCancelContentTouches;
</code></pre>

<p>//返回yes 是不滚动 scroll 返回no 是滚动scroll</p>

<pre><code>- (BOOL)touchesShouldBegin:(NSSet *)touches withEvent:(UIEvent *)event inContentView:(UIView *)view;
</code></pre>

<p>//NO scroll不可以滚动 YES scroll可以滚动</p>

<pre><code>- (BOOL)touchesShouldCancelInContentView:(UIView *)view;
</code></pre>

<p>// 缩小的最小比例</p>

<pre><code>CGFloat minimumZoomScale;     
</code></pre>

<p>// 放大的最大比例</p>

<pre><code>CGFloat maximumZoomScale;     
</code></pre>

<p>// 设置变化比例</p>

<pre><code>CGFloat zoomScale;  
- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated;
</code></pre>

<p>//  设置变化范围</p>

<pre><code>- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>// 控制缩放的时候是否会反弹</p>

<pre><code>BOOL  bouncesZoom;
</code></pre>

<p>// 判断控件的大小是否正在改变(只读)</p>

<pre><code>BOOL zooming;
</code></pre>

<p>// 判断是否正在进行缩放反弹(只读)</p>

<pre><code>BOOL zoomBouncing;
</code></pre>

<p>// 控制控件滚动到顶部</p>

<pre><code>BOOL  scrollsToTop;
</code></pre>

<p>// Use these accessors to configure the scroll view&rsquo;s built-in gesture recognizers.
// Do not change the gestures&#8217; delegates or override the getters for these properties.
// 只读</p>

<pre><code>UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);
</code></pre>

<p>// <code>pinchGestureRecognizer</code> will return nil when zooming is disabled.
// 只读</p>

<pre><code>UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);

UIScrollViewKeyboardDismissMode keyboardDismissMode NS_AVAILABLE_IOS(7_0); // default is UIScrollViewKeyboardDismissModeNone
</code></pre>

<p>@end</p>

<p>UIScrollViewDelegate协议（可选）</p>

<p>//只要滚动了就会触发</p>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView;
</code></pre>

<p>// 当scrollview发生缩放的时相应</p>

<pre><code>- (void)scrollViewDidZoom:(UIScrollView *)scrollView;
</code></pre>

<p>// 将要拖拽视图</p>

<pre><code>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;
</code></pre>

<p>// 开始拖拽视图</p>

<pre><code>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset;
</code></pre>

<p>// 完成拖拽</p>

<pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;
</code></pre>

<p>// 将开始降速时</p>

<pre><code>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;   
</code></pre>

<p>// 减速停止了时执行</p>

<pre><code>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;      
</code></pre>

<p>// 滚动动画停止时执行,代码改变时出发,也就是setContentOffset改变时</p>

<pre><code>- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; 
</code></pre>

<p>// 设置放大缩小的视图，要是uiscrollview的subview</p>

<pre><code>- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;     
</code></pre>

<p>// 当scrollview将要发生缩放的时相应</p>

<pre><code>- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view; 
</code></pre>

<p>// 完成放大缩小时调用</p>

<pre><code>- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale; 
</code></pre>

<p>// //如果你不是完全滚动到滚轴视图的顶部，你可以轻点状态栏，那个可视的滚轴视图会一直滚动到顶部，那是默认行为，你可以通过该方法返回NO来关闭它 。点击状态栏，scroll view回到顶部，如果想实现这个，实现代理方法scrollViewShouldScrollToTop返回YES，当完成时，给代理发送scrollViewDidScrollToTop: 消息</p>

<pre><code>- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;   
- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIAlertView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uialertview/"/>
    <updated>2014-01-05T12:32:06+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uialertview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 初始化UIAlertView</p>

<pre><code>- (id)initWithTitle:(NSString *)title message:(NSString *)message delegate:(id &lt;UIAlertViewDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UIAlertViewDelegate&gt; delegate;
</code></pre>

<p>// 设置title</p>

<pre><code>NSString *title;
</code></pre>

<p>// 显示的消息文本文字</p>

<pre><code>NSString *message;
</code></pre>

<p>// 添加一个Button到AlertView并且指定按钮显示的文字，并且返回它的索引(从0开始，cancelButton的索引是0)</p>

<pre><code>- (NSInteger)addButtonWithTitle:(NSString *)title; 
</code></pre>

<p>// 通过下标获取button的title</p>

<pre><code>- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// button的总数(只读)</p>

<pre><code>NSInteger numberOfButtons;
</code></pre>

<p>// 取消按钮的下标</p>

<pre><code>NSInteger cancelButtonIndex;
</code></pre>

<p>// 第一个其他button的下标(只读)</p>

<pre><code>NSInteger firstOtherButtonIndex;
</code></pre>

<p>// 是否显示了(只读)</p>

<pre><code>BOOL visible;
</code></pre>

<p>// 动画显示alert.</p>

<pre><code>- (void)show;
</code></pre>

<p>// 隐藏按下指定索引值的按钮之后，隐藏AlertView，并制定是否启动动画效果</p>

<pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre>

<p>// 设置alertView样式（iOS5.0）</p>

<pre><code>UIAlertViewStyle alertViewStyle;
</code></pre>

<p>// 返回指定索引值的TextField ，这个API仅存在于IOS5.0以上</p>

<pre><code>- (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex;
</code></pre>

<p>UIAlertViewDelegate协议（可选）</p>

<p>// 当一个指定索引的按钮被点击的时候，回调此方法，buttonIndex是按钮的索引值，从0开始</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 当用户按下HOME键的时候，回调此方法，用户点击Cancel按钮的时候不会回调此方法</p>

<pre><code>- (void)alertViewCancel:(UIAlertView *)alertView;
</code></pre>

<p>// 开始显示View的动画之前进行回调</p>

<pre><code>- (void)willPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 显示动画完成之后进行回调</p>

<pre><code>- (void)didPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 将要开始View隐藏动画的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 
</code></pre>

<p>// 当View的隐藏动画结束的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 编辑任何默认的字段添加的风格之后调用</p>

<pre><code>- (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIActionSheet详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiactionsheet/"/>
    <updated>2014-01-05T12:31:54+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiactionsheet</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p>目录</p>

<p>// 初始化UIActionSheet上的button按钮</p>

<pre><code>- (id)initWithTitle:(NSString *)title delegate:(id&lt;UIActionSheetDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle destructiveButtonTitle:(NSString *)destructiveButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;
</code></pre>

<p>// 设置UIActionSheet代理</p>

<pre><code>id&lt;UIActionSheetDelegate&gt; delegate;    // weak reference
</code></pre>

<p>// 设置UIActionSheet的title</p>

<pre><code>NSString *title;
</code></pre>

<p>// 设置UIActionSheet的样式（默认为UIActionSheetStyleAutomatic）</p>

<pre><code>UIActionSheetStyle actionSheetStyle;
</code></pre>

<p>// 通过按钮的title获取这个按钮在UIActionSheet上的下标</p>

<pre><code>- (NSInteger)addButtonWithTitle:(NSString *)title;
</code></pre>

<p>// 通过下标获得按钮的title</p>

<pre><code>- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 获取按钮的总个数(只读)</p>

<pre><code>NSInteger numberOfButtons;
</code></pre>

<p>// 获取取消按钮的下标</p>

<pre><code>NSInteger cancelButtonIndex;
</code></pre>

<p>// 红色按钮的下标（翻译成破坏性的，其实就是那个红色的按钮）</p>

<pre><code>NSInteger destructiveButtonIndex;
</code></pre>

<p>// 获取第一个其他按钮的下标(只读)</p>

<pre><code>NSInteger firstOtherButtonIndex;
</code></pre>

<p>// UIActionSheet是否可见（只读）</p>

<pre><code>BOOL visible;
</code></pre>

<p>// show a sheet animated. you can specify either a toolbar, a tab bar, a bar butto item or a plain view. We do a special animation if the sheet rises from
// a toolbar, tab bar or bar button item and we will automatically select the correct style based on the bar style. if not from a bar, we use
// UIActionSheetStyleDefault if automatic style set
// 如果要将ActonSheet 与工具栏或者标签栏对齐，可以使用showFromToolBar(showFromTabBar)</p>

<pre><code>- (void)showFromToolbar:(UIToolbar *)view;
- (void)showFromTabBar:(UITabBar *)view;
</code></pre>

<p>// showFromBarButtonItem，就是popover会指向个BarButtonItem。在iPhone上只能使用showInView，如果是universal app，要用些if来判断。用delegate来知道用户选择了什么</p>

<pre><code>- (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>// showFromRect，在ipad上指定个矩形区域，它会在其上显示个popover</p>

<pre><code>- (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;
</code></pre>

<p>// 显示在iphone的中间位置，它会从下往上滑动；在ipad上它会放在中间，所以在ipad上从不用showInView</p>

<pre><code>- (void)showInView:(UIView *)view;
</code></pre>

<p>// hides alert sheet or popup. use this method when you need to explicitly dismiss the alert.
// it does not need to be called if the user presses on a button</p>

<pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre>

<p>UIActionSheetDelegate协议（可选）</p>

<p>// 点击UIActionSheet会调用的函数，buttonIndex为所点击button在UIActionSheet的下标</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 点击取消按钮会调用的函数</p>

<pre><code>- (void)actionSheetCancel:(UIActionSheet *)actionSheet;
</code></pre>

<p>// 将来显示ActionSheet</p>

<pre><code>- (void)willPresentActionSheet:(UIActionSheet *)actionSheet;
</code></pre>

<p>// 显示ActionSheet</p>

<pre><code>- (void)didPresentActionSheet:(UIActionSheet *)actionSheet;
</code></pre>

<p>// ActionSheet将要消失</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// ActionSheet消失</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITableViewCell详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uitableviewcell/"/>
    <updated>2014-01-04T12:31:43+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uitableviewcell</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 初始化方法</p>

<pre><code>- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier;
</code></pre>

<p>// cell上默认图片显示view，（默认为nil,当需要的时候才会被创建）</p>

<pre><code>UIImageView *imageView;
</code></pre>

<p>// cell上默认的UILabel(默认为nil，当需要的时候才会被创建)</p>

<pre><code>UILabel     *textLabel;
</code></pre>

<p>//  cell简介（默认为nil，如果当前的style支持的话需要时将会被创建）</p>

<pre><code>UILabel     *detailTextLabel;
</code></pre>

<p>// 与cell自带的删除按钮平级的view</p>

<pre><code>UIView *contentView;
</code></pre>

<p>// 背景view</p>

<pre><code>UIView *backgroundView;
</code></pre>

<p>// 多选时的背景view</p>

<pre><code>UIView *multipleSelectionBackgroundView;
</code></pre>

<p>// cell的标识符</p>

<pre><code>NSString *reuseIdentifier;
</code></pre>

<p>//  重用cell时会调用这个函数</p>

<pre><code>- (void)prepareForReuse; 
</code></pre>

<p>// 选中时的cell样式（默认为UITableViewCellSelectionStyleBlue）</p>

<pre><code>UITableViewCellSelectionStyle   selectionStyle; 
</code></pre>

<p>// 是否选中</p>

<pre><code>BOOL         selected; 
</code></pre>

<p>// 是否高亮</p>

<pre><code>BOOL      highlighted;
</code></pre>

<p>// 设置cell为选中状态</p>

<pre><code>- (void)setSelected:(BOOL)selected animated:(BOOL)animated;                  
</code></pre>

<p>// 设置为高亮状态</p>

<pre><code>- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
</code></pre>

<p>// 设置cell的编辑样式</p>

<pre><code>UITableViewCellEditingStyle editingStyle;
</code></pre>

<p>// showsReorderControl = YES时Cell显示移动按钮（默认为NO）</p>

<pre><code>BOOL showsReorderControl;        // default is NO
</code></pre>

<p>// 没有出现delete控件和行头控件，可cell的宽度还是变了，有没有办法使cell在edit模式下，宽度不改变</p>

<pre><code>BOOL shouldIndentWhileEditing;
</code></pre>

<p>// 设置cell的样式</p>

<pre><code>UITableViewCellAccessoryType accessoryType;
</code></pre>

<p>UITableViewCellAccessoryNone;//cell没有任何的样式</p>

<p>UITableViewCellAccessoryDisclosureIndicator;//cell的右边有一个小箭头，距离右边有十几像素；</p>

<p>UITableViewCellAccessoryDetailDisclosureButton;//cell右边有一个蓝色的圆形button；</p>

<p>UITableViewCellAccessoryCheckmark;//cell右边的形状是对号；</p>

<p>// 除此上面之外，如果你想使用自定义附件按钮的其他样式，必需使用UITableView的accessoryView属性</p>

<pre><code>UIView *accessoryView;
</code></pre>

<p>// 设置当cell进入编辑模式时的辅助按钮样式</p>

<pre><code>UITableViewCellAccessoryType editingAccessoryType;
</code></pre>

<p>// 自定义cell进入编辑模式后辅助按钮</p>

<pre><code>UIView *editingAccessoryView;       
</code></pre>

<p>// 获取cell的缩进级别</p>

<pre><code>NSInteger indentationLevel;           
</code></pre>

<p>// 获取cell的缩进宽度</p>

<pre><code>CGFloat indentationWidth;
</code></pre>

<p>// 设置是否处于编辑模式</p>

<pre><code>BOOL           editing;
</code></pre>

<p>// 设置编辑模式</p>

<pre><code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<p>// 当前是否显示delete按钮</p>

<pre><code>BOOL showingDeleteConfirmation;  // currently showing "Delete" button
</code></pre>

<p>// 这两个方法应该在子类中覆写，当前Cell的状态发生改变的时刻就会触发这些方法，可以在这些方法中进行一些额外的操作。（例如：cell被点击以后就会进入UITableViewCellStateShowingDeleteConfirmationMask 状态）</p>

<pre><code>- (void)willTransitionToState:(UITableViewCellStateMask)state;
- (void)didTransitionToState:(UITableViewCellStateMask)state;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UINavigaionBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uinavigaionbar/"/>
    <updated>2014-01-04T12:31:24+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uinavigaionbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p><strong>1、UINavigaionBar</strong></p>

<p>// 设置bar的样式</p>

<pre><code>UIBarStyle barStyle;
</code></pre>

<p>// 设置代理</p>

<pre><code>id delegate;
</code></pre>

<p>// 设置是否透明（在iOS6中默认为NO,如果barStyle为UIBarStyleBlackTranslucent为YES）</p>

<pre><code>BOOL translucent;
</code></pre>

<p>// Pushing a navigation item displays the item&rsquo;s title in the center of the navigation bar.
// 方法将新的UINavigationItem 压入栈</p>

<pre><code>- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;
</code></pre>

<p>//  方法将顶部的UINavigationItem 推出栈</p>

<pre><code>- (UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; // Returns the item that was popped.
</code></pre>

<p>// 获取顶部的item（只读）</p>

<pre><code>UINavigationItem *topItem;
</code></pre>

<p>// 获取返回的item</p>

<pre><code>UINavigationItem *backItem;
</code></pre>

<p>// 设置items组</p>

<pre><code>NSArray *items;
- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 设置背景颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 设置背影颜色（iOS7.0新增）</p>

<pre><code>UIColor *barTintColor;
</code></pre>

<p>iOS5新增</p>

<p>//  根据屏幕状态设置背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics;

如果支持竖屏，那么应该设置UIBarMetricsDefault
[navBar setBackgroundImage:[UIImage imageNamed:@"navBarBg.png"] forBarMetrics:UIBarMetricsDefault];

如果支持横屏，那么应该设置UIBarMetricsLandscapePhone
[navBar setBackgroundImage:[UIImage imageNamed:@"navBarBg.png"] forBarMetrics:UIBarMetricsLandscapePhone];
</code></pre>

<p>// 根据屏幕状态获取背景图片</p>

<pre><code>- (UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 对titleText设置字体属性</p>

<pre><code>NSDictionary *titleTextAttributes;
</code></pre>

<p>// 根据屏幕状态设置标题的垂直偏移量</p>

<pre><code>- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 根据屏幕状态获得标题的垂直偏移量</p>

<pre><code>- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>iOS6新增</p>

<p>// 设置阴影图片</p>

<pre><code> UIImage *shadowImage;
</code></pre>

<p>iOS7新增</p>

<p>// iOS7下设置背景图片(iOS上默认是64，可以通过这个方法设置成44)。</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 获取图片</p>

<pre><code>- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 如果想要用自己的图片替换V型，可以设置图片的backIndicatorImage backIndicatorTransitionMaskImage。</p>

<pre><code>UIImage *backIndicatorImage;
UIImage *backIndicatorTransitionMaskImage;

如下代码所示：
[[UINavigationBar appearance] setBackIndicatorImage:[UIImage imageNamed:@"backBtton.png"]]; 
[[UINavigationBar appearance] setBackIndicatorTransitionMaskImage:[UIImage imageNamed:@"backBtton.png"]]; 
</code></pre>

<p>UINavigationBarDelegate协议（可选）
// 是否支持pushItem，如果返回NO就不能。</p>

<pre><code>- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item;
</code></pre>

<p>// pushItem时会调用的函数</p>

<pre><code>- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item;
</code></pre>

<p>// 是否支持popItem，如果返回NO就不能。</p>

<pre><code>- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item;
</code></pre>

<p>// popItem时会调用的函数</p>

<pre><code>- (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item;
</code></pre>

<p><strong>2、UINavigationItem </strong></p>

<p>// 初始化item的title</p>

<pre><code>- (id)initWithTitle:(NSString *)title;
</code></pre>

<p>// 设置item的title</p>

<pre><code>NSString        *title; 
</code></pre>

<p>// 设置返回barButtonItem</p>

<pre><code>UIBarButtonItem *backBarButtonItem;
</code></pre>

<p>// 设置titleView</p>

<pre><code>UIView          *titleView;
</code></pre>

<p>// 一个显示在顶部导航栏的单行文本</p>

<pre><code>NSString *prompt;    
</code></pre>

<p>// 是否隐藏返回按钮</p>

<pre><code>BOOL hidesBackButton; 
</code></pre>

<p>// 隐藏返回按钮</p>

<pre><code>- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated;
</code></pre>

<p>// 设置左边按钮</p>

<pre><code>UIBarButtonItem *leftBarButtonItem;
- (void)setLeftBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>// 设置右边按钮</p>

<pre><code>UIBarButtonItem *rightBarButtonItem;
- (void)setRightBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>iOS5新增</p>

<pre><code>NSArray *leftBarButtonItems;
NSArray *rightBarButtonItems;
- (void)setLeftBarButtonItems:(NSArray *)items animated:(BOOL)animated; 
- (void)setRightBarButtonItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 当某个UIViewController自定义了LeftBarButtonItem(如：返回首页的Home按钮)，同时这个UIViewController存在被其他UIViewController，pushViewController(即：从其他试图控制器，跳转到自定义LeftBarButtonItem的试图控制器),这时如果没有在自定义LeftBarButtonItem设置UINavigationItem的属性leftItemsSupplementBackButton，那么系统会默认为NO，那麽其他控制器跳转到此控制器时，导航栏就只会展示你自定的LeftBarButtonItem，而不会显示后退按钮。但这样很不友好。如果想显示后退按钮，这在自定义LeftBarButtonItem时，设置UINavigationItem的属性leftItemsSupplementBackButton为YES即可。</p>

<pre><code>BOOL leftItemsSupplementBackButton;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIToolBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uitoolbar/"/>
    <updated>2014-01-03T12:31:14+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uitoolbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UIToolBar的基本属性及方法
2、iOS5.0新增
3、iOS6.0新增
4、iOS7.0新增
5、UIToolbar协议
</code></pre>

<p><strong>1、UIToolBar的基本属性及方法</strong></p>

<p>// UIToolBar的样式 （默认为blue）</p>

<pre><code>UIBarStyle barStyle;
</code></pre>

<p>// 设置tooBar的选项</p>

<pre><code>NSArray   *items;
</code></pre>

<p>// 设置上面的一层view是否半透明</p>

<pre><code>BOOL translucent;
</code></pre>

<p>//</p>

<pre><code>- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 背景颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>2、iOS5.0新增</p>

<p>// 背景图片设置</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>//</p>

<pre><code>- (UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>3、iOS6.0新增</p>

<p>// 设置ToolBar上边沿的阴影</p>

<pre><code>- (void)setShadowImage:(UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom;
- (UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom;
</code></pre>

<p>4、iOS7.0新增</p>

<p>// 设置背景颜色</p>

<pre><code>UIColor *barTintColor;
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UIToolbarDelegate&gt; delegate;
</code></pre>

<p><strong>5、UIToolbar协议</strong></p>

<p>目前还没有协议</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITabBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uitabbar/"/>
    <updated>2014-01-03T12:31:06+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uitabbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UITabBar作为一个标签栏控制，它本身继承于UIView,也就是说UITabBar本身是一个视图控件。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UITabBar基本属性及方法
2、iOS5.0新增
3、iOS6.0新增
4、iOS7.0新增
5、UITabBarDelegate协议（可选）
</code></pre>

<p><strong>1、UITabBar基本属性及方法</strong></p>

<p>// 设置UITabBar的代理</p>

<pre><code>id&lt;UITabBarDelegate&gt; delegate;
</code></pre>

<p>//  设置UITabBar的选项值</p>

<pre><code>NSArray  *items;
</code></pre>

<p>//  设置UITabBar选中的item</p>

<pre><code>UITabBarItem *selectedItem; 
</code></pre>

<p>// 是否动画添加item（冒似没有效果）</p>

<pre><code>- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 定制化items</p>

<pre><code>- (void)beginCustomizingItems:(NSArray *)items;
</code></pre>

<p>// 结束定制化动画</p>

<pre><code>- (BOOL)endCustomizingAnimated:(BOOL)animated;
</code></pre>

<p>// 是否定制化</p>

<pre><code>- (BOOL)isCustomizing;
</code></pre>

<p><strong>2、iOS5.0新增</strong></p>

<p>// 改变UITabBar的着色(直接通过back背景颜色)</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 选中时背景颜色</p>

<pre><code>UIColor *selectedImageTintColor;
</code></pre>

<p>// 背景图片</p>

<pre><code>UIImage *backgroundImage;
</code></pre>

<p>// 选中的item的背景图片</p>

<pre><code>UIImage *selectionIndicatorImage; 
</code></pre>

<p><strong>3、iOS6.0新增</strong></p>

<pre><code>UIImage *shadowImage;
</code></pre>

<p><strong>4、iOS7.0新增 </strong></p>

<pre><code>UIColor *barTintColor;

UITabBarItemPositioning itemPositioning;

CGFloat itemWidth;


CGFloat itemSpacing;

UIBarStyle barStyle;

BOOL translucent;
</code></pre>

<p><strong>5、UITabBarDelegate协议（可选）</strong></p>

<pre><code>- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item;

- (void)tabBar:(UITabBar *)tabBar willBeginCustomizingItems:(NSArray *)items; 

- (void)tabBar:(UITabBar *)tabBar didBeginCustomizingItems:(NSArray *)items;
- (void)tabBar:(UITabBar *)tabBar willEndCustomizingItems:(NSArray *)items changed:(BOOL)changed;

- (void)tabBar:(UITabBar *)tabBar didEndCustomizingItems:(NSArray *)items changed:(BOOL)changed;  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIImageView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uiimageview/"/>
    <updated>2014-01-03T12:30:58+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uiimageview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、基本属性
2、动画图片相关
3、iOS7新增
</code></pre>

<!--more-->


<p><strong>1、基本属性</strong></p>

<p>// 初始化UIImageView展示的图片资源</p>

<pre><code>- (id)initWithImage:(UIImage *)image;
</code></pre>

<p>// 初始化UIImageView默认和选中时展示的图片资源</p>

<pre><code>- (id)initWithImage:(UIImage *)image highlightedImage:(UIImage *)highlightedImage;
</code></pre>

<p>// UIImageView的图片资源</p>

<pre><code>UIImage *image;
</code></pre>

<p>// UIImageView选中之后的图片资源</p>

<pre><code>UIImage *highlightedImage;
</code></pre>

<p>// 是否允许用户交互 （默认为NO）</p>

<pre><code>BOOL userInteractionEnabled;
</code></pre>

<p>// 是否选中 （默认为NO）</p>

<pre><code>BOOL highlighted;
</code></pre>

<p><strong>2、动画图片相关</strong></p>

<p>// UIImageView 动画播放的图片组资源（必须是UIImage,如果设置了单一的image，那么这个为nil）</p>

<pre><code>NSArray *animationImages;
</code></pre>

<p>// 选中时UIImageView 动画播放的图片组资源（同上）</p>

<pre><code>NSArray *highlightedAnimationImages;
</code></pre>

<p>// 图片播放的时间间隔</p>

<pre><code>NSTimeInterval animationDuration;
</code></pre>

<p>// 图片重复播放次数（默认为0，为表示一直重复播放）</p>

<pre><code>NSInteger      animationRepeatCount;
</code></pre>

<p>// 播放图片</p>

<pre><code>- (void)startAnimating;
</code></pre>

<p>// 停止播放</p>

<pre><code>- (void)stopAnimating;
</code></pre>

<p>// 是否正在播放</p>

<pre><code>- (BOOL)isAnimating;
</code></pre>

<p><strong>3、iOS7新增</strong></p>

<pre><code>UIColor *tintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIActivityIndicatorView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uiactivityindicatorview/"/>
    <updated>2014-01-03T12:30:48+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uiactivityindicatorview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、UIActivityIndicatorView基本属性及方法
2、iOS5.0新增
</code></pre>

<!--more-->


<p><strong>1、UIActivityIndicatorView基本属性及方法</strong></p>

<p>// 初始化样式</p>

<pre><code>- (id)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style;
</code></pre>

<p>// 设置样式（默认为UIActivityIndicatorViewStyleWhite）</p>

<pre><code>UIActivityIndicatorViewStyle activityIndicatorViewStyle;
</code></pre>

<p>// 停止时是否隐藏</p>

<pre><code>BOOL hidesWhenStopped;
</code></pre>

<p>// 开始播放动画</p>

<pre><code>- (void)startAnimating;
</code></pre>

<p>// 停止播放动画</p>

<pre><code>- (void)stopAnimating;
</code></pre>

<p>// 是否正在播放动画</p>

<pre><code>- (BOOL)isAnimating;
</code></pre>

<p><strong>2、iOS5.0新增</strong></p>

<p>// 设置圈圈的颜色</p>

<pre><code>UIColor *color;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIProgressView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/02/uiprogressview/"/>
    <updated>2014-01-02T12:28:03+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/02/uiprogressview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增内容
</code></pre>

<!--more-->


<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化progressView的样式</p>

<pre><code>- (id)initWithProgressViewStyle:(UIProgressViewStyle)style; 
</code></pre>

<p>// progressView的样式（默认为UIProgressViewStyleDefault）</p>

<pre><code>UIProgressViewStyle progressViewStyle;
</code></pre>

<p>// 进度（范围为0-1）</p>

<pre><code>float progress; 
</code></pre>

<p><strong>2、iOS5新增内容</strong></p>

<p>// 进度填充部分的颜色(譬如进度到40%,那么40%部分的颜色就是这个属性)</p>

<pre><code>UIColor* progressTintColor;
</code></pre>

<p>// 未填充部分的颜色</p>

<pre><code>UIColor* trackTintColor ;
</code></pre>

<p>// 进度填充部分的图片，如progressTintColor</p>

<pre><code>UIImage* progressImage;
</code></pre>

<p>// 未填充部分的图片，如trackTintColor</p>

<pre><code>UIImage* trackImage;
</code></pre>

<p>// 设置progress的进度</p>

<pre><code>- (void)setProgress:(float)progress animated:(BOOL)animated;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UILabel详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/02/uilabel/"/>
    <updated>2014-01-02T09:57:41+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/02/uilabel</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2014/01/06/uilabel.png" alt="image" /></p>

<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、属性
2、方法
</code></pre>

<p><strong>1、属性</strong></p>

<p>// UILabel显示内容</p>

<pre><code>NSString           *text;
</code></pre>

<p>// 文字字体(默认为系统字体，大小17)</p>

<pre><code>UIFont             *font;
</code></pre>

<p>// 字体颜色</p>

<pre><code>UIColor            *textColor;
</code></pre>

<p>// 阴影颜色（默认没有阴影）</p>

<pre><code>UIColor            *shadowColor;
</code></pre>

<p>// 阴影大小（默认为（0，-1））</p>

<pre><code>CGSize             shadowOffset; 
</code></pre>

<p>// 文字对齐模式（默认是居左）</p>

<pre><code>NSTextAlignment    textAlignment;
</code></pre>

<p>//  设置单词折行方式（默认NSLineBreakByTruncatingTail）</p>

<pre><code> NSLineBreakMode    lineBreakMode; 
</code></pre>

<p>// 文字显示属性(iOS6.0)</p>

<pre><code>NSAttributedString *attributedText;
</code></pre>

<p>// 文字高亮时的颜色</p>

<pre><code>UIColor *highlightedTextColor; 
</code></pre>

<p>// 是否支持高亮（默认为NO）</p>

<pre><code>BOOL     highlighted;          // default is NO
</code></pre>

<p>// 是否允许接收触摸事件(默认为NO)</p>

<pre><code>BOOL userInteractionEnabled;  // default is NO
</code></pre>

<p>// 文本是否可变(默认YES)</p>

<pre><code>BOOL enabled;                 // default is YES. changes how the label is drawn
</code></pre>

<p>// 设置label可以显示多少行(0表示多行，默认为1)</p>

<pre><code>NSInteger numberOfLines;
</code></pre>

<p>// 文本文字是否自适应大小(默认为NO)</p>

<pre><code>BOOL adjustsFontSizeToFitWidth;         // default is NO
</code></pre>

<p>//</p>

<pre><code>BOOL adjustsLetterSpacingToFitWidth NS_DEPRECATED_IOS(6_0,7_0); // deprecated - hand tune by using NSKernAttributeName to affect tracking
</code></pre>

<p>// 最小字体，行数为1时有效（默认为0.0 iOS2.0 &ndash; iOS6.0）</p>

<pre><code>CGFloat minimumFontSize;
</code></pre>

<p>// 控制文本的基线位置，只有文本行数为1是有效（默认为UIBaselineAdjustmentAlignBaselines）</p>

<pre><code>UIBaselineAdjustment baselineAdjustment;
//有三种方式
typedef enum {
    UIBaselineAdjustmentAlignBaselines = 0, 默认值文本最上端于label中线对齐
    UIBaselineAdjustmentAlignCenters,//文本中线于label中线对齐
    UIBaselineAdjustmentNone,//文本最低端与label中线对齐
} UIBaselineAdjustment;
</code></pre>

<p>// 设置最小字体,与minimumFontSize相同（iOS6.0）</p>

<pre><code>CGFloat minimumScaleFactor; 
</code></pre>

<p>// 优先选择标签布局的最大宽度(iOS 6.0)</p>

<pre><code>CGFloat preferredMaxLayoutWidth;    
</code></pre>

<p><strong>2、方法</strong></p>

<p>// 不可直接调用,需要子类重载,第二参数为0时没有行数限制</p>

<pre><code>- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines;
</code></pre>

<p>// 不可直接调用,需要子类重载</p>

<pre><code>- (void)drawTextInRect:(CGRect)rect;
</code></pre>
]]></content>
  </entry>
  
</feed>
