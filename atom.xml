<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel's Den]]></title>
  <link href="http://www.beyondabel.com/atom.xml" rel="self"/>
  <link href="http://www.beyondabel.com/"/>
  <updated>2016-05-05T19:36:27+08:00</updated>
  <id>http://www.beyondabel.com/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《管理工作的本质》读后感]]></title>
    <link href="http://www.beyondabel.com/blog/2016/04/25/thenatureofmanagerialwork/"/>
    <updated>2016-04-25T13:56:34+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/04/25/thenatureofmanagerialwork</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/04/manager.jpg" alt="image" /></p>

<p>最近看完了明茨伯格的《管理工作的本质》，这是一本管理研究类型书的，看起来非常烧脑子。看完之后感觉还是非常不错，这是一本能建立管理理论体系的一本书，有兴趣的朋友们可以去看看。</p>

<!--more-->


<p>在这本书的第一章对管理工作进行了概述，陈述了管理的本质和目的：管理者负责规划、组织、激励、指挥和控制，管理者让其他人的工作有了前瞻性、秩序性和目标性，让工作得以整合，并取得成效。通常从乍一眼的理解来看，这些内容都是管理工作的部分内容，但从实际执行的角度去理解会发现将这些单个点作为管理工作的内容和重心来执行的话会发生非常难以定义的情况，从对于一门学科且需要量化结果的角度来说，如此职能的划分由于是交叉且不完备的，证明的这种划分的不合理性；同时由于不具备可执行性和可量化的特点，更加证明将这些直接作为管理工作的内容分类十分不合理。因此，这本书从另外一个视角帮助我们理解管理工作，而把传统理解管理工作的内容定义为管理的目标来协助进一步更准确更可量化的理解管理。在第二章中作者把研究管理工作的八个学派做了列举：1、古典学派：以法约尔提出的5种基本管理职能为开创，后形成了一套固定的模式，即 POSDCORB，分别是计划，组织，人员配置，指导，协调，报告，预算。2、伟人学派：着重描写危机时刻。以趣闻轶事为主，缺乏普遍性。3、企业家学派：关注企业创始人。4、决策理论学派：关注管理决策行为。5、领导有效性学派：更关注工作中的人，而不是管理工作。6、领导权力学派：关心的是权力和影响力，关心的是领导者所掌握的特权。代表性有五种权力论：奖赏权力、强制权力、参照权力、法定权力、专家权力。7、领导行为学派：通过研究在职者的行为来分析管理工作的实际内容。8、工作活动学派：研究管理者的活动。在这一部分中比较有趣且有启发的有以下几点：首先，在古典学派中在此呼应第一章节，提到了常规认为的管理工作的核心职能，但在此基础上进行了扩展，其中最有趣的是报告，这里需要理解的是报告不单纯是中级领导向再上级汇报的过程，也有向下属进行信息同步的含义。第三章节主要说明了管理工作的重要特征。首先，关于工作量大这个特征，从表面上来看只是一个工作负载和压力相关的特征，但结合实际工作，会发现其实这个看起来很简单直白的事实特征内含很多可细化的因素需要不断去反思、进行自我激励，比如如何自我驱动、自我管理、如何制定目标并对目标不断持续的关注、如何量化结果、如何定义工作的完成程度和效果、如何从中获得成就感。而作为管理者本身，原意承担更高要求的工作的原因是源自其对于公司的责任感。第二，关于工作性质本身短暂、多样、零碎的特点，这个命题给我带来的是需要思考并期待看到解决方案的一个问题：管理者该如何在无法深入业务细节的情况下，如何保持信息的不断更新。以目前我对管理工作的理解以及日常对管理工作的观察，浅显的初步认识是两点：一是管理者需要有很强的全局观和整体逻辑思维方式，从整体框架性的角度获取更广阔的信息，从而减少对细节信息的依赖度；第二，是上文提到过的对目标的持续关注，以协助自身去辨别细节信息的重要性，有的放矢的进行了解和掌控。同时再辅助对人的深刻理解和善用以实现通过别人来掌控业务细节。而这一重点将作为一个重要问题来辅助我日后对全本的阅读。最后比较有感触的一点是对于口头沟通的重视程度，这一点实际对日常工作有最直接的指导价值，虽然是看起来很简单的一件事情，但由于发邮件的正式便捷可追溯，以及由于日常对科技力量的依赖，已经日渐忽视面对面交谈的重要性。这不仅仅是管理工作中一个很好的辅助工具，也是作为执行者对工作方法的重要性的再一次强调。另一方面，通过书中的数字说明，再次证明了口头沟通对信息传递的准确性带来的显著改善。在第五章中，明茨伯格在前面研究的六大特征和10个基本角色的基础上，重点研究管理者工作的过程中所涉及到的变量。管理者工作的多样性来自于4组相互影响的变量：一是组织、行业以及其他因素所在环境；二是工作本身所在组织中的层级和其所掌管的职能；三是工作中特定的管理者本人的个性和风格等；四是工作中的具体情景与特定情况。在这四种变量之下，明茨伯格进一步归纳出了8种管理工作类型（也即8种类型的管理者）以及他们分别对应的关键角色，即：联系人（联络官、名义领袖）、政治管理者（发言人、谈判者）、创业者（创业者、谈判者）、内部人士（资源调配者）、实时管理者（故障排除者）、团队管理者（领导者）、专家管理者（监控者、发言人）、新管理者（联络官、监控者）。这部分其实与管理者的10大基本角色有很大的重合。 在第六章中，明茨伯格指出，管理是一门艺术，而非建立在科学基础之上的职业。管理者必须利用经验、直觉，加上不断优化的流程与工具，去形成自己的管理风格。主要改进及不断迭代优化的几个方向是： “寻找机遇和问题”、“拟议项目的成本和收益评估”、“模型构建”、“突发事件预案”、“分析&#8217;即时事件&#8217;”、“监控改进计划”和“发展适应性计划”等7个。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS移动开发周报-第6期]]></title>
    <link href="http://www.beyondabel.com/blog/2016/04/22/weekly06/"/>
    <updated>2016-04-22T12:50:11+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/04/22/weekly06</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/04/weekly06.png" alt="image" /></p>

<!--more-->


<h2>业界新闻</h2>

<ol>
<li><p><a href="http://toutiao.com/a6275841927522861314/?tt_from=weixin&amp;utm_campaign=client_share&amp;app=news_article&amp;utm_source=weixin&amp;iid=3824799348&amp;utm_medium=toutiao_ios&amp;wxshare_count=1">阿里宣布开源Weex 用Web方式开发Native性能体验应用</a> : 阿里巴巴今天在Qcon大会上宣布跨平台移动开发工具Weex开放内测邀请。Weex能够完美兼顾性能与动态性，让移动开发者通过简捷的前端语法写出Native级别的性能体验，并支持iOS、安卓、YunOS及Web等多端部署。
对于移动开发者来说，Weex主要解决了频繁发版和多端研发两大痛点，同时解决了前端语言性能差和显示效果受限的问题。开发者可通过<a href="http://alibaba.github.io/weex/">Weex官网</a>申请内测。</p></li>
<li><p><a href="http://daringfireball.net/linked/2016/04/14/bloomberg-app-store-search">Apple 可能正在策划推出 App Store 付费排名</a>：国外有消息指出，Apple 可能在考虑将竞价排名或者付费关键词搜索加入到 App Store 的搜索体系中。根据现有消息，App Store 的付费排名可能采取和 Google 搜索的关键字购买类似，开发商对某个关键字进行购买，并让自己的 app 出现在搜索前列。如果消息属实，那么这对整个 App Store 生态将产生相当大的影响。</p></li>
<li><a href="http://www.jiemian.com/article/621007.html">苹果关闭中国区iTunes Movies和iBooks Store服务</a>: 目前在国内登陆上述两个内容商店均显示不可用。对于关闭的原因，苹果公司相关人士拒绝透露更多信息。</li>
</ol>


<h2>教程</h2>

<ol>
<li><p><a href="http://go.macrumors.com/?id=73726X1523000&amp;site=macrumors.com&amp;xs=1&amp;isjs=1&amp;url=https%3A%2F%2Fitunes.apple.com%2Fus%2Fcourse%2Fdeveloping-ios-9-apps-swift%2Fid1104579961&amp;xguid=074ac52994ec90a466b54092a91fa805&amp;xuuid=28851a1abff392d7a27a283d1a053ef0&amp;xsessid=d720f8c99835144c8cec6fc4c10cae45&amp;xcreo=0&amp;xed=0&amp;sref=http%3A%2F%2Fwww.macrumors.com%2F2016%2F04%2F20%2Fstanford-developing-ios-9-apps-course%2F&amp;xtz=-480&amp;abp=1">斯坦福大学更新iOS 9编程开发新课程</a>：想必很多从事或正在学习iOS应用编程开发的用户都是通过斯坦福大学教授Paul Hegarty的教学课程中起步，而且在过去几年间，斯坦福大学在iTunes U上向那些想要为iOS设备创建应用的用户提供了免费的开发课程。近日，面向iOS 9和Swift的2016年课程正式上线，在课程需求中要求掌握C语言和面向对象编程经验，并超过Programming Abstractions级别且完成Programming Paradigms课程。</p></li>
<li><p><a href="http://www.jianshu.com/p/3fb19ce35e4b">老生常谈：深入浅出RAC</a> : RAC是ReactiveCocoa的简称，ReactiveCocoa是响应式编程(FRP)在iOS中的一个实现框架，它在Github上是开源的；ReactiveCocoa为事件定义了一个标准接口，从而可以使用一些基本工具来更容易的连接、过滤和组合。</p></li>
</ol>


<h2>开源代码</h2>

<ol>
<li><a href="https://github.com/hypoyao/GYHttpMock">FBMemoryProfiler</a> : FBMemoryProfiler是Facebook开源的一款用于分析iOS内存使用和检测循环引用的工具库。</li>
<li><a href="https://github.com/beyondabel/BANetworking">BANetworking</a>: BANetworking是一个类似于AFNetworkring的网络构架，它把一些基本的请求业务逻辑已经封装好了，使用非常简单。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS移动开发周报-第5期]]></title>
    <link href="http://www.beyondabel.com/blog/2016/04/12/weekly05/"/>
    <updated>2016-04-12T22:19:53+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/04/12/weekly05</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/04/weekly05.png" alt="image" /></p>

<!--more-->


<h2>业界新闻</h2>

<ol>
<li><p><a href="http://thenextweb.com/dd/2016/04/07/google-facebook-uber-swift/?%2BSandbox">Google Android或采纳苹果的Swift编程语言：避开Java这个坑？</a> : 据TNW报道，苹果正考虑将苹果公司开源的Swift作为Android的“一类”编程语言。有消息称，在苹果宣布将Swift开源的前后（去年12月），Google、Facebook和Uber的高管曾进行了会面讨论：“Google的Android操作系统，当前仍将Java作为它的首选语言，但消息人士称，Swift并不是要取代Java，至少从目前来说不是”。</p></li>
<li><p><a href="http://3g.163.com/ntes/special/0034073A/wechat_article.html?docid=BKEGUNKU0011179O&amp;spst=0&amp;spss=newsapp&amp;spsf=wx&amp;spsw=1">iOS 10将于6月到来：新增表情</a>：根据最新的消息显示，iOS10或于今年在WWDC大会上发布预览版，虽然目前苹果还没有公布具体的举行实现，但是根据每年的惯例，今年的会议也将于6月13日至6月17日举行，地点位于旧金山MosconeWest。</p></li>
</ol>


<h2>教程</h2>

<ol>
<li><a href="http://drops.wooyun.org/papers/14170">iOS冰与火之歌 – 利用XPC过App沙盒</a>：XPC 是 OS X 上进程间通讯的常用手段，而在 iOS 中虽然第三方开发者不允许直接使用 XPC，但是这项技术还是存在于 iOS 系统之中的，这篇文章简单介绍了在 iOS 上利用 XPC 与系统进程通讯并突破沙盒的技术要点。</li>
<li><a href="http://ios.jobbole.com/84513/">iOS 不要用宏来定义你的常量</a>：前不久有人在询问我关于define和const的用法以及一些区别，本来想写一篇关于它们的文章，看到这篇文章之后，我想这个已能解决你们的疑点了。</li>
</ol>


<h2>开源代码</h2>

<ol>
<li><a href="https://github.com/hypoyao/GYHttpMock">GYHttpMock：iOS HTTP请求模拟工具</a> : iOS App开发过程中，前台开发过程通常都是并行进行的，因此难免会出现一些客户端需要等待后台开发联调的情景，等待的过程往往痛若而无奈（后台被催得痛苦，前端无奈等待）。通常解决办法是，客户端在某处 hardcode 网络返回数据，当然，一不小心，这种测试代码被提交到了线上也是常有的事情。还有更“高级”一点，通过设置代理，用抓包工具修改网络数据，但这种效率低得令人抓狂。</li>
<li><a href="https://github.com/EddyBorja/EBPhotoPages">EBPhotoPages</a> : 用于显示一个滚动型照片页和元数据的图片库。用户可以放大、缩小图片，以及创建，编辑或删除注释和标记，共享或删除照片，并报告不当的照片。所有照片和内容异步加载。相片的用户权限通过委托协议控制。该库是使用状态模式来控制画廊的行为，让其他开发人员可以轻松地修改或增加新的状态，而不必了解太多的原代码设计。。</li>
<li><a href="https://github.com/tdginternet/TGCameraViewController">TGCameraViewController</a> : 一款可定制的AVFoundation相机,界面美观、实用性强且容易集成。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用ttf字体库给App瘦身]]></title>
    <link href="http://www.beyondabel.com/blog/2016/04/05/ttf/"/>
    <updated>2016-04-05T14:42:10+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/04/05/ttf</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/04/iconfont.png" alt="image" /></p>

<!--more-->


<h3>前言</h3>

<p>自从4.7、5.5屏幕的iPhone出来之后，我们在做iPhone适配上就开始头痛了，他开始有@2x、@3x图了，这无疑增加了App的安装包的体积了，那么有没有好的方法去解决这个问题呢？在这我介绍一种使用TTF字体库替换使用图片方式。利用现在的时间整理一份TTF使用文档，希望能帮助到大家。</p>

<h3>为什么选择ttf字体库</h3>

<p>首先我问一下大家，如果看到以下的设计，大家会怎么做呢？</p>

<p><img src="http://www.beyondabel.com/images/2016/04/iconfont_sample02.png" alt="image" /></p>

<p>图1</p>

<p>如上图所示的红色区域，一般情况下，我们会使用一个imageView后面加一个label,再接着imageView，最后时间又是一个label，这样使用不仅创建的控件多，而且还要设置它们的相对位置，非常繁琐。但是我们可以使用字体库简单解决，示例代码如下：</p>

<pre><code>UILabel *addressLabel = [[UILabel alloc] initWithFrame:(CGRect){80, 33, 40, 21}];
addressLabel.textColor = kColorWithRGB(0x666666);
addressLabel.text = @"\ue601 北京   \ue600 4月23日 12:00";
addressLabel.font = [UIFont fontWithName:@"iconfont" size:14];
[self.contentView addSubview:addressLabel];
</code></pre>

<p>所以使用字体库图标可以带来如下的好处：</p>

<ol>
<li>减少资源所占内存。如果你使用TTF字体库的图标就是一个个文字，而使用图片就需要单倍图、@2x、@3x三张图片。</li>
<li>使用方便。ttf字体库的使用规则就像我们使用的文字一样（具体如何使用将在下面介绍到），我们还可以根据字体的颜色自由设置图标颜色，而不需要重新要UI切图。</li>
<li>UI切图也方便，不需要切多套图。</li>
</ol>


<p>注：ttf适合范围只是单色的图标，如果是多色彩图片还是需要选择图片。</p>

<h3>如何使用ttf字体库</h3>

<h5>1. 创建ttf字体库</h5>

<p>在这里我向大家介绍一个生成一个字体库平台—— <a href="http://iconfont.cn/">阿里巴巴矢量图标库</a>，在这里有许多现成的图标库，你可以选择你需要的图标然后生成一个ttf库，具体可参考 <a href="http://iconfont.cn/help/platform.html">ICONFONT平台功能介绍</a>。</p>

<h4>2. 查看ttf字体库名称</h4>

<p>双击<code>iconfont.tff</code>文件，能看到弹出了以下的一个字体弹框。用红色框住的就是字体库名称。</p>

<p><img src="http://www.beyondabel.com/images/2016/04/iconfont03.png" height="223" width="400" alt="image" /></p>

<h4>3. 使用ttf字体库</h4>

<ol>
<li><p>将xx.ttf字体库加入工程里面</p>

<p> <img src="http://www.beyondabel.com/images/2016/04/iconfont02.png" height="216" width="200" alt="image" /></p></li>
<li><p>在工程的xx-Info.plist文件中新添加一行Fonts provided by application，加上字体库的名称。</p>

<p> <img src="http://www.beyondabel.com/images/2016/04/iconfont01.png" height="200" width="634" alt="image" /></p></li>
<li>引用字体库的名称，设置字体：</li>
</ol>


<p>A、 Label使用ttf</p>

<pre><code>UILabel * iconFontLabel = [[UILabel alloc] initWithFrame:(CGRect){100, 60, 200, 40}];
iconFontLabel.font = [UIFont fontWithName:@"fanghuwang" size:20];
iconFontLabel.text = @"\ue62a 这是一个iconfont";
iconFontLabel.textColor = [UIColor redColor]; // 设置字体的颜色
[self.view addSubview:iconFontLabel];
</code></pre>

<p>B、Button 使用ttf</p>

<pre><code>UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];
button.titleLabel.font = [UIFont fontWithName:@"fanghuwang" size:20];
button.frame = (CGRect){100, 120, 160, 40};
[button setTitleColor:[UIColor blueColor] forState:UIControlStateNormal];
[button setTitle:@"\ue61d iconfont Button" forState:UIControlStateNormal];
[self.view addSubview:button];
</code></pre>

<p>注： 如果不知道字体安装是否成功，可以遍历字体进行查询：</p>

<pre><code> NSLog(@"familyNames:'%@'",[UIFont familyNames]);
</code></pre>

<h4>4. 使用ttf字体库创建图片</h4>

<pre><code>// 使用iconfont创建图片
+ (UIImage *)imageFromText:(NSString *)text fontSize:(CGFloat)fontSize color:(UIColor *)color {
    UIFont *font = [UIFont fontWithName:@"fanghuwang" size:fontSize];
    CGSize size  = [text sizeWithAttributes:@{NSFontAttributeName : font}];//[text sizeWithFont:font];
    UIGraphicsBeginImageContextWithOptions(size, NO, 0);
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    CGContextSetFillColorWithColor(ctx, color.CGColor);
    CGContextSetShouldSmoothFonts(ctx, YES);

    CGContextSetShouldAntialias(ctx, YES);
    CGContextSetLineWidth(ctx, 10);
    [text drawAtPoint:CGPointMake(0.0, 0.0) withAttributes:@{NSFontAttributeName : font, NSForegroundColorAttributeName : color}];
    UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    return image;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS移动开发周报-第4期]]></title>
    <link href="http://www.beyondabel.com/blog/2016/03/27/weekly04/"/>
    <updated>2016-03-27T13:40:37+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/03/27/weekly04</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/03/weekly04.png" alt="image" /></p>

<!--more-->


<h2>业界新闻</h2>

<ol>
<li><a href="http://www.infoq.com/cn/news/2016/03/ios-security-fix">苹果在iOS9.3中修复了安全漏洞</a> : 3月21日在加利福尼亚苹果总部的Let us loop you in活动中，苹果发布了他们移动端设备的更新版本，叫做iPhone SE。它回归了之前iPhone版本的4英寸设计但是拥有一个与iPhone 6相似的处理器，包括了Touch ID、NFC（为了使用Apple Pay）和Live Photos，其中Live Photos是一个记录拍照片前和拍照片后的一小段视频的功能，以实现真实的Harry Potter体验。伴随新发布的iPhone SE一起而来的是iPad Pro的一个较小版本，它使用了和iPad Pro一样的处理器和技术，但是和现有的iPad大小一致。</li>
<li><a href="http://news.zol.com.cn/563/5631114.html">苹果推Watch OS 2.2更新</a>：苹果再3月22日凌晨1点发布了新的Apple Watch表带，颜色搭配相当之诡异。不过，庆幸的是，苹果同样推送了Watch OS 2.2的更新。</li>
<li><p><a href="https://developer.apple.com/news/?id=03092016a">App Analytics 分析周报上线</a>：对于 app 下载和评论的管理一直是 iTunes Connect 的弱项，不过最近一两年来 Apple 一直这方面进行了改进，包括在 iTunes Connect 中添加分析模块，更好的 Crash 报告等。最近，Apple 为开发者提供了周报邮件，以帮助开发者追踪 app 的下载和评分状况。有需要的开发者可以在 iTunes Connect 中进行订阅。</p></li>
<li><p><a href="http://3g.163.com/ntes/special/0034073A/wechat_article.html?docid=BIBTQR67001168BQ&amp;spst=0&amp;spss=newsapp&amp;spsf=wx&amp;spsw=1">一弃用iOS应用数据库泄露</a>：Chris Vickery表示，与这款应用相关（MongoDB）数据库依然维持在线，尽管Kinoptic已经下架。Vickery称该数据库已经在网络上曝光，已经通过默认MongoDB配置来允许任何人不加认证的访问这些内容。</p></li>
</ol>


<h2>教程</h2>

<ol>
<li><a href="http://drops.wooyun.org/papers/13824">iOS冰与火之歌番外篇 &ndash; App Hook答疑以及iOS 9砸壳</a>：关于 iOS 安全系列的最新文章。上架 App Store 的 app 会被进行加壳处理，我们想要对这些 app 进行 hook 或者探索，第一步就是要进行去壳。本文主要介绍了 iOS 上砸壳 (Dumpdecrypted)，签名及重新安装的一些技巧。</li>
<li><p><a href="https://bestswifter.com/uiviewlifetime/">UIView的生命周期总结</a>：这篇主要参考官方和文档和StackOVerFlow有关问题文章整理了View在UIViewController的生命周期的创建方法，以及IB和代码加载视图的区别，对UIView的讲解还是比较详细。</p></li>
<li><p><a href="http://limboy.me/ios/2016/03/10/mgj-components.html">蘑菇街 App 的组件化之路</a>：随着项目规模变大，将业务进行组件化拆分是一个很容易做出的选择。本文介绍了在一个实际项目中，将业务拆分成分离的相互之间不直接引用的组件的一些方法和实践。</p></li>
</ol>


<h2>开源代码</h2>

<ol>
<li><a href="https://github.com/ibireme/YYModel">YYModel</a> : 与Mantle一样，都是JSON转Model库，相比Mantle,YYModel源码小而精炼，接口也简单。</li>
<li><a href="https://github.com/windshg/VPImageCropper">VPImageCropper</a> : 可以让你轻松实现微信选取图片并裁剪成头像的控件。</li>
<li><a href="https://github.com/JaviSoto/JSBadgeView">JSBadgeView</a> : 添加带动画效果的未读消息数提醒</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何编写高质量iOS代码]]></title>
    <link href="http://www.beyondabel.com/blog/2016/03/23/efficient/"/>
    <updated>2016-03-23T00:33:32+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/03/23/efficient</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/03/effective-objective-oc.png" alt="image" /></p>

<p>一直以来，身边总会有这样的声音——“如何提高自己的代码质量”，我想这个话题可能大家会比较感兴趣，所以在这里分享一下我在iOS开发中对如何提高代码质量的一些心得体会，其他的语言可以以此做一个参照。</p>

<!--more-->


<h3>1. 基础知识及技巧</h3>

<p>想写出高质量代码，并不是一蹴而就的，它需要有一定的基础以及大量的代码知识积累，这里我重点强调与代码质量密切相关的几点：</p>

<p>首先得掌握好开发语言，iOS开发有二种语言——Objective-C和Swift，不管你选择哪种都可以，不过现在Objective-C还是主流，但我相信未来肯定是Swift的天下，关于Objective-C可以看看<a href="http://item.jd.com/11402853.html">《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》</a>，这本书讲解了非常多使用Objective-C的技巧。</p>

<p>其次你就需要去了解iOS开发平台特性以及工作原理，了解清楚这些之后，充分利用他的一些特性写出更加地道的代码。</p>

<h3>2. 数据结构和算法</h3>

<p>计算机科学本来就是由数学发展而来的，数据结构与算法的重要性不言而喻，当然，不是说你不学习算法就不能做开发了，而是说学好数据结构和算法，当你遇到问题时，你可以以更加优雅高效地解决问题。</p>

<h3>3. 设计模式</h3>

<p>设计模式是一个老生常谈的话题，市面上充斥着各种的设计模式，我们无需对所有的设计模式都需要了解，只需要了解一些常用的设计原则即可，这里给你推荐一本书——<a href="http://item.jd.com/10871643.html">《Objective-C编程之道：iOS设计模式解析》</a>，学完之后应该能解决你的绝大部分问题了。</p>

<h3>4. 代码标准</h3>

<p>一个团队中人来自不同的地方是非常正常的，每个团队中代码风格有时往往又会不一样，这个时候代码标准在团队合作中尤为重要，谁也不希望一个项目中代码风格各异，相互之间都不愿看别人的代码。标准怎么定是一个老生常谈的话题，我个人职业生涯中经历过很多次的代码标准讨论会议，大家有时会坚持自己的习惯不肯退让。代码规范问题我推荐raywenderlich.com团队的<a href="https://github.com/raywenderlich/objective-c-style-guide">objective-c-style-guide</a> （<a href="https://github.com/samlaudev/Objective-C-Coding-Style">中文翻译</a>），</p>

<h3>5. 拆解功能，再写代码</h3>

<p>拿到需求除非你很清楚你要怎么做，否则绝对不能直接下手写代码，而是我们需要先思考如何对功能进行拆解以及如何去解决问题，思考目前的方案是否有效？有没有更优的方案？如果你把问题拆解好了，实现其实是非常简单的事。</p>

<h3>6. 代码审查</h3>

<p>在项目起始阶段进行代码审查会帮助我们更好地使用已经建立起来的代码体系，因为如果我们没有使用过某些现有代码，那么可以从当前的开发者中获得反馈信息。在项目进行过程中，我们会时不时地向团队增加新的开发人员，代码审查可以极大地降低这些新加入人员的熟悉时间。特别地，我们可以让新加入的开发人员很有信心地开发新特性，因为我们可以在合并前审查代码并且对于他们所编写的任何代码提供有价值的反馈信息。</p>

<p>对于分布式团队来说，代码审查更加具有实际意义。团队协同在构建协作环境上会带来很大的帮助作用，我们可以即时提出想法，然后讨论，再进行开发。虽然由于不在同一地点我们会失去一些东西，不过我们却可以在代码审查过程中通过深入的讨论来获得好处。</p>

<h3>7. 单元测试</h3>

<p>自从Xcode 5以来，Xcode就会默认带上XCTest单元测试库，但单元测试一直没有引起大家的注意，大家可能考虑到写单元测试太破费时间了，但单元测试的一个非常显著的优点是，当你需要修改大量代码时，尽管放心修改，只需要保证单元测试用例通过即可，无需瞻前顾后。</p>

<h3>8. 充分自测</h3>

<p>自测对于程序员来说是一个头痛的问题，有些程序员总想着让测试帮找问题，连自己的运行结果都不看就把App丢给测试，这是非常不负责任的。作为一个程序员在写完代码后至少需要跑完一遍全部流程以及一些简单的异常情况再交给测试，不然，随便用几下就Crash的东西，会给测试人员这人不靠谱以及技术真low的印象，再说，你准备在别人面前展示自己研究的工作成果时，突然之间Crash掉了，你真的好意思吗？充分自测也是基本的职业素养体现~所以充分自测非常重要！充分自测非常重要！充分自测非常重要！重要的事说三遍~</p>

<h3>9. 善用开源</h3>

<p>在我刚学iOS开发时，那时的iOS开源代码还是比较少的，我当时都是去官网去看一些代码，ASI还是非常火的网络框架，现在完全就不一样了，各种各样的轮子都有了。当然，在这些轮子的背景下并非所有的开源质量就很高，但一般情况下中口碑好的、使用人多的、关注度高的开源项目，质量是有一定的保证的，这其中的道理很简单。即便存在一些问题，也可以通过提交反馈，不断改进。而充分利用开源项目，能帮助你节省很多时间，把精力专注在最需要你关心的问题上。</p>

<p>能被关注的开源项目，都是领域内的高手所写，向这些牛人学习编程技巧，能让你知道如何能写出高效的代码，学习别人解决问题的方式，培养自己对代码更灵敏的嗅觉。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS学习资料整理]]></title>
    <link href="http://www.beyondabel.com/blog/2016/03/14/comming-soon/"/>
    <updated>2016-03-14T22:35:45+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/03/14/comming-soon</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/03/resource.png" alt="image" />
目录</p>

<!--more-->


<ul>
<li><a href="#1">iOS开发</a>

<ul>
<li> <a href="#1.1">架构设计</a></li>
<li> <a href="#1.2">Apple Watch</a></li>
<li> <a href="#1.3">Swift</a></li>
<li> <a href="#1.4">屏幕适配</a></li>
<li> <a href="#1.5">工程</a></li>
<li> <a href="#1.6">Foundation</a></li>
<li> <a href="#1.7">旋转</a></li>
<li> <a href="#1.8">Category</a></li>
<li> <a href="#1.9">UIKit</a>

<ul>
<li><a href="#1.9.1">UIViewController</a></li>
<li><a href="#1.9.2">UITableView</a></li>
<li><a href="#1.9.3">UIWebView</a></li>
<li><a href="#1.9.4">UIActionSheet</a></li>
<li><a href="#1.9.5">其他</a></li>
</ul>
</li>
<li> <a href="#1.11">iOS8</a>

<ul>
<li><a href="#1.12">App Extension</a></li>
</ul>
</li>
<li> <a href="#1.13">内存管理</a></li>
<li> <a href="#1.14">Block</a></li>
<li> <a href="#1.15">GCD</a></li>
<li> <a href="#1.16">绘图&amp;动画</a></li>
<li> <a href="#1.17">runtime</a></li>
<li> <a href="#1.18">C语言</a></li>
<li> <a href="#1.19">代码优化</a></li>
<li> <a href="#1.20">调试</a></li>
<li> <a href="#1.21">第三库的使用</a></li>
<li> <a href="#1.22">底层分析</a></li>
<li> <a href="#1.23">StoryBoard</a></li>
<li> <a href="#1.24">逆向</a></li>
<li> <a href="#1.25">面试</a></li>
<li> <a href="#1.26">工具</a></li>
<li> <a href="#1.27">技巧</a></li>
<li> <a href="#1.28">博客</a></li>
<li> <a href="#1.29">期刊</a></li>
</ul>
</li>
<li><a href="#2">其他</a>

<ul>
<li> <a href="#2.1">UI设计</a></li>
<li> <a href="#2.2">Markdown</a></li>
</ul>
</li>
</ul>


<h2 id="1">iOS开发</h2>


<p></p>

<h4 id="1.1">架构设计</h4>


<ul>
<li><a href="http://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html">iOS应用架构谈 开篇</a> by Casa Taloyum</li>
<li><a href="http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html">iOS应用架构谈 view层的组织和调用方案</a> by Casa Taloyum</li>
<li><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html">跳出面向对象思想(一)</a> 继承 by Casa Taloyum</li>
<li><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-er-duo-tai.html">跳出面向对象思想(二)</a> 多态 by Casa Taloyum</li>
<li><a href="http://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-san-feng-zhuang.html">跳出面向对象思想(三)</a> 封装 by Casa Taloyum</li>
</ul>


<h4 id="1.2">Apple Watch</h4>


<ul>
<li><a href="http://jerryliu.org/ios%20programming/Apple-Watch-Overview/">Apple Watch 开发调研一</a>：总览 by Swift 小瑞的BLOG</li>
<li><a href="http://jerryliu.org/ios%20programming/Apple%20Watch-WatchKit-Apps/">Apple Watch 开发调研二</a>：WatchKit Apps by Swift 小瑞的BLOG</li>
<li><a href="http://jerryliu.org/ios%20programming/Apple%20Watch-Glances-Notifications/">Apple Watch 开发调研三</a>: Glances,Notifications by Swift 小瑞的BLOG</li>
<li><a href="http://jerryliu.org/ios%20programming/Apple%20Watch-Development-summary/">Apple Watch三个月开发的一些收获总结</a> by Swift 小瑞的BLOG</li>
</ul>


<h4 id="1.3">Swift</h4>


<ul>
<li><a href="http://numbbbbb.gitbooks.io/-the-swift-programming-language-/content/"> The Swift Programming Language 中文版</a> by Swift 中文翻译组</li>
<li><a href="http://www.cocoachina.com/special/swift/">CocoaChina Swift专场</a> by CocoaChina</li>
<li><a href="https://github.com/ipader/SwiftGuide">Swift语言指南</a> by ipader</li>
<li><a href="http://swifter.tips/">喵神的Swift书~Tip列表</a> by onevcat</li>
<li><a href="https://swiftist.org/">Swift论坛社区</a> by Swiftist</li>
<li><a href="http://blog.sunnyxx.com/2014/10/14/fp-essential/">( ) –> ( )</a> by sunnyxx</li>
<li><a href="http://idlelife.org/archives/716">Swift如何检查系统版本</a> by <a href="http://idlelife.org">http://idlelife.org</a></li>
<li><a href="http://idlelife.org/archives/742">我在开发第一个Swift App过程中学到的四件事</a> by <a href="http://idlelife.org">http://idlelife.org</a></li>
</ul>


<h4 id="1.4">屏幕适配</h4>


<ul>
<li><a href="http://www.devtalking.com/articles/adaptive-layout-for-iphone6-1/">为iPhone6设计自适应布局（一）</a> by 宇轩</li>
<li><a href="http://www.devtalking.com/articles/adaptive-layout-for-iphone6-2/">为iPhone6设计自适应布局（二）</a> by 宇轩</li>
</ul>


<h4 id="1.5">工程</h4>


<ul>
<li><a href="http://www.cocoachina.com/ios/20140912/9605.html">iOS开发实战：如何将非ARC的项目转换成ARC项目</a> by CocoaChina</li>
</ul>


<h4 id="1.6">Foundation</h4>


<ul>
<li><a href="http://beyondvincent.com/blog/2014/01/26/how-to-sort-nsarray-with-custom-objects/">对NSArray中自定义的对象进行排序</a> by破船</li>
<li><a href="http://lldong.github.io/2014/02/24/key-paths-validation.html">Compile-time Key Paths Verification</a> by lldong</li>
<li><a href="http://lldong.github.io/2012/11/06/hanzi-to-pinyin.html">Cocoa 漢字轉拼音最簡單的方法</a> by lldong</li>
<li><a href="http://blog.xcodev.com/archives/ios-mmap-api/">iOS将大文件映射到内存</a> by xcodev</li>
<li><a href="http://www.isaced.com/post-244.html">用宏提速NSCoding</a> by isaced</li>
<li><a href="http://gracelancy.com/blog/2014/04/21/toll-free-bridging/">Toll-Free Bridging</a> by Lancy</li>
<li><a href="http://www.cocoachina.com/ios/20150512/11805.html">NSString属性什么时候用copy，什么时候用strong?</a> by 南峰子的技术博客</li>
</ul>


<h4 id="1.7">旋转</h4>


<ul>
<li><a href="http://rdc.taobao.org/?p=408">iOS旋转视图实践</a> by淘宝技术部</li>
<li><a href="http://blog.t-xx.me/blog/2014/01/19/force-rotate-uiviewcontroller/">强制旋转一个UIViewController</a> bytxx’s blog</li>
</ul>


<h4 id="1.8">Category</h4>


<ul>
<li><a href="http://www.cocoachina.com/applenews/devnews/2014/0212/7808.html">Objective-C相关Category的收集</a> by CocoaChina</li>
<li><a href="http://blog.xcodev.com/archives/implement-objc-property-in-category/">Objective-C语言在Category中实现属性</a> by xcodev</li>
</ul>


<h4 id="1.9">UIKit</h4>


<h5 id="1.9.1">UIViewController</h5>


<ul>
<li><a href="http://blog.devtang.com/blog/2012/02/06/new-methods-in-uiviewcontroller-of-ios5/">iOS5中UIViewController的新方法</a> by 唐巧</li>
</ul>


<h5 id="1.9.2">UITableView</h5>


<ul>
<li><a href="http://blog.cocoabit.com/blog/2014/02/09/uitableview-gun-dong-liu-cheng-xing-you-hua/">UITableView 滚动流畅性优化</a> by 6david9</li>
<li><a href="http://beyondvincent.com/blog/2014/01/13/animation-tableview-cell/">给tableview Cell添加动画</a> by 破船</li>
<li><a href="http://beyondvincent.com/blog/2014/03/26/cookbook-moving-table-view-cells-with-a-long-press-gesture/">利用长按手势移动 Table View Cells</a> by 破船</li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-26-make-swipeable-table-view-cell-actions-without-going-nuts-scroll-views.md">制作一个可以滑动操作的 Table View Cell</a> by nixzhu</li>
<li><a href="http://blog.xcodev.com/archives/no-keyboard-in-webview-of-ios5/">TableView中嵌套一个ScrollView有时导致ScrollView无法滚动</a> by xcodev</li>
</ul>


<h5 id="1.9.3">UIWebView</h5>


<ul>
<li><a href="http://blog.xcodev.com/archives/no-keyboard-in-webview-of-ios5/">iOS5网页视图（UIWebView）中的输入框不能弹出键盘的问题</a> by xcodev</li>
</ul>


<h5 id="1.9.4">UIActionSheet</h5>


<ul>
<li><a href="http://blog.devtang.com/blog/2012/06/24/enhance-uiactionsheet/">封装同步的UIActionSheet</a> by 唐巧</li>
</ul>


<h5 id="1.9.5">其他</h5>


<ul>
<li><a href="http://beyondvincent.com/blog/2014/01/20/how-to-build-a-custom-control-in-ios/">如何自定义iOS中的控件</a> by 破船</li>
</ul>


<h4 id="1.11">iOS8</h4>


<p>App Extension</p>

<ul>
<li><a href="http://foggry.com/blog/2014/06/23/wwdc2014zhi-app-extensionsxue-xi-bi-ji/">WWDC2014之App Extensions学习笔记</a> by foggry.com</li>
<li><a href="http://www.raywenderlich.com/83809/ios-8-today-extension-tutorial">iOS 8 Today Extension Tutorial</a> by raywenderlich.com</li>
<li><a href="http://zixun.github.io/blog/2014/10/22/%3Cyi-%3Eios-8-today-extension-tutorial/">&lt;译>iOS 8 Today Extension Tutorial</a> by zixun.github.io</li>
</ul>


<h4 id="1.12">内存管理</h4>


<ul>
<li><a href="http://onevcat.com/2012/06/arc-hand-by-hand/">手把手教你ARC——iOS/Mac开发ARC入门和使用</a> by onevcat</li>
<li><a href="http://lldong.github.io/2011/10/20/retain-count.html">retainCount 不会为 0</a> by lldong</li>
</ul>


<h4 id="1.13">Block</h4>


<ul>
<li><a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">谈Objective-C Block的实现</a> by 唐巧</li>
<li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/">正确使用Block避免Cycle Retain和Crash</a> by tanqisen</li>
</ul>


<h4 id="1.14">GCD</h4>


<ul>
<li><a href="http://blog.devtang.com/blog/2012/02/22/use-gcd/">使用GCD</a> by 唐巧</li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md">GCD 深入理解：第一部分</a> by nixzhu</li>
</ul>


<h4 id="1.15">绘图&动画</h4>


<ul>
<li><a href="http://blog.xcodev.com/archives/anti-alise-for-image-ios/">在iOS中让图片旋转时抗锯齿</a> by xcodev&lt;br</li>
<li><a href="http://answerhuang.duapp.com/index.php/2013/10/17/objective-c_c99/">Objective C中C99的使用</a> by answerhuangbr/> *</li>
</ul>


<h4 id="1.16">代码优化</h4>


<ul>
<li><a href="http://blog.leezhong.com/ios/2014/01/04/class-cluster.html">类簇在iOS开发中的应用</a> by无网不剩</li>
<li><a href="http://blog.leezhong.com/ios/2013/09/23/build-ios-application.html">iOS项目的目录结构和开发流程</a> by无网不剩</li>
<li><a href="http://studentdeng.github.io/blog/2014/05/09/pop-tweaks/">Facebook Pop &amp; Tweaks Demo</a> by不会开机的男孩</li>
</ul>


<h4 id="1.17">runtime</h4>


<ul>
<li><a href="http://blog.devwu.com/develop/2014-08-15/objcruntime-explore1/">objc/runtime 探索(一)</a></li>
<li><a href="http://blog.devwu.com/develop/2014-08-17/objcruntime-explore2/">objc/runtime 探索(二)</a></li>
<li><a href="http://blog.devwu.com/develop/2014-08-18/objcruntime-explore3/">objc/runtime 探索(三)</a></li>
<li><a href="http://blog.devwu.com/develop/2014-08-19/objcruntime-explore4/">objc/runtime 探索(四)</a></li>
<li><a href="http://www.jianshu.com/p/1bde36ad9938">轻松学习之一－－Objective-C消息转发</a> by J_雨</li>
</ul>


<h4 id="1.18">c语言</h4>


<ul>
<li><a href="http://www.cnblogs.com/rollenholt/articles/1907414.html">什么情况下用宏定义do{}while(0);这种结构体</a></li>
</ul>


<h4 id="1.19">调试</h4>


<ul>
<li><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/">LLDB调试命令初探</a> by 达叔</li>
</ul>


<h4 id="1.20">第三方库使用</h4>


<ul>
<li><a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">在iOS开发中使用FMDB</a> by 唐巧</li>
</ul>


<h4 id="1.21">底层分析</h4>


<ul>
<li><a href="http://blog.devtang.com/blog/2013/10/15/objective-c-object-model/">Objective-C对象模型及应用</a> by 唐巧</li>
</ul>


<h4 id="1.22">StoryBoard</h4>


<ul>
<li><a href="http://blog.devtang.com/blog/2012/12/15/do-not-use-storyboard/">StoryBoard—看上去很美</a> by 唐巧</li>
</ul>


<h4 id="1.23">逆向</h4>


<ul>
<li><a href="http://tweakweek.com/">TweakWeek</a> 每周一个开源tweek</li>
<li><a href="http://developer.limneos.net/">iPhone 7.0 Headers</a></li>
<li><a href="http://security.ios-wiki.com">iOS Security</a></li>
</ul>


<h4 id="1.24">面试</h4>


<ul>
<li><a href="http://onevcat.com/2013/04/ios-interview/">上级向的十个iOS面试问题</a> by onevcat</li>
</ul>


<h4 id="1.25">工具</h4>


<ul>
<li><a href="http://blog.devtang.com/blog/2012/12/02/use-cocoapod-to-manage-ios-lib-dependency/">使用CocoaPods来做iOS程序的包依赖管理</a> by 唐巧</li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/20067595">CocoaPods详解之——制作篇</a> by wangzz</li>
<li><a href="http://girlios.github.io/blog/2014/03/16/enrolling-in-apple-developer-programs/">Enrolling in Apple Developer Programs</a> by Girl_iOS</li>
</ul>


<h4 id="1.26">技巧</h4>


<ul>
<li><a href="http://www.cocoachina.com/newbie/basic/2014/0225/7882.html">Xcode Key Bindings &amp; Gestures利用快捷键提高开发效率</a> by CocoaChina</li>
<li><a href="http://www.gitignore.io/">www.gitignore.io</a> by gitignore
这个网站可以自动为你生成gitignore文件，比如你输入Objective Xcode 就会为你生成正对iOS开发的gitignore文件，如果你对gitignore文件不熟，那就请翻阅&lt;Git权威指南>。</li>
<li><a href="http://www.douban.com/note/165306479/">Chrome 快捷键 整理版 【来自豆瓣】</a> by douban</li>
<li><a href="http://segmentfault.com/a/1190000000475547">少有人知的 GitHub 使用技巧</a> by segmentfault</li>
</ul>


<h4 id="1.27">插件</h4>


<ul>
<li><a href="https://github.com/supermarin/Alcatraz">Alcatraz</a> by Github
Alcatraz是一个帮你管理Xcode插件、模版以及颜色配置的工具。它可以直接集成到Xcode的图形界面中，让你感觉就像在使用Xcode自带的功能一样.这里有一篇很好的介绍它的文章使用Alcatraz来管理Xcode插件</li>
<li><p><a href="https://github.com/omz/ColorSense-for-Xcode">ColorSense-for-Xcode</a> by Github
这个插件可以在编辑器上动态的渲染出你代码编写的颜色，例如在你写如下代码时它会在这段代码的右上角绘制出颜色预览，可以省去很多UI调整的时间</p></li>
<li><p><a href="https://github.com/ksuther/KSImageNamed-Xcode">KSImageNamed-Xcode</a> by Github
这个工具可以帮你自动补全image的图片信息，效果非常惊艳, 预览，自动补全，提示有无@2x高清图。</p></li>
</ul>


<h4 id="1.28">博客</h4>


<ul>
<li><a href="http://blog.devtang.com/">唐巧</a>(InfoQ编辑，Blogger，iOS开发，创业者，前网易员工。微信公共账号iOSDevTips创建者。)</li>
<li><a href="http://beyondvincent.com/">破船</a>(宠辱不惊，闲看庭前花开花落。去留无意，漫随天外云卷云舒。不妄取，不妄予，不妄想，不妄求。与人方便，随遇而安)</li>
<li><a href="http://onevcat.com/">喵神</a> (iOS/Mac,Unity3D开发者，现就职于日本创意公司Kayac，正在修行，探求创意之源)</li>
<li><a href="http://www.devtalking.com/">宇轩</a>(付宇轩，80后，程序员，关注技术和人文，记录学习的点点滴滴于《程序员说》)</li>
<li><a href="http://blog.cocoabit.com/">6david9</a>(iOS码农，攻城狮。喜欢各种有意思的东西。最近迷恋上了自行车。)</li>
<li><a href="http://lldong.github.io/">lldong</a>(不详！)</li>
<li><a href="http://yingkong1987.github.io/">yingkong1987</a>(@兔be南玻1)</li>
<li><a href="http://blog.xcodev.com/">xcodev</a>(资深iOS开发工程师@谌启亮)</li>
<li><a href="http://www.isaced.com/">isaced</a>(iOS Programmer@isaced)</li>
<li><a href="http://answerhuang.duapp.com/">answerhuang</a>(iOS developer, Python fans@answer-huang)</li>
<li><a href="http://geeklu.com/">卢克</a>(Mac，iOS开发@卢小克)</li>
<li><a href="http://blog.csdn.net/ysy441088327">余书懿</a>(代表作:&lt;豆豆音乐> @余书懿)</li>
<li><a href="http://wangling.me/">Creator of moke</a>(Creator of 墨客(moke.com) and Voodo(moke.com/voodo)@an00na)</li>
<li><a href="http://iiiyu.com/">萧宸宇</a>(注定漂泊的人@Sumi-iYu)</li>
<li><a href="http://webfrogs.me/">webfrogs</a>(iOS开发，开源爱好者 @webfrogs)</li>
<li><a href="http://esoftmobile.com/">esoftmobile</a>(iOS开发者 esoftmobile.com @TracyYih)</li>
<li><a href="http://blog.leezhong.com/">无网不剩</a>(iOS开发@李忠)</li>
<li><a href="http://www.starfelix.com/">starfelix达叔</a>(不要告诉任何人你无法实现自己的梦想，包括我！@达叔是一种沧桑)</li>
<li><a href="http://www.tanhao.me/">老谭</a>(不详，但看博客内容很牛！)</li>
</ul>


<h4 id="1.29">期刊</h4>


<ul>
<li><a href="http://www.objc.io/">objc.io</a> —-中文版—–> <a href="http://www.objccn.io/">objccn.io</a></li>
<li><a href="http://nshipster.com/">nshipster.com</a> —-中文版—–> <a href="http://nshipster.com/">nshipster.cn</a></li>
<li><a href="http://raywenderlich.com">raywenderlich.com</a></li>
</ul>


<h4 id="2">其他</h4>


<h5 id="2.1">UI设计</h5>


<p>Sketch</p>

<ul>
<li><a href="http://www.zcool.com.cn/article/ZODQ1ODA=.html">酷九合金社Sketch教程系列-IOS图标（上）</a> by C9D</li>
<li><a href="http://www.zcool.com.cn/article/ZODQ1ODg=.html">酷九合金社Sketch教程系列-IOS图标（下）</a> by C9D</li>
<li><a href="http://www.ui.cn/project.php?id=31346">奇葩的Sketch教程，专治各种疑难杂症</a> by JaminWoo</li>
</ul>


<h4 id="2.2">Markdown</h4>


<ul>
<li><a href="http://www.appinn.com/markdown/">Markdown 语法说明 (简体中文版)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS移动开发周报-第3期]]></title>
    <link href="http://www.beyondabel.com/blog/2016/03/11/weekly03/"/>
    <updated>2016-03-11T13:01:11+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/03/11/weekly03</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/03/weekly03.png" alt="image" /></p>

<!--more-->


<h2>业界新闻</h2>

<ol>
<li><a href="http://www.cocoachina.com/android/20160311/15656.html">Android 7.0新特性曝光：装App只需几秒</a> : 谷歌出乎意料的放出Android 7.0（Android N）的开发者预览版，Android 7.0带来了不少新特性，原生的分屏多任务支持、画中画功能、通知栏快速回复功能等。现在，Android 7.0又一新特性被曝出。</li>
<li><p><a href="http://www.macx.cn/thread-2183605-1-1.html">盘古发布 iOS 9.1 越狱工具，Apple TV 4 越狱即将到来</a>：中国团队盘古更新了越狱工具，并开始支持运行 iOS 9.1 的设备。盘古越狱工具支持 Mac 和 Windows，用户可以对 iPad、iPhone 和 iPod touch 等设备完成越狱。更有趣的是，盘古团队表示下周会推出第四代 Apple TV 越狱工具。</p></li>
<li><p><a href="http://tech.163.com/16/0307/06/BHHLO4PH000915BF.html">Mac用户成勒索病毒的首攻目标</a>：据路透社报道，苹果公司用户成为黑客首次针对Macintosh电脑的攻击目标。Ransomeware是目前增长最快的一种网络安全威胁因素，被感染的计算机数据将会被加密。之后，受害者需要支付一定的赎金以获取密码来解锁数据。</p></li>
</ol>


<h2>教程</h2>

<ol>
<li><a href="http://www.jianshu.com/p/0b0d9b1f1f19">关于iOS多线程，你看我就够了</a>：正如文章标题所示，这是一篇关于多线程的文章，以及其使用方法和注意事项。当然也会给出几种多线程的案例，在实际使用中感受它们的区别。</li>
<li><a href="http://www.jianshu.com/p/7e3f197504c1">iOS开发中的测试框架</a>：我们为什么要用测试框架呢？当然对项目开发有帮助了，但是业内现状是经常赶进度，所以TDD还是算了吧，BDD就测测数据存取和重要环节，这很重要，一次性跑完测试单元检查接口或模块的可用性，这比打断点调试强多了吧。</li>
<li><a href="http://www.jianshu.com/p/f6300eb3ec3d">runtime那些事</a>：我们经常会遇到RunTime（或者听别人说），这里有四篇文章是关于<code>runtime</code>教程，相信这四篇文章对你在<code>runtime</code>的理解有非常大的帮助。</li>
</ol>


<h2>开源代码</h2>

<ol>
<li><a href="https://github.com/hades0918/ipapy">ipapy</a> : 一个用Python写的iOS项目自动打包脚本工具。</li>
<li><a href="https://github.com/BradLarson/GPUImage">GPUImage</a> : 一款强大的图片滤镜工具, 支持自定义滤镜, 可用来实时处理图片和视频流, 作者是 SonoPlot 公司的 CTO, 在很小的时候便开始接触编程, 他在 SO 上面的回答也有很多值得阅读, GPUImage 这个项目从 2012 年开始, 使用 OpenGL 图形程序接口编写, 性能非常好, 现在很多 iOS 程序员都用它来实现 iOS 的模糊效果.</li>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> : 由 GitHub 工程师们开发的一个应用于 iOS 和 OS X 开发的函数响应式编程新框架, Matt 称其为 &ldquo;An open source project that exemplifies this brave new era for Objective-C&rdquo;, 也有人说它是 Cocoa 的未来.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS移动开发周报-第2期]]></title>
    <link href="http://www.beyondabel.com/blog/2016/03/03/weekly02/"/>
    <updated>2016-03-03T00:36:30+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/03/03/weekly02</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/03/weekly02.png" alt="image" /></p>

<!--more-->


<h2>业界新闻</h2>

<ol>
<li><a href="http://www.cocoachina.com/apple/20160302/15503.html">苹果iOS 10系统已现身：允许删除系统预装软件</a></li>
<li><a href="http://news.xinhuanet.com/fortune/2016-03/02/c_128769374.htm">OpenSSL曝新漏洞 超1100万HTTPS站点受影响</a></li>
<li><a href="http://www.infoq.com/cn/news/2016/02/realm-react-native">Realm推出了适用于React Native的新数据库</a></li>
<li><a href="http://tech.qq.com/a/20160303/028642.htm">苹果获柔性屏专利 或应用到未来iPhone中</a></li>
</ol>


<h2>教程</h2>

<ol>
<li><a href="http://www.jianshu.com/p/f970872fdc22">《iOS高效添加圆角效果实战讲解》</a>: 在项目中我们会经常使用圆角来做一些效果，通过这篇文章你就会知道为什么自己的项目会很卡，自己的姿势是否正确了。</li>
<li><a href="http://wereadteam.github.io/2016/02/22/MLeaksFinder/">MLeaksFinder：精准 iOS 内存泄露检测工具</a>：在 iOS 开发中，稍不注意就会导致内存泄露的问题，MLeaksFinder 相较于 Instrument，为我们提供了更方便易用的内存泄露检测方案。这篇文章介绍了该工具的使用方式。</li>
</ol>


<h2>开源代码</h2>

<ol>
<li><a href="https://github.com/Mantle/Mantle">Mantle</a> : Mantle是一个用于简化Cocoa或Cocoa Touch程序中model层的第三方库。通常我们的应该中都会定义大量的model来表示各种数据结构，而这些model的初始化和编码解码都需要写大量的代码。而Mantle的优点在于能够大大地简化这些代码。</li>
<li><a href="https://github.com/marcuswestin/WebViewJavascriptBridge">WebViewJavaScriptBridge</a> : WebViewJavascriptBridge是Obj-C和JavaScript通过UIWebViews/WebViews互通消息的一个iOS/OSX的桥梁.</li>
<li><a href="https://github.com/SnapKit/Masonry">Masonry</a> : 用过autolayout会感觉这东西好麻烦，写一个约束得一堆很罗嗦的代码，还不如直接frame来得快，Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了，非常好用</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIWebView中Objective-C与JavaScript交互]]></title>
    <link href="http://www.beyondabel.com/blog/2016/03/03/oc-to-js/"/>
    <updated>2016-03-03T00:13:39+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/03/03/oc-to-js</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/03/js-oc.png" alt="image" /></p>

<p>现在越来越多的项目为了支持公司业务的发展而选择使用HTML5做一些功能，那么这样就会涉及到HTML5与原生Objective-C的交互，今天就聊聊HMTL与原生之间的相互调用问题。</p>

<!--more-->


<h3>概述</h3>

<p>原生与Web页面的交互可以分为Objective-C执行JavaScript代码和Web页面（或JavaScript）执行Objective-C代码,前者相对非常简单，后面可以通过JavaScriptCore、拦截协议等方式实现，下面我将主要对这二种方式进行叙述。</p>

<h3>Objective-C执行JavaScript代码</h3>

<p>打开UIWebView的头文件我们可以发现有一个方法叫stringByEvaluatingJavaScriptFromString:，它就是Objective-C执行JavaScript代码的通路，并且要注意它的返回值是NSString，这个方法在平时非常实用，列举几个例子：</p>

<pre><code>// 获取当前页面的title
NSString *title = [webview stringByEvaluatingJavaScriptFromString:@"document.title"];

// 获取当前页面的可高度
float offsetHeight = [[webview stringByEvaluatingJavaScriptFromString:@"document.body.offsetHeight"] floatValue];

// 获取需要分享的类内
NSString *sharedDictionary = [webview stringByEvaluatingJavaScriptFromString:@"getSharedContent"];
</code></pre>

<h3>JavaScript执行Objective-C代码</h3>

<p>JavaScript执行Objective-C代码之前我就说过有二种方式，现在我分别来说说这二种方式。</p>

<h4>1. 利用JavaScriptCore来执行Objective-C代码</h4>

<p>iOS7之后苹果推出了JavaScriptCore这个框架，从而让Web页面和本地原生应用交互起来非常方便，而且使用此框架可以做到Android那边和iOS相对统一，web前端写一套代码就可以适配客户端的两个平台，从而减少了Web前端的工作量。</p>

<h5>Web前端</h5>

<p>在三端交互中，web前端要强势一些，一切传值、方法命名都按web前端开发人员来定义，让另外两端去做适配。在这里以调用分享为例来详细讲解，测试网页代码取名为shared.html，其代码内容如下：</p>

<p>shared.html代码内容</p>

<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;title&gt;js调用objective-c代码&lt;/title&gt;
    &lt;style type="text/css"&gt;
        #backButton { 
            display: inline-block;
            width:50px; height:30px;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;button id="backButton"&gt;返回&lt;/button&gt;
    &lt;script type="text/javascript"&gt;

        var btn = document.getElementById('backButton');

        btn.addEventListener('click', function() {
           callBackObj.letsGoBack();
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h5>iOS</h5>

<p>iOS这边根据前端定义的方法名来写代码，但是有些时候web前端会让我们定义，但是我们定义好之后他又要修改，这时候就会很烦啊。所以碰到三端交互的时候最好就是让web前端去定义方法名，iOS和Android根据web前端定义好的去写代码。JavaScriptCore中web页面调用原生应用的方法可以用Delegate或Block两种方法，此文以按Delegate讲解。</p>

<pre><code>JavaScriptCore中类及协议：

JSContext：给JavaScript提供运行的上下文环境
JSValue：JavaScript和Objective-C数据和方法的桥梁
JSManagedValue：管理数据和方法的类
JSVirtualMachine：处理线程相关，使用较少
JSExport：这是一个协议，如果采用协议的方法交互，自己定义的协议必须遵守此协议
</code></pre>

<p>ViewController中的代码</p>

<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView {

    JSContext *context = [webView valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
    [context setExceptionHandler:^(JSContext *ctx, JSValue *value) {
    NSLog(@"error: %@", value);
}];

    context[@"callBackObj"] = self;
}

- (void) letsGoBack {
    [self.navigationController popViewControllerAnimated:YES];
}
</code></pre>

<p>ViewController中的代码解释</p>

<p>看到上面的代码我们可以看到设置了context中的callBackObj为self,通过这样的设置js在使用callBackObj.letsGoBack时其实等价于在viewController中使用[self letsGoBack]。</p>

<p>运行效果如图所示</p>

<p><img src="http://www.beyondabel.com/images/2016/03/js-to-oc.gif" alt="image" /></p>

<h4>拦截协议</h4>

<p>首先我说解释一下什么是协议，协议是共同计议的规定，是大家一起遵循的准则。拦截协议这个非常适合各个平台，不需要引入什么框架，只需要大家相互之间遵守协议就可以了。那么在我们团队中协议是怎么定义的呢？scheme://model/aciton?{参数1}={数值1}&amp;{参数2}={数值2}&amp;&hellip;，比如在金蛋中分享的协议会是:jindanlicai://active/shared?callback=result(&lsquo;%s&rsquo;,&lsquo;%s&rsquo;)&amp;function=getContent()。其中，function的值是可以获取分享内容的JavaScript函数名称，callback的值是分享结束之后调用的方法来告知HTML5是否分享成功与失败状态。</p>

<h5>web前端</h5>

<p>home.html中的代码</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;input type="button" value="分享" onclick="share()"&gt;
        &lt;/div&gt;

        &lt;script&gt;
        function share() {
            window.location.href = 'jindanlicai://active/shared?callback=result('%s','%s')&amp;function=getContent()';
        }
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>home.html中的代码解释</p>

<p>通过点击分享按钮将会调用JavaStript中的share()，window.location.href这里是改变主窗口的指向从而马上发出一个链接为‘jindanlicai://active/shared?callback=result(&lsquo;%s&rsquo;,&lsquo;%s&rsquo;)&amp;function=getContent()’请求，而在iOS方法中我们要拦截这个请求，根据URL请求内容去判断Web页面想要原生做的事情，从而实现web页面和本地应用之间的交互。</p>

<h5>iOS</h5>

<p>iOS对应的代码</p>

<pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType {
    NSString *url = request.URL.absoluteString;
    if ([[request.URL scheme] isEqualToString:@"jindanlicai"]) {
        [JDOpenURL handlerURL:request.URL context:self];
        return NO;
    }
    return YES;
}
</code></pre>

<p>iOS对应的代码的解释</p>

<p>在webView的代理方法中去拦截URL的scheme为自定义jindanlicai协议，调用原生提前约定好的方法，并且返回值为NO来阻止此链接的跳转。</p>

<h3>总结</h3>

<p>随着手机硬件的配置越来越强大和HTML5的兴起，一个App完全可以由web页面来写。现在在我们公司已经有很多的App已经完全是这么干了，iOS和Android只是给这个App套一个壳并通过一些协议去实现一些本地逻辑。协议是一个非常不错的方法，在这我推荐使用协议去做这样的事，当前提前是你要非常理解协议。如果有人喜欢协议，WebViewJavaScriptBridge是一个不错的第三库。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS移动开发周报-第1期]]></title>
    <link href="http://www.beyondabel.com/blog/2016/02/28/weekly01/"/>
    <updated>2016-02-28T17:05:32+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/02/28/weekly01</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/02/weekly01.png" alt="image" /></p>

<!--more-->


<h3>业界新闻</h3>

<hr />

<ol>
<li><a href="http://tech2ipo.com/10027880">Facebook 再次进军搜索领域，想和 Google 干一仗？</a></li>
<li><a href="http://tech.sina.com.cn/mobile/n/n/2016-02-26/doc-ifxpvysv4898279.shtml">传苹果将推出9.7英寸iPad Pro</a></li>
<li><a href="http://tech.sina.com.cn/it/2016-02-26/doc-ifxpvysx1670446.shtml">微软正式宣布移植 Android 应用计划流产</a></li>
</ol>


<h3>教程</h3>

<hr />

<ol>
<li><a href="http://www.jianshu.com/p/c467809bedb3">《七个Swift中的陷阱以及避免方法》</a>: Swift语言希望通过采用安全的编程模式去帮助开发者避免bug。然而这也会不可避免的产生一些人造的陷阱，他们会在编译器不报错的情况下引入一些Bug。这些陷阱有的已经在Swift book中提到，有一些还没有。这里有七个我在去年遇到的陷阱，它们涉及Swift协议扩展、可选链和函数式编程。</li>
<li><a href="http://jspatch.com/Docs/intro">《JSPatch使用文档》</a>:JSPatch 是一个开源项目(Github链接)，只需要在项目里引入极小的引擎文件，就可以使用 JavaScript 调用任何 Objective-C 的原生接口，替换任意 Objective-C 原生方法。目前主要用于下发 JS 脚本替换原生 Objective-C 代码，实时修复线上 bug。</li>
<li><a href="http://bugly.qq.com/bbs/forum.php?mod=viewthread&amp;tid=267&amp;extra=page%3D1">H5 缓存机制浅析 移动端 Web 加载性能优化</a>:如果曾经被UIWebView的cache虐过的人可以看看这篇文章是否能解决你的问题。</li>
</ol>


<h3>开源代码</h3>

<hr />

<ol>
<li><a href="https://github.com/beyondabel/BATableView">BATableView</a> : BATableView是自定义列表中的索引栏（Index Bar）。手指滑动 index bar 时，中间会出现黑色小浮块，并把index Bar上的字显示在黑色小浮块上，黑色小浮块上的字会随手指index bar 变换。</li>
<li><a href="https://github.com/dustturtle/RealReachability">RealReachability</a>：一个类似于Reachability的库，但比Reachability对网络侦听更好的库。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac系统安装Lua]]></title>
    <link href="http://www.beyondabel.com/blog/2016/01/04/macxi-tong-an-zhuang-lua/"/>
    <updated>2016-01-04T21:44:12+08:00</updated>
    <id>http://www.beyondabel.com/blog/2016/01/04/macxi-tong-an-zhuang-lua</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2016/02/beyondabel.png" alt="image" /></p>

<!--more-->


<ol>
<li>下载最新版的<a href="http://www.lua.org/download.html">lua-5.2.0</a> 请点击，然后解压</li>
<li>运行“终端”进入到该文件夹下  ，主要是cd 【文件夹名】</li>
<li>在“终端”输入    make macosx   （回车）</li>
<li><p>在“终端”输入    make test  （回车）</p>

<p> 正常情况下会出现： src/lua -v
            Lua 5.2.0 Copyright&copy;1994-2011 Lua.org,PUC-Rio</p></li>
<li><p>然后再输入“sudo make install”命令，会要求输入Password:     输入相应密码（你的密码），然后回车就自动安装了</p></li>
</ol>


<p>待安装完成后可输入 lua -v，回车就会看到 ：Lua 5.2.0  Copyright &copy; 1994-2011 Lua.org, PUC-Rio</p>

<p>OK ，已经安装成功！</p>

<p>然后你可以键入lua   开始lua之旅！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自己写一个第三方分享库（一）]]></title>
    <link href="http://www.beyondabel.com/blog/2015/07/16/share1/"/>
    <updated>2015-07-16T14:19:24+08:00</updated>
    <id>http://www.beyondabel.com/blog/2015/07/16/share1</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2015/07/16/share1.png" alt="image" /></p>

<h4>前言</h4>

<p>最近想做分享时，总是遇到需要更新最新包的问题，并且还需要导入真机和模拟器二个包，非常麻烦，所以一直在思考如何自己做一个分享库，要想做第三方的分享库，首要问题是需要知道App是如何跳转以及分享数据是如何传递，之前我想到是通过OpenURL中URL后面带参数去实现，后来想想URL长度传递是不可能允许这么多的数据传递，应该是通过App之间相互能访问的存储空间实现APP之间的数据传递，想想只有剪贴版了，实践证明我的猜想是对的，所以就把这次研究的步骤一步一步想下，与大家分享~</p>

<!--more-->


<h4>准备工作</h4>

<p>本代码都是在真机上测试，模拟器不在此次考虑之内，为了简化，现在暂时以微信做介绍。</p>

<p>到微信官网下载Lib库，并按照微信官方指示搭建项目。</p>

<h4>证明猜想</h4>

<p>微信会话分享代码</p>

<pre><code>- (void)weixinSession_share:(NSDictionary *)para {

    WXMediaMessage *message = [WXMediaMessage message];
    message.title = title;
    message.description = description;
    [message setThumbImage:[UIImage imageNamed:@"Icon-72"]];

    WXWebpageObject *ext = [WXWebpageObject object];
    ext.webpageUrl = webpageUrl;
    message.mediaObject = ext;

    SendMessageToWXReq* req = [[SendMessageToWXReq alloc] init];
    req.bText = NO;
    req.message = message;
    req.scene = WXSceneSession;
    [WXApi sendReq:req];

    NSArray * pastboardTypes = [[UIPasteboard generalPasteboard] pasteboardTypes];
    for (NSString * pastboardType in pastboardTypes) {
        NSData * data = [[UIPasteboard generalPasteboard] valueForPasteboardType:pastboardType];
        NSDictionary * dictionary = [NSPropertyListSerialization propertyListWithData:data options:NSPropertyListBinaryFormat_v1_0 format:0 error:nil];
        debug(@"%@", dictionary);
    }
}
</code></pre>

<p>打印出来的结果</p>

<pre><code>{
    wx72607e32ec65d0e1 =     {
        command = 1010;
        description = "8%\U6d3b\U671f\U6536\U76ca\U7387\Uff0c\U4ec5\U5343\U5206\U4e4b\U4e00\U574f\U5e10\U7387\Uff0c2015\U5e74\U6700\U706b\U7206\U7684\U62a2\U94b1\U795e\U5668\Uff0c\U771f\U5fc3\U8dea\U4e86\Uff01";
        mediaUrl = "http://www.jindanlicai.com/download/download.html";
        objectType = 5;
        result = 1;
        returnFromApp = 0;
        scene = 0;
        sdkver = "1.5";
        thumbData = &lt;ffd8ffe0 .....&gt;;（图片太长，这个就省略了）
        title = "\U91d1\U86cb\U7406\U8d22\Uff0c\U8de8\U754c\U7406\U8d22\U795e\U5668";
    };
}
</code></pre>

<p>从打印结果看，他的数据是存在UIPasteboard中，其中，wx72607e32ec65d0e1为我在微信平台申请的key值，description为分享描述，mediaUrl为分享链接，objectType为分享对象类型，scene为分享目的地，sdkver为版本号，thumbData为分享的缩略图，title为分享标题。</p>

<h4>自己实现分享</h4>

<p>既然我们已经知道了微信的数据保存在哪，并且知道他的数据格式是如何保存的，那么我们就可以自己写代码去实现微信分享了，我们新建一个项目SharedSDKDemo,然后在viewController中添加如下代码</p>

<pre><code>- (NSString*)weixinShare {
    NSMutableDictionary *dic=[[NSMutableDictionary alloc] initWithDictionary:@{
                            @"result" : @"1",
                            @"returnFromApp" : @"0",
                            @"scene" : [NSString stringWithFormat:@"%d",shareTo],
                            @"sdkver" : @"1.5",
                            @"command" : @"1020",
                            @"title" : @"我们来测试",
                        }];

    NSData *output = [NSPropertyListSerialization dataWithPropertyList:@{@"wxd930ea5d5a258f4f":dic} format:NSPropertyListBinaryFormat_v1_0 options:0 error:nil];
    [[UIPasteboard generalPasteboard] setData:output forPasteboardType:@"content"];



[[UIApplication sharedApplication]openURL:[NSURL URLWithString:[NSString stringWithFormat:@"weixin://app/%@/sendreq/?",@"wx72607e32ec65d0e1"]];
}
</code></pre>

<p>执行以上代码可以得到：</p>

<p><img src="http://img.blog.csdn.net/20150714224138423" height="568" width="320" alt="image " /></p>

<p>由此可看到如果我们自己想做一具分享SDK也是可以的~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac Unity3D安装及破解教程]]></title>
    <link href="http://www.beyondabel.com/blog/2014/04/07/unity3dinstall/"/>
    <updated>2014-04-07T17:41:20+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/04/07/unity3dinstall</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2014/04/07/unity3dInstall.png" alt="image" /></p>

<h3>引言</h3>

<p>Unity是由Unity Technologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。Unity类似于Director,Blender game engine, Virtools 或 Torque Game Builder等利用交互的图型化开发环境为首要方式的软件其编辑器运行在Windows 和Mac OS X下，可发布游戏至Windows、Mac、Wii、iPhone、Windows phone 8和Android平台。也可以利用Unity web player插件发布网页游戏，支持Mac 和Windows的网页浏览。它的网页播放器也被Mac widgets所支持。</p>

<!--more-->


<p>最近由于工作需要，涉及了Unity3D开发，作为一个Unity3D开发小白，把自己开发过程记录下来是非常有必要的，一个是以后再次涉及有笔记可看，同时也是方便其他朋友学习。</p>

<h3>目录</h3>

<ul>
<li>1、Unity3D下载及安装</li>
<li>2、Unity3D破解</li>
</ul>


<h3>1、Unity3D下载及安装</h3>

<p>Unity3D安装包可以到官网下载也可以点击 <a href="http://pan.baidu.com/s/1pJ4Tdmr">http://pan.baidu.com/s/1pJ4Tdmr</a> 下载。下载完之后按正常软件安装即可，这里就不做过多讲解。</p>

<h3>2、Unity3D破解</h3>

<p>如果你资金充足的话，建议还是去购买正版。如果是练手开发当然就没必须去购买了。</p>

<ul>
<li>1、下载Unity3D破解文件（这里给一个下载地址：<a href="http://pan.baidu.com/s/1gdoUvbt%EF%BC%89">http://pan.baidu.com/s/1gdoUvbt%EF%BC%89</a></li>
<li>2、在finder里找到unity，右键显示包内容，进入Contents/MacOS,找到Unity文件，一会我们要替换它（如果不放心可以县备份一下里面的Unity 文件）</li>
</ul>


<p><img src="http://www.beyondabel.com/images/2014/04/07/1.png" alt="image" /></p>

<ul>
<li>3、打开破解文件，用破解文件里的Unity 文件替换MacOS里的Unity文件</li>
<li>4、运行unity，点最右边的Manuak Activation按钮，然后选择load License找到破解文件里的Unity_v4.x.ulf，选择，成功后会提示载入成功</li>
</ul>


<p><img src="http://www.beyondabel.com/images/2014/04/07/2.png" alt="image" /></p>

<p><img src="http://www.beyondabel.com/images/2014/04/07/3.png" alt="image" /></p>

<p><img src="http://www.beyondabel.com/images/2014/04/07/4.png" alt="image" /></p>

<p>破解成功的标志：</p>

<ul>
<li>1、运行Unity后没有其他乱七八糟的提示。</li>
<li>2、点击状态栏的Unity，破解不成功的话有些选项是灰色不可点击的，例如About Unity&hellip;等</li>
</ul>


<p><img src="http://www.beyondabel.com/images/2014/04/07/5.png" alt="image" /></p>

<h2>&ndash; 3、点击About Unity&hellip;后会出现各种pro</h2>

<p><img src="http://www.beyondabel.com/images/2014/04/07/6.png" alt="image" /></p>

<p>这就说明你已经破解成功了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC VS MRC，这不是一个编程习惯问题]]></title>
    <link href="http://www.beyondabel.com/blog/2014/03/05/mrc-arc/"/>
    <updated>2014-03-05T10:21:40+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/03/05/mrc-arc</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2014/03/05/arcvsmrc.png" alt="image" /></p>

<h3>引言</h3>

<p>虽然距离WWDC2011和iOS5已经过去3年多时间了，但之前我一直没有去研究过ARC，一个是因为觉得ARC非常简单，到时什么时候想使用ARC时再转向ARC，第二个是担心内存管理不受自己控制（好吧，从现在来看是我对ARC机制了解不足而已），第三，我觉得使用MRC更能体现一个码农对内存管理的理解，第四，我是一个追求技术不“追赶时髦”的码农。说了这么多的原因，其实是想说作为一个最需要“追求时髦”的职业，我这样的心态是错误的。写这篇文章的目的是希望和我一同处于对 MAC &amp;　ARC迷茫的人的一个参考吧！</p>

<!--more-->


<h3>目录</h3>

<ul>
<li>1、 什么是ARC</li>
<li>2、 ARC工作原理</li>
<li>3、 MRC的代价</li>
<li>4、 ARC &amp; MAC 在大量数据下的测试</li>
<li>5、 CF与Objective-C在ARC下的内存管理</li>
<li>6、 使用ARC注意事项</li>
<li>7、 总结</li>
</ul>


<h4>1、什么是ARC</h4>

<p>什么是ARC，google一下，你会发现有太多太多对ARC非常非常详细的讲解。对于有C++背景的人来说，ARC的本质从某种角度上来说类似 C++ 的智能指针，区别就是ARC更智能简单，而且会加速程序，而不是像智能指针那样会一定程度上减慢程序运行。对于纯ObjC背景的人来说，ARC相当于编译器自动帮你填写了 retain, release。但是，远远不是这么简单。</p>

<p>首先ARC不会真的填写<code>retain/release</code>，<code>retain/release</code> 是 ObjC的消息，ARC会直接调用runtime的C函数，这会快很多。另外对于MRC中恶心的 <code>return [[[XXX alloc] init] autorelease]</code> ，ARC不但可以简化其写法，还可以让它更快，原因就在于它可以消除不必要的“入池”操作（<code>autorelease</code>是放到了自动释放池），详见objc_retainAutoreleasedReturnValue.</p>

<p>基于上面两点，ARC会让所有涉及到内存的操作变快。</p>

<p>ARC虽然会让单位内存操作变快，甚至会智能的取消某些<code>retain/release</code>，但是毕竟ARC不是人脑，如果一个人完全清晰的掌握某个对象的生命周期，那么他完全可以只retain一次，然后在最后不需要的时候release掉，所以MRC可以在这种情况下比ARC快。至于具体应用到项目中的数据，可以参考 <a href="http://www.learn-cocos2d.com/2013/12/performance-comparison-cocos2diphone-v2-v3-sparrow-arc-mrc/">http://www.learn-cocos2d.com/2013/12/performance-comparison-cocos2diphone-v2-v3-sparrow-arc-mrc/</a>  。其中有快有慢。</p>

<h4>2、 ARC工作原理</h4>

<p>手动内存管理的机理大家应该已经非常清楚了，简单来说，只要遵循以下三点就可以在手动内存管理中避免绝大部分的麻烦：</p>

<p>如果需要持有一个对象，那么对其发送retain 如果之后不再使用该对象，那么需要对其发送release（或者autorealse） 每一次对retain,alloc或者new的调用，需要对应一次release或autorealse调用</p>

<p>初学者可能仅仅只是知道这些规则，但是在实际使用时难免犯错。但是当开发者经常使用手动引用计数 MRC 的话，这些规则将逐渐变为本能。你会发现少一个release的代码怎么看怎么别扭，从而减少或者杜绝内存管理的错误。可以说MRC的规则非常简单，但是同时也非常容易出错。往往很小的错误就将引起crash或者内存溢出之类的严重问题。</p>

<p>在MRC的年代里，为了避免不小心忘写release，Xcode提供了一个很实用的小工具来帮助可能存在的代码问题(Xcode里默认快捷键command+B)，可以指出潜在的内存泄露或者过多释放。而ARC在此基础上更进一步：ARC是Objective-C编译器的特性，而不是运行时特性或者垃圾回收机制，ARC所做的只不过是在代码编译时为你自动在合适的位置插入release或autorelease，就如同之前MRC时你所做的那样。</p>

<h4>3、MRC的代价</h4>

<p>代码有好多代价，最简单直白的代价是编写时的代价，然后更重大的代价则是维护的代价。</p>

<p>编写的代价：
每个人的脑力都是有限的，而在编程的时候往往需要全心专注，这说明编程本身就耗费了100%的脑力。基于这个出发点，那么如果一个人在每写100行代码里面10行都是内存维护相关的代码时，他分配给其他的东西（程序结构，API设计，业务逻辑）肯定会减少，除非他愿意花更多的时间来写这个东西（加班）。注意，内存维护的10行代码并非简单地事情，要把他们搞正确，一个合格的MRC程序员肯定会前后审阅自己的代码好几遍。</p>

<p>维护的代价：
代码的本质是动态的，它会随着时间不停的改变自己，所以代码不但需要运行时健壮，同时还需要重构健壮，即你能安全的重构一段代码，而不是重构之后错误百出。这个举个常见例子：</p>

<p>在MRC下，有一个函数，在运行中间会 return 掉，那么所有合格的MRC程序员必然会记得在return之前把 alloc 的对象逐个 release 掉，咱不讨论在MRC下如果多几个中途return会让代码多么难写（这是编写代价），假设写好了，程序OK，没bug。然后某天重构了，把 return 提前了，然后由于位置提前，需要release的对象变成了另外一些，这会造成相当多的重构bug。另外一个例子，假设这个MRC程序员采用了极端的 retain/release 优化，那么在重构时必然要全面审视新的代码下面原来的优化是否安全，代价很高。那如果这些代码要交给别人重构呢？</p>

<p>维护代价的另一面是阅读时的代价。代码的价值是给人（别人或者自己）读，一行代码敲下去，可能要被读10遍，20遍。设想一下阅读到处穿插 <code>retain/ release</code> 的代码 vs 阅读清晰的业务逻辑的代码的容易程度对比。</p>

<h4>4、 ARC &amp; MAC 在大量数据下的测试</h4>

<p>下面举一个例子，同样的代码，只是在「ARC」与「MRC」的情況下编译执行， 但是二者所需要的时间是相差数倍的！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">600000</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span>
</span><span class='line'><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">arr</span> <span class="nl">addObject</span><span class="p">:[</span><span class="bp">NSNumber</span> <span class="nl">numberWithInt</span><span class="p">:</span><span class="mi">1</span><span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFAbsoluteTime</span> <span class="n">start</span> <span class="o">=</span> <span class="n">CFAbsoluteTimeGetCurrent</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFAbsoluteTime</span> <span class="n">end</span> <span class="o">=</span> <span class="n">CFAbsoluteTimeGetCurrent</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;end:%lf, start:%lf, diff:%lf&quot;</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">arr</span> <span class="k">release</span><span class="p">];</span> <span class="c1">// -&gt; 这一行是「MRC」需要加上的，但「ARC」沒有这行</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果：</p>

<pre><code>MRC:  end:358178433.846184, start:358178433.753032, diff:0.093152
ARC:    end:358178929.480108, start:358178928.841418, diff:0.638690
</code></pre>

<p>可以看出「MRC」的版本比「ARC」的版本快了近7倍！</p>

<p>但实际上程序是慢在哪呢？ &ndash;> 慢在 obj = [arr objectAtIndex:n &ndash; 1]; 这个地方， XCode 在 Compile 的时候，帮我們加上了类似下面的代码，</p>

<pre><code>obj = [[arr objectAtIndex:n - 1] retain];
[obj autorelease];
</code></pre>

<p>如果把「MRC」的版本修改为上述的代码，
则执行結果：</p>

<pre><code>MRC:  end:358179022.496308, start:358179021.894909, diff:0.601399
</code></pre>

<p>是不是就变慢了！
因此，XCode 在 Compile 的时候，我想它对代码的记忆管理是采取较保守的态度， 如此看來，iOS 5 预设 property 为 strong 也就不意外了！</p>

<p>那么上面所举的例子要怎么解決呢？ &ndash;> 我们可以透过 Toll-Free Bridged Types 来解決！ 来看一下，我们将 ARC 的版本的代码改成下面这个样子： 將NSArray改成使用CFArrayRef， 这是 Foundation class &ndash;> Core Foundation type 的转换， 这样的转换是 Toll-Free 的！</p>

<pre><code>__unsafe_unretained id obj;
for (int j = 0; j &lt; m; j++){
  obj = (__bridge __unsafe_unretained id)CFArrayGetValueAtIndex((__bridge CFArrayRef)arr, n - 1);
}
</code></pre>

<p>如果把「ARC」的版本修改为上述的代码，
则执行结果：</p>

<pre><code>MRC:  end:358179460.237259, start:358179460.004701, diff:0.232558
</code></pre>

<p>是不是就变快了！(但还沒有办法跟原本的「MRC」版本一样快！)
所以其实写程序的時候要多想一下有沒有其它作法， 因为不同的写法虽然可能是相同結果， 但所需要的时间是不同的， 在使用 ARC 時， 如果能清楚的知道自己所创建的物件是被 retain 的状态， 那么在传递的过程中就可以视需求决定接收此物件是要 retain 或只是 assign， 这样可以让 XCode 在 Compile 的时候， 依照我们給它的指示去产生记忆体管理的代码， 避免不必要或多余的效能损失！</p>

<h4>5、 CF与Objective-C在ARC下的内存管理</h4>

<p>在cocoa application的应用中，我们有时会使用Core Foundation(CF),我们经常会在Objective-C和CF之间进行转化。系统使用arc的状态下，编译器不能自动管理CF的内存，这时候你必须使用CFRetain和CFRelease来进行CF的内存的管理。</p>

<p>具体的CF内存管理规则见： Memory Management Programming Guide for Core Foundation</p>

<p>在OC和FC之间进行转化的时候，主要是对象的归属问题。共有两种方式：</p>

<p>1、使用宏，可以标识归属者从OC到CF，还是从CF到OC。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NS_INLINE</span> <span class="n">CFTypeRef</span> <span class="nf">CFBridgingRetain</span><span class="p">(</span><span class="kt">id</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">__bridge_retain</span> <span class="n">CFTypeRef</span><span class="p">)</span><span class="n">X</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NS_INLINE</span> <span class="kt">id</span> <span class="nf">CFBridgingRelease</span><span class="p">(</span><span class="n">CFTypeRef</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="kt">id</span><span class="p">)</span><span class="n">X</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
2、使用转化符,如：<code>__bridge</code>，<code>__bridge_transfer</code>，<code>__bridge_retained</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">my_id</span><span class="p">;</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">my_cfref</span><span class="p">;</span>
</span><span class='line'><span class="err">…</span>
</span><span class='line'><span class="bp">NSString</span>   <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">my_cfref</span><span class="p">;</span>     <span class="c1">// Noop cast. </span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">my_id</span><span class="p">;</span>      <span class="c1">// Noop cast. </span>
</span><span class='line'><span class="err">…</span>
</span><span class='line'><span class="bp">NSString</span>   <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">my_cfref</span><span class="p">;</span> <span class="c1">// -1 on the CFRef </span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">my_id</span><span class="p">;</span>  <span class="c1">// returned CFRef is +1</span>
</span></code></pre></td></tr></table></div></figure>


<p>
下面以详细的例子来介绍一下OC和CF在arc下内存管理的详细写法.下面以CFURLCreateStringByAddingPercentEscapes()函数为例说一下在ARC下的写法和非ARC下的写法。</p>

<p>非ARC模式下的写法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark – View lifecycle </span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">escape</span><span class="p">:</span><span class="s">@&quot;wangjun&quot;</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">));;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
使用instruments检测，没有内存泄漏。</p>

<p>下面把上面工程改为arc模式。</p>

<p>可以看到xcode自动把上面函数转化为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark – View lifecycle </span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">escape</span><span class="p">:</span><span class="s">@&quot;wangjun&quot;</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在arc中，CF和OC之间的转化桥梁是 __bridge，有两种方式：</p>

<ul>
<li>__bridge_transfer  ARC接管管理内存</li>
<li>__bridge_retained  ARC释放内存管理</li>
</ul>


<p>上面的方法是从CF转化为OC NSString对象，使用的__bridge_transfer ，对象所有者发生转变，由CF到OC，最后由ARC接管内存管理。运行上面的代码，用instruments检测，是没有内存泄漏的。</p>

<p>上面代码等同于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">)));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果将上述代码改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">__bridge</span> <span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">));;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
编译也会成功，但是这时候用instruments检测，可以发现内存泄漏：</p>

<p>由于CF转化完OC，没有自己释放内存，同时也没有把内存管理交给ARC，所以出现内存泄漏。由于__bridge只是同一个对象的引用，内存的所有权没有发生变化。</p>

<p>下面在说一下oc到CF的转化，需要把OC的内存管理权释放掉。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">s1</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&quot;Hello, %@!&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">s1</span><span class="p">;</span>
</span><span class='line'><span class="c1">// do something with s2 // . . . </span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>
最后由CF进行内存释放。</p>

<p>上面代码等同于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">CFBridgingRetain</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
</span><span class='line'><span class="c1">// . . . </span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>
下面总结一下我们使用ARC情况下。oc和CF互相转化的原则：</p>

<ul>
<li>CF转化为OC时，并且对象的所有者发生改变，则使用<code>CFBridgingRelease()</code>或<code>__bridge_transfer</code> 。</li>
<li>OC转化为CF时，并且对象的所有者发生改变，则使用<code>CFBridgingRetain()</code>或<code>__bridge_retained</code></li>
</ul>


<p>当一个类型转化到另一种类型时，但是对象所有者没有发生改变，则使用__bridge.</p>

<h4>6、 使用ARC注意事项</h4>

<ul>
<li>属性命名不能用new开头</li>
<li>不再使用<code>retain</code>， <code>relase</code>， <code>autorelease</code>。</li>
<li><p>对<code>strong</code>,<code>weak</code>,<code>assign</code>,<code>copy</code>,<code>__weak</code>，<code>__strong</code>，<code>__autorelease</code>，<code>@autorelease{}</code>等的使用需要学习一下（特别注意一下<code>__weak</code>, <code>__strong</code>, <code>__autorelease</code>应该写在指针后边，变量名前面，否则不是正确写法，只是编译器会做一些处理）。</p></li>
<li><p>重写dealloc方法不调用[super dealloc]方法。</p></li>
<li><p>第三方库不支持arc，要將每个相关文件设置-fno-objc-arc。</p></li>
<li><p>arc对core foundation无效，需要自己控制内存，包括释放，并且需要cast的时候要用 <code>__bridge</code>，<code>__bridge_retain</code>，<code>__bridge_transfer</code>等修饰来控制对应内存。</p></li>
<li><p>arc和block的时候需要注意循环引用的问题。</p></li>
<li><p>还有和C混用的时候需要注意，先將对象赋nil再free掉相关内存。避免使用 C 的 memcpy 和 realloc 函数等等。</p></li>
<li>在dealloc中把成员变量置nil</li>
</ul>


<h4>7、 总结</h4>

<p>ARC相对于MRC时弱引用时运行效率确实会慢一些，但他在<code>[[[XXX alloc] init] autorelease]</code>时ARC不但可以简化其写法，还可以让它更快的处理，减少不必要的入池操作，而且他的优势也是十分明显的。ARC只是为了提高您的工作效率，而不是一个神奇而没有缺点的一项技术。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSObjective-C之id/NSObject/id&lt;NSObject>区别]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/16/ios-nsobject-id-difference/"/>
    <updated>2014-02-16T16:23:26+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/16/ios-nsobject-id-difference</id>
    <content type="html"><![CDATA[<h3>概述</h3>

<p>我们在iOS开发过程中，经常会碰到id、NSObject、id&lt; NSObject>，但我们也经常会混淆这三种申明（我之前也不是很留意这个），现在Abel带你一起去看看他们的真实面目。</p>

<!--more-->


<h3>目录</h3>

<ul>
<li>1、 id</li>
<li>2、 NSObject *</li>
<li>3、 id&lt;NSObject></li>
<li>4、 如何选择你要用的类型</li>
<li>5、 补充说明</li>
</ul>


<h4>1、 id</h4>

<p>第一种是最常用的，它简单地申明了指向对象的指针，没有给编译器任何类型信息，因此，编译器不会做类型检查。但也因为是这样，你可以发送任何信息给id类型的对象。这就是为什么+alloc返回id类型，但调用[[Foo alloc] init]不会产生编译错误。</p>

<p>因此，id类型是运行时的动态类型，编译器无法知道它的真实类型，即使你发送一个id类型没有的方法，也不会产生编译警告。</p>

<h4>2、 NSObject *</h4>

<p>我们知道，id类型是一个Objective-C对象，但并不是都指向继承自NSOjbect的对象，即使这个类型和NSObject对象有很多共同的方法，像retain和release。要让编译器知道这个类继承自NSObject，一种解决办法就是像第2种那样，使用NSObject静态类型，当你发送NSObject没有的方法，像length或者count时，编译器就会给出警告。这也意味着，你可以安全地使用像retain，release，description这些方法。</p>

<p>因此，申明一个通用的NSObject对象指针和你在其它语言里做的类似，像java，但其它语言有一定的限制，没有像Objective-C这样灵活。并不是所有的Foundation/Cocoa对象都继承息NSObject，比如NSProxy就不从NSObject继承，所以你无法使用NSObject＊指向这个对象，即使NSProxy对象有release和retain这样的通用方法。为了解决这个问题，这时候，你就需要一个指向拥有NSObject方法对象的指针，这就是第3种申明的使用情景。</p>

<h4>3、 id&lt;NSObject></h4>

<p>id&lt;NSObject>告诉编译器，你不关心对象是什么类型，但它必须遵守NSObject协议(protocol)，编译器就能保证所有赋值给id&lt;NSObject>类型的对象都遵守NSObject协议(protocol)。这样的指针可以指向任何NSObject对象，因为NSObject对象遵守NSObject协议(protocol)，而且，它也可以用来保存NSProxy对象，因为它也遵守NSObject协议(protocol)。这是非常强大，方便且灵活，你不用关心对象是什么类型，而只关心它实现了哪些方法。</p>

<h4>4、 如何选择你要用的类型</h4>

<p>如果你不需要任何的类型检查，使用id，它经常作为返回类型，也经常用于申明代理(delegate)类型。因为代理类型通常在运行时，才会检查是否实现了那些方法。</p>

<p>如果真的需要编译器检查，那你就考虑使用第2种或者第3种。很少看到NSObject＊能正常运行，但id&lt;NSObject>无法正常运行的。使用协议(protocol)的优点是，它能指向NSProxy对象，而更常用的情况是，你只想知道某个对象遵守了哪个协议，而不用关心它是什么类型。</p>

<h4>5、补充说明</h4>

<ul>
<li>id 还可以表示基础类型，但是不能表示float，double类型</li>
<li>NSObject *foo2; 如果使用这种形式，用到的时候需要强制类型转换，可能会很麻烦</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective C之Block教程]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/15/ios-block/"/>
    <updated>2014-02-15T21:06:42+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/15/ios-block</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>Block是C级别的语法和运行时特性。Block比较类似C函数，但是Block比之C函数，其灵活性体现在栈内存、堆内存的引用，我们甚至可以将一个Block作为参数传给其他的函数或者Block。</p>

<!--more-->


<h3>目录</h3>

<ul>
<li>一、Block的基本介绍

<ul>
<li>1、什么是Block</li>
<li>2、Block和C语言函数指针和什么区别</li>
<li>3、如何调用Block</li>
</ul>
</li>
<li>二、Block内存管理与其他特性

<ul>
<li>1、Block放在哪里</li>
<li>2、Block引用的变量在哪里</li>
</ul>
</li>
<li>三、Block揭开神秘面纱</li>
</ul>


<h4>一、Block的基本介绍</h4>

<h5>1、什么是Block</h5>

<p>Block是一个C Level的语法以及运行时的一个特性，和标准C中的函数（函数指针）类似，但是其运行需要编译器和运行时支持，从iOS4.0开始就很好的支持Block了。广泛用于两个对象之前的回调函数。</p>

<p>下面我们来看一下Block的声明：</p>

<pre><code>int(^hbFunction) (BOOL a);
</code></pre>

<p>其中int为block的返回类型，hbFunction为block名称，a为参数。</p>

<h5>2、Block和C语言函数指针和什么区别</h5>

<p>首先我们来看看C函数指针：</p>

<pre><code>int (* hbFunction) (int a);  // 函数声明
int resut = hbFunction(10);  // 函数调用
</code></pre>

<p>再看看Block的用法：</p>

<pre><code>int (^ hbFunction) (int a);  // 函数声明
int resut = hbFunction(10);   // 函数调用
</code></pre>

<p>C语言函数指针typedef</p>

<pre><code>typedef int (*SumFunction)(int a,int b);
</code></pre>

<p>Block中的typedef</p>

<pre><code>typedef int (^SumBlock)(int a,int b);   
</code></pre>

<h5>3、如何调用Blocks</h5>

<p>主动调用一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">someMethod</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">BoolBlock</span> <span class="n">ablock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Bool block!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ablock</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>作为参数返回：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">BoolBlock</span><span class="p">)(</span><span class="kt">BOOL</span><span class="p">);</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">BoolBlock</span><span class="p">)</span><span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">BoolBlock</span> <span class="n">ablock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Bool block!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[[</span><span class="n">ablock</span> <span class="k">copy</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span><span class="c1">//一定要copy，将其复制到堆上，更详细的原理，将在后续章节讲解</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类的一个成员：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">OBJ1</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span><span class="n">BoolBlock</span> <span class="n">block</span><span class="p">;</span><span class="c1">//理由同上啊，同学们</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">OBJ1</span> <span class="o">*</span><span class="n">obj1</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="n">obj1</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Bool block!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
其他函数的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo</span><span class="p">(</span><span class="n">BoolBlock</span> <span class="n">block</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">block</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
甚至其他block的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">BoolBlock</span> <span class="n">bBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bV</span><span class="p">){</span><span class="k">if</span><span class="p">(</span><span class="n">Bv</span><span class="p">){</span><span class="cm">/*do some thing*/</span><span class="p">}};</span>
</span><span class='line'><span class="n">HugeBlock</span> <span class="n">hBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">BoolBlock</span> <span class="n">bB</span><span class="p">)</span> <span class="p">{</span><span class="n">bB</span><span class="p">();};</span>
</span><span class='line'>
</span><span class='line'><span class="n">hBolck</span><span class="p">(</span><span class="n">bBlock</span><span class="p">);</span>   
</span></code></pre></td></tr></table></div></figure>


<h4>二、Block内存管理与其他特性</h4>

<h5>1、Block放在哪里</h5>

<h6>1.1栈和堆</h6>

<p>以下情况中的block位于堆中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blkInHeap</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);};</span><span class="c1">//blk在栈里</span>
</span><span class='line'>  <span class="n">blkInHeap</span> <span class="o">=</span> <span class="n">Block_copy</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span><span class="c1">//blkInHeap在堆里</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fooBar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">_oi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">OBJ1</span><span class="o">*</span> <span class="n">oj</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">oblk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oj</span><span class="p">.</span><span class="n">oi</span><span class="p">);};</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">oblkInHeap</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">oblk</span> <span class="k">copy</span><span class="p">];</span><span class="c1">//oblkInHeap在堆中</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h6>1.2全局</h6>

<p>以下情况中的block位于全局区：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="nf">int</span><span class="p">(</span><span class="o">^</span><span class="n">maxIntBlock</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="o">?</span><span class="nl">a</span><span class="p">:</span><span class="n">b</span><span class="p">;};</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fooBar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">maxIntBlockCopied</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span><span class="p">[</span><span class="n">maxIntBlock</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">maxIntBlockCopied</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">Block_copy</span><span class="p">(</span><span class="n">maxIntBlock</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，这里复制过后的block依旧位于全局区，实际上，复制操作是直接返回了原block对象。</p>

<h5>2、Block引用的变量在哪里</h5>

<h5>1.全局区</h5>

<p>全局区的变量存储位置与block无关：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">gVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="c1">//__block static int gMVar = 1;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">stackVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="c1">//    __block static int stackMVar = 0;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
注意，static变量是不允许添加__block标记的</p>

<h5>2.堆栈</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="c1">// 此时i在栈上</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 此时j在栈上</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d,  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>   <span class="c1">//此时blk位于栈上，其使用的变量也在栈上</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">blk</span><span class="p">();</span>
</span><span class='line'>  <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blkInHeap</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">Block_copy</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 复制block后，block位于堆上，有__block标记的i会被复制一份至堆，而没有__block标记的j并不会动依旧位于栈上。</span>
</span><span class='line'>  
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>三、Block揭开神秘面纱</h4>

<h5>1、Block到底是什么</h5>

<p>我们使用clang的rewrite-objc命令来获取转码后的代码。</p>

<p>我们来看看最简单的一个block：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i :%d,j:%d,&amp;i:%p,&amp;j:%p&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个block仅仅打印栈变量i和j的值，其被clang转码为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span><span class="kt">int</span> <span class="n">_j</span><span class="p">,</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">_i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">_j</span><span class="p">),</span><span class="kt">int</span><span class="p">(</span><span class="n">_i</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">){</span>
</span><span class='line'>         <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>         <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>         <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>         <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">){</span>
</span><span class='line'>   <span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">j</span><span class="p">;</span>
</span><span class='line'>   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i :%d,j:%d,&amp;i:%p,&amp;j:%p&quot;</span><span class="p">,</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">),</span><span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">src</span><span class="p">){</span>
</span><span class='line'>   <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">src</span><span class="p">){</span>
</span><span class='line'>   <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="p">{</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">),</span><span class="n">__main_block_copy_0</span><span class="p">,</span><span class="n">__main_block_dispose_0</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_i_0</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_i_0</span><span class="p">),</span><span class="mi">1024</span><span class="p">};</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">blk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span> <span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span><span class="n">j</span><span class="p">,(</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="mi">570425344</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>首先是一个结构体<code>__main_block_impl_0</code>（从图二中的最后一行可以看到，block是一个指向<code>__main_block_impl_0</code>的指针，初始化后被类型强转为函数指针），其中包含的<code>__block_impl</code>是一个公共实现（学过c语言的同学都知道，<code>__main_block_impl_0</code>的这种写法表示其可以被类型强转为<code>__block_impl</code>类型）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>          <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>          <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>
 isa指针说明block可以成为一个objc 对象。</p>

<pre><code>__main_block_impl_0的意思是main函数中的第0个block的implementation，这就是这个block的主体了。
</code></pre>

<p>这个结构体的构造函数的参数：</p>

<ul>
<li><p>1、block实际执行代码所在的函数的指针，当block真正被执行时，实际上是调用了这个函数，其命名也是类似的方式。</p></li>
<li><p>2、block的描述结构体，注意这个结构体声明结束时就创建了一个唯一的desc，这个desc包含了block的大小，以及复制和析构block时需要额外调用的函数。</p></li>
<li><p>3、接下来是block所引用到的变量们</p></li>
<li><p>4、最后是一个标记值，内部实现需要用到的。（我用计算器看了一下，570425344这个值等于1&lt;&lt;29，即BLOCK_HAS_DESCRIPTOR这个枚举值）</p></li>
</ul>


<p>所以，我们可以看到：</p>

<ul>
<li>1、为什么上一篇我们说j已经不是原来的j了，因为j是作为参数传入了block的构造函数，进行了值复制。</li>
<li>2、带有__block标记的变量会被取地址来传入构造函数，为修改其值奠定了基础</li>
</ul>


<p>接下来是block执行函数<code>__main_block_func_0</code>:</p>

<p>其唯一的参数是<code>__main_block_impl_0</code>的指针，我们看到printf语句的数据来源都取自<code>__cself</code>这个指针，比较有意思的是i的取值方式（带有<code>__block</code>标记的变量i被转码为一个结构体），先取<code>__forward</code>指针，再取i，这为将i复制到堆中奠定了基础。</p>

<p>再下来是预定义好的两个复制/释放辅助函数，其作用后面会讲到。</p>

<p>最后是block的描述信息结构体 <code>__main_block_desc_0</code>，其包含block的内存占用长度，已经复制/释放辅助函数的指针，其声明结束时，就创建了一个名为<code>__main_block_desc_0_DATA</code>的结构体，我们看它构造时传入的值，这个DATA结构体的作用就一目了然了：</p>

<p>长度用sizeof计算，辅助函数的指针分别为上面预定义的两个辅助函数。</p>

<pre><code>注意，如果这个block没有使用到需要在block复制时进行copy/retian的变量，那么desc中不会有辅助函数
</code></pre>

<p>至此，一个block所有的部件我们都看齐全了，一个主体，一个真正的执行代码函数，一个描述信息(可能包含两个辅助函数)。</p>

<h5>2、构造一个block</h5>

<p>我们进入main函数：</p>

<p>图一中的第三行（block的声明），在图二中，转化为一个函数指针的声明，并且都没有被赋予初始值。
而图一中的最后一行（创建一个block），在图二中，成为了对<code>__main_block_impl_0</code>的构造函数的调用，传入的参数的意义上面我们已经讲过了。</p>

<p>所以构造一个block就是创建了<code>__main_block_impl_0</code> 这个c++类的实例。</p>

<h5>3、调用一个block</h5>

<p>调用一个block的写法很简单，与调用c语言函数的语法一样：</p>

<pre><code>blk();
</code></pre>

<p>其转码后的语句：</p>

<pre><code>((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
</code></pre>

<p>将blk这个函数指针类型强转为<strong>block_impl类型，然后取其执行函数指针，然后将此指针类型强转为返回void*并接收一个</strong>block_impl<em>的函数指针，最后调用这个函数，传入强转为__block_impl</em>类型的blk，</p>

<p>即调用了前述的函数__main_block_func_0</p>

<h5>4、objective-c类成员函数中的block</h5>

<p>源码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">of1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">OBJ1</span><span class="o">*</span> <span class="n">oj</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">oblk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oj</span><span class="p">.</span><span class="n">oi</span><span class="p">);};</span>
</span><span class='line'>  <span class="n">Block_copy</span><span class="p">(</span><span class="n">oblk</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这里我故意将self赋值给oj这个变量，是为了验证前一章提出的一个结论：无法通过简单的间接引用self来防止retain循环，要避免循环，我们需要__block标记（多谢楼下网友的提醒）
转码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__OBJ1__of1_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__OBJ1__of1_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>          <span class="n">OBJ1</span> <span class="o">*</span><span class="n">oj</span><span class="p">;</span>
</span><span class='line'>          <span class="n">__OBJ1__of1_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__OBJ1__of1_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">OBJ1</span> <span class="o">*</span><span class="n">_oj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">oj</span><span class="p">(</span><span class="n">_oj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>  <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>  <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__OBJ1__of1_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__OBJ1__of1_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">OBJ1</span> <span class="o">*</span><span class="n">oj</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">oj</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">((</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">oj</span><span class="p">,</span>         <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;oi&quot;</span><span class="p">)));</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
objc方法中的block与c中的block并无太多差别，只是一些标记值可能不同，为了标记其是objc方法中的blcok。</p>

<p>注意其构造函数的参数:OBJ1 *_oj</p>

<p>这个<em>oj在block复制到heap时，会被retain，而</em>oj与self根本就是相等的，所以，最终retain的就是self，所以如果当前实例持有了这个block，retain循环就形成了。</p>

<p>而一旦为其增加了__block标记：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">of1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">__block</span> <span class="n">OBJ1</span> <span class="o">*</span><span class="n">bSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">bSelf</span><span class="p">.</span><span class="n">oi</span><span class="p">);</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
其转码则变为：</p>

<p>//增加了如下行</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_bSelf_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_bSelf_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="n">OBJ1</span> <span class="o">*</span><span class="n">bSelf</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_copy_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">40</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_dispose_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_dispose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<pre><code>//声明处变为
__block __Block_byref_bSelf_0 bSelf = {(void*)0,(__Block_byref_bSelf_0 *)&amp;bSelf, 33554432, sizeof(__Block_byref_bSelf_0),   __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, self};
</code></pre>

<p>clang为我们的bSelf结构体创建了自己的copy/dispose辅助函数，33554432（即1&lt;&lt;25 BLOCK_HAS_COPY_DISPOSE）这个值告诉系统，我们的bSelf结构体具有copy/dispose辅助函数。</p>

<p>而131这个参数（二进制1000 0011，即BLOCK_FIELD_IS_OBJECT (3) |BLOCK_BYREF_CALLER（128））
中的BLOCK_BYREF_CALLER在内部实现中告诉系统不要进行retain或者copy，
也就是说，在 __block bSelf 被复制至heap上时，系统会发现有辅助函数，而辅助函数调用后，并不retain或者copy 其结构体内的bSelf。
这样就避免了循环retain。</p>

<h4>2、内存管理的真面目</h4>

<p>objc层面如何区分不同内存区的block</p>

<p>Block_private.h中有这样一组值：</p>

<pre><code>/* the raw data space for runtime classes for blocks */
/* class+meta used for stack, malloc, and collectable based blocks */
BLOCK_EXPORT void * _NSConcreteStackBlock[32];
BLOCK_EXPORT void * _NSConcreteMallocBlock[32];
BLOCK_EXPORT void * _NSConcreteAutoBlock[32];
BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32];
BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];
BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32];
</code></pre>

<p>其用于对block的isa指针赋值
1.栈</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__OBJ1__of2_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__OBJ1__of2_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>          <span class="n">OBJ1</span> <span class="o">*</span><span class="nb">self</span><span class="p">;</span>
</span><span class='line'>          <span class="n">__OBJ1__of2_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__OBJ1__of2_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">OBJ1</span> <span class="o">*</span><span class="n">_self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="nb">self</span><span class="p">(</span><span class="n">_self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>      <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>      <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>      <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在栈上创建的block，其isa指针是_NSConcreteStackBlock。</p>

<h5>2.全局区</h5>

<p>在全局区创建的block，其比较类似，其构造函数会将isa指针赋值为_NSConcreteGlobalBlock。</p>

<h5>3.堆</h5>

<p>我们无法直接创建堆上的block，堆上的block需要从stack block拷贝得来，在runtime.c中的_Block_copy_internal函数中，有这样几行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Its a stack block.  Make a copy.</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isGC</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">_NSConcreteMallocBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
可以看到，栈block复制得来的新block，其isa指针会被赋值为_NSConcreteMallocBlock</p>

<h5>4.其余的isa类型</h5>

<pre><code>BLOCK_EXPORT void * _NSConcreteAutoBlock[32];
BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32];
BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32];
</code></pre>

<p>其他三种类型是用于gc和arc，我们暂不讨论</p>

<p>复制block</p>

<p> 对block调用Block_copy方法，或者向其发送objc copy消息，最终都会调用runtime.c中的<code>_Block_copy_internal</code>函数，其内部实现会检查block的flag，从而进行不同的操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_Block_copy_internal</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">aBlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>1.栈block的复制</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="c1">// reset refcount</span>
</span><span class='line'> <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">);</span>    <span class="c1">// XXX not needed</span>
</span><span class='line'> <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BLOCK_NEEDS_FREE</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'> <span class="n">result</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">_NSConcreteMallocBlock</span><span class="p">;</span>
</span><span class='line'> <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_HAS_COPY_DISPOSE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="c1">//printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span>
</span><span class='line'>     <span class="p">(</span><span class="o">*</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="k">copy</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">);</span> <span class="c1">// do fixup</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了修改isa指针的值之外，拷贝过程中，还会将BLOCK_NEEDS_FREE置入，大家记住这个值，后面会用到。
最后，如果block有辅助copy/dispose函数，那么辅助的copy函数会被调用。</p>

<p>2.全局block的复制</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_IS_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
全局block进行copy是直接返回了原block，没有任何的其他操作。</p>

<p>3.堆block的复制</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// latches on high</span>
</span><span class='line'>    <span class="n">latching_incr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
栈block复制时，置入的BLOCK_NEEDS_FREE标记此时起作用，_Block_copy_internal函数识别当前block是一个堆block，则仅仅增加引用计数，然后返回原block。</p>

<p>辅助copy/dispose函数</p>

<p>1.普通变量的复制
辅助copy函数用于拷贝block所引用的可修改变量，我们这里以 __block int i = 1024为例：
先看看Block_private.h中的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Block_byref</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">forwarding</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* refcount; */</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">byref_keep</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">byref_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="cm">/* long shared[0]; */</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>
而我们的__block int i = 1024的转码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_i_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span><span class="c1">//所以我们知道，当此结构体被类型强转为Block_byref时，前四个成员是一致的，访问flags就相当于访问__flags，而内部实现就是这样使用的</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_i_0</span> <span class="n">i</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span>    <span class="p">(</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_i_0</span><span class="p">),</span> <span class="mi">1024</span><span class="p">};</span><span class="c1">//i初始化时__flags为0</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span>    <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时，复制时调用的辅助函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span><span class="c1">//此处flags为8，即BLOCK_FIELD_IS_BYREF</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>      <span class="c1">// copying a __block reference from the stack Block to the heap</span>
</span><span class='line'>      <span class="c1">// flags will indicate if it holds a __weak reference and needs a special isa</span>
</span><span class='line'>          <span class="n">_Block_byref_assign_copy</span><span class="p">(</span><span class="n">destAddr</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_Block_byref_assign_copy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span><span class="c1">//此处flags为8，即BLOCK_FIELD_IS_BYREF</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="n">destp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">//当初次拷贝i时，flags为0，进入此分支会进行复制操作并改变flags值，置入BLOCK_NEEDS_FREE和初始的引用计数</span>
</span><span class='line'>   <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// already copied to heap</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span><span class="c1">//当再次拷贝i时，则仅仅增加其引用计数</span>
</span><span class='line'>      <span class="n">latching_incr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// assign byref data block pointer into new Block</span>
</span><span class='line'>  <span class="n">_Block_assign</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">destp</span><span class="p">);</span><span class="c1">//这句仅仅是直接赋值，其函数实现只有一行赋值语句，查阅runtime.c可知</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
所以，我们知道，当我们多次copy一个block时，其引用的__block变量只会被拷贝一次。</p>

<p>2.objc变量的复制</p>

<p>当objc变量没有__block修饰时：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__OBJ1__of2_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__OBJ1__of2_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__OBJ1__of2_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//printf(&quot;retaining object at %p\n&quot;, object);</span>
</span><span class='line'>      <span class="n">_Block_retain_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span><span class="c1">//当我们没有开启arc时，这个函数会retian此object</span>
</span><span class='line'>      <span class="c1">//printf(&quot;done retaining object at %p\n&quot;, object);</span>
</span><span class='line'>      <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="p">....</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
当objc变量有__block修饰时：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_bSelf_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_bSelf_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="n">OBJ1</span> <span class="o">*</span><span class="n">bSelf</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_copy_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">40</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span><span class="c1">//131即为BLOCK_FIELD_IS_OBJECT|BLOCK_BYREF_CALLER</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_dispose_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_dispose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span> <span class="c1">//33554432即为BLOCK_HAS_COPY_DISPOSE</span>
</span><span class='line'>
</span><span class='line'><span class="k">__block</span> <span class="n">__Block_byref_bSelf_0</span> <span class="n">bSelf</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_bSelf_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bSelf</span><span class="p">,</span> <span class="mi">33554432</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_bSelf_0</span><span class="p">),</span> <span class="n">__Block_byref_id_object_copy_131</span><span class="p">,</span> <span class="n">__Block_byref_id_object_dispose_131</span><span class="p">,</span> <span class="nb">self</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>BLOCK_HAS_COPY_DISPOSE告诉内部实现，这个变量结构体具有自己的copy/dispose辅助函数，而此时我们的内部实现不会进行默认的复制操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//printf(&quot;_Block_object_assign(*%p, %p, %x)\n&quot;, destAddr, object, flags);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">_Block_assign_weak</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// do *not* retain or *copy* __block variables whatever they are</span>
</span><span class='line'>        <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
当我们没有开启arc，且flags中具有BLOCK_BYREF_CALLER时，会进入_Block_assign函数，而此函数仅仅是赋值
所以，如果要避免objc实例中的block引起的循环引用，我们需要让block间接使用self：</p>

<pre><code>__block bSelf = self;
</code></pre>

<p>其他</p>

<p>对于dipose辅助函数，其行为与copy是类似的，我们不再重复同样的东西，如果大家要了解，自行查阅runtime.c和Block_private.h即可。</p>

<p>我们已经理解了非arc非gc情况下的block的内存管理内部实现，对arc和gc的情况，其行为也是类似的，只是一些函数的指针指向的真正函数会改变，比如_Block_use_GC函数，会将一些函数指向其他的实现，使其适用于gc开启的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS安全攻防（一）：Hack必备的命令与工具]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/11/iossafety-hacktools/"/>
    <updated>2014-02-11T23:32:27+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/11/iossafety-hacktools</id>
    <content type="html"><![CDATA[<h3>Hack必备的命令与工具</h3>

<p>你的应用正在被其他对手反向工程、跟踪和操作！你的应用是否依旧裸奔豪不防御？
郑重声明一下，懂得如何攻击才会懂得如何防御，一切都是为了之后的防御作准备。废话少说，进入正题。
今天总结一下为hack而做的准备工作。</p>

<!--more-->


<h3>常用的命令和工具</h3>

<pre><code>ps           ——显示进程状态，CPU使用率，内存使用情况等
sysctl       ——检查设定Kernel配置
netstat      ——显示网络连接，路由表，接口状态等
route        ——路由修改
renice       ——调整程序运行的优先级
ifconfig     ——查看网络配置
tcpdump      ——截获分析网络数据包
lsof         ——列出当前系统打开的文件列表，别忘记一切皆文件，包括网络连接、硬件等
otool ①     ——查看程序依赖哪些动态库信息，反编代码段……等等等等
nm ②        ——显示符号表
ldid ③      ——签名工具
gdb         ——调试工具
patch       ——补丁工具
SSH         ——远程控制
</code></pre>

<p>备注：</p>

<p>① otool，可查看可执行程序都链接了那些库：</p>

<pre><code>   otool  -L WQAlbum 
</code></pre>

<p>可以得到：</p>

<pre><code>WQAlbum:
    /System/Library/Frameworks/StoreKit.framework/StoreKit (compatibility version 1.0.0, current version 1.0.0)
    /System/Library/Frameworks/AdSupport.framework/AdSupport (compatibility version 1.0.0, current version 1.0.0)
    /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.5)
    /System/Library/Frameworks//MediaPlayer.framework/MediaPlayer (compatibility version 1.0.0, current version 1.0.0)
    /System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices (compatibility version 1.0.0, current version 40.0.0)
    /System/Library/Frameworks/CoreMedia.framework/CoreMedia (compatibility version 1.0.0, current version 1.0.0)
    ……
</code></pre>

<p>可以反编译WQAlbum的<strong>TEXT</strong>段内容, 截前10行：</p>

<pre><code>otool -tV WQAlbum |head -n 10 
</code></pre>

<p>可以得到：</p>

<pre><code>WQAlbum:
(__TEXT,__text) section
start:
00002de0    pushl   $0x00
00002de2    movl    %esp,%ebp
00002de4    andl    $0xf0,%esp
00002de7    subl    $0x10,%esp
00002dea    movl    0x04(%ebp),%ebx
……
</code></pre>

<p>② nm，显示程序符号表，用我自己的应用程序私人相册现身说法一下：
nm -g WQAlbum  （ -g 代表 global）</p>

<p>可以得到：</p>

<pre><code>001e5eec S _OBJC_IVAR_$_WQPhotoViewController.albumObject
001e5efc S _OBJC_IVAR_$_WQPhotoViewController.int_current
001e5f00 S _OBJC_IVAR_$_WQPhotoViewController.int_total
</code></pre>

<p>其中，WQPhotoViewController为类名，albumObject为该类的成员</p>

<p>③ ldid，是iPhoneOS.platform提供的签名工具，我们自己编译的程序需要签上名才能跑在iPhone/iPad上，使用方法</p>

<pre><code>export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/codesign_allocate
ldid -S helloworld 
</code></pre>

<p>编译Hello world</p>

<h4>1.首先找到编译器：</h4>

<p>arm-apple-darwin10-llvm-gcc-4.2 就是了。
为了方便起见，可以在.bashrc或者profile 配置下环境变量，方便编译。</p>

<h4>2.找到SDK</h4>

<p>编译我们自己的程序的时候需要指定该目录下的SDK。</p>

<h4>3.来个经典Hello world ：</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;stdio.h&gt;                                                                                             </span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span><span class='line'>   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello world !!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>4.编译</h4>

<p>其中 -isysroot用来指定build时的SDK</p>

<h4>5.校验</h4>

<p>file查看一下类型，没问题。</p>

<h4>6.SCP给iPhone、iPad</h4>

<p>前提是，设备已经越狱并且安装了SSH,且必须在同一网段。</p>

<pre><code>$scp helloworld root@x.x.x.x:hello world
</code></pre>

<h4>7.登录设备签名</h4>

<pre><code>$ssh -l root x.x.x.x
#ldid -S helloworld
</code></pre>

<h4>8.执行程序</h4>

<pre><code>#./helloworld
Hello world !!!
</code></pre>

<p>运行成功，这就完成了最简单的手动执行自己的应用程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABELWebImageKit使用介绍]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/10/abelwebimagekit/"/>
    <updated>2014-02-10T20:30:17+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/10/abelwebimagekit</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>ABELWebImageKit托管在github上：<a href="https://github.com/beyondabel/ABELWebImage">https://github.com/beyondabel/ABELWebImage</a></p>

<!--more-->


<h3>目录</h3>

<pre><code>1、ABELWebImageKit介绍
2、ABELWebImageKit库结构的简单分析
3、ABELWebImageKit库的图片管理
4、ABELWebImageKit库使用的简单举例
</code></pre>

<h3>1、ABELWebImageKit介绍</h3>

<p>这个库提供一个ABELImageView类以支持加载来自网络的远程图片。具有缓存管理、异步下载、同一个URL下载次数控制和优化等特征。将ABELWebImageKit类库添加入工程时，一定注意需要添加ImageIO.framework。UIImage+Tools依赖这个framework。</p>

<h3>2、ABELWebImageKit库结构的简单分析</h3>

<p>ABELImageView：ABELImageView继承于UIImageView的，它主要用于加载来自网络的远程图片。其中avater用于区别是否为头像图片（默认非头像）。</p>

<p>ABELWebImageCacheManager：ABELWebImageCacheManager是一个单例，对图片进行管理的中转站，读取图片（向下层读取Cache或者读取网络），实现ABELWebImageCache和ABELWebImageRequest的回调。</p>

<p>ABELWebImageCache：根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）     实现图片和内存清理工作。
ABELWebImageRequest：根据URL向网络读取数据</p>

<h3>3、ABELWebImageKit库的图片管理</h3>

<p>ABELWebImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。</p>

<p>内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。当ABELWebImageCacheManager向ABELWebImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。</p>

<h3>4、ABELWebImageKit库使用的简单举例</h3>

<pre><code>self.avatarImageView = [[ABELImageView alloc] init];
// 设置avatar为YES为显示圆形头像图片，否则为普通的图片
self.avatarImageView.avatar = YES;
self.avatarImageView.frame = CGRectMake(15, 10, 40, 40);
[self.avatarImageView setImageWithURL:[NSURL URLWithString:URLString]]
[self.contentView addSubview:self.avatarImageView];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISwitch详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/11/uiswitch/"/>
    <updated>2014-01-11T12:34:31+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/11/uiswitch</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>UISwitch继承于UIControl（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）,您可以使用UISwitch类来创建和管理使用开/关按钮。例如，在对选项，如飞行模式和蓝牙设置应用程序。这些对象被称为交换机。</p>

<!--more-->


<h3>目录</h3>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
</code></pre>

<h3>1、基本属性及方法</h3>

<p>// 开关是否打开</p>

<pre><code>BOOL on;
</code></pre>

<p>// 这个frame会被忽略，他会强制设置大小</p>

<pre><code>- (id)initWithFrame:(CGRect)frame;
</code></pre>

<p>// 打开/关闭调用函数(animated：是否使用动画)</p>

<pre><code>- (void)setOn:(BOOL)on animated:(BOOL)animated;
</code></pre>

<h3>2、iOS5新增</h3>

<p>// 开关打开时颜色</p>

<pre><code>UIColor *onTintColor;
</code></pre>

<h3>3、iOS6新增</h3>

<p>// 背影颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 开关的圆形滑钮的颜色</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 开关打开时自定义图片</p>

<pre><code>UIImage *onImage;
</code></pre>

<p>// 开关关闭时自定义图片</p>

<pre><code>UIImage *offImage;
</code></pre>
]]></content>
  </entry>
  
</feed>
