<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel之家]]></title>
  <link href="http://beyondabel.github.io/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2014-01-01T23:20:28+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[再见2013，展望2014]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/29/2013summarize/"/>
    <updated>2013-12-29T15:25:42+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/29/2013summarize</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/29/summarize.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>人生如一本书，应该多一些精彩的细节，少一些乏味的字眼;人生如一支歌，应该多一些昂扬的旋律，少一些忧伤的音符;人生如一幅画，应该多一些亮丽的色彩，少一些灰暗的色调。</p>

<!--more-->


<p>窗外的黑色已经降下，2013年的时间就只剩下几个小时了，能感觉到2014年已经在向我招手了。最近逛一些论坛和博客看了很多人都在总结自己的2013年，看着他们故事的同时也一直回顾着自己这一年的成长与经历，回顾自己这一年的成长与经历，不但只是为了回忆和纪念，更是对自己这一年荒废岁月、虚度年华的反省，让自己能更深刻地认清自己，及时调整自己已迷失的方向，坚定自己的目标。</p>

<p>今年2月份初的时候，当公司下班的钟声响起，每位同事都欢快地自己的行理箱赶火车，而我沮丧地背着我的mac pro回到住处去超市购物，走进超市，各样的中国结，包装精美的糖果、巧克力，耀眼醒目的春节装饰，喜庆的红色铺天盖地的印入眼帘，刺激着我每一根敏感脆弱的神经。我今年2月份没能回家过年,这是我将在外过的第一个年头,其实心情很复杂也很无奈!</p>

<p>也不知道那段时间自己怎么了，对于筷子兄弟的《父亲》特别地有感触，一遍又一遍听着，眼睛中情不自禁地泛着泪水，那时心里想着自己到时一定要买一把guitar去学习这首歌，然后弹给父母听（好吧，现在我还是没有钱买guitar，等办完这件事之后怎么也得买guitar），感觉这辈子欠父母的东西太多了。</p>

<p>虽然因为种种原因不能回家过年，有时候也在想自己也是幸福的，我的girl friend放弃了回家陪我一起在北京过新年。在一座陌生的城市里，有着另一个人的陪伴真的是很不容易，如果本身有年假还可以回家然后愿意留下来陪你一起在一个陌生的城市里过年更是不容易。过年时的北京真的很冷清，走在大街上你看不到什么人，过年的时候随便上一辆公交车，可能就那么一两个人，坐地铁你都可以包车间。北京冬天的空气真的很差很差，空气污染太严重了，以致于我没有兴趣出去玩。在初三的时间，我们终于去了一趟地坛看了年会。</p>

<p>春节收假之后回到公司感觉一切还是老样子，唯一感觉有区别的是手机端终于出来产品需求了，产品需求出来以后意味着公司终于有东西可做了，其实这个时候除了我的在公司的工作，还有另外一件事就是毕业的事情，因为我没有参加过论文的开题，也没有与指导老师说这事，虽然说自己的胆子有点大，但毕竟有关自己的毕业，所以也不敢太马虎，一个电话接一个电话去询问什么时候毕业答辩，最终得到确定的消息是在5月份中旬的时候，自己也开始写论文了，然后就形成在公司工作看书回家写论文这样的循环了，这样的生活持续了一个多月。</p>

<p>由于需要回学校参加毕业答辩，我向公司请了一个礼拜的假，提前也告诉了我的姐姐和父母，我打电话告诉她们希望她们到我学校来玩（姐姐和父母都没有进过大学，所以想让她们看大学来看看），一回到学校就是去系里“拜访”各位领导（没办法，谁叫我很多的东西没办好呢？），找指导老师修改论文，修改论文，吃饭，基本上就是这几件事，至于母亲和姐姐当时真的是完全顾不上了，我也就只好让她们自己到处去玩了（惭愧呀，不回家看父母，父母来学校看我了，都还没时间陪～）然后一日三餐我和家人一起去吃，毕业答辩的前一天，父母和姐姐都准备回家了，我把自己身上的剩下的二千多元都给了母亲（一万只剩下这么一点了，毕业答辩真是一个花钱的主呀），毕业答辩那天，我请了我们宿舍的和my girl friend宿舍的人吃饭，但由于后来我们宿舍的人差不多都有事，结果还得罪人（那段时间都是忙得晕头转向，没有考虑那么多，对我宿舍那几位兄弟说声非常抱歉），那天晚上，我们三个人在my girl friend宿舍的人的送别下踏上了回北京的火车（现在回想起来，我在大学真的很失败，玩的非常要好的真的可以用自己的手指可以数得出，真像他们所说的），心里五味杂粮。</p>

<p>回到北京最最开心的事莫过于，老大找我私聊说我涨工资了，虽然他一直在说我比他那会好很多，我自己也赞同他的说法，但我相信涨工资不管对于谁来说，都是一个非常好的一个消息，第一，是说明公司对你在这个岗位上的一个肯定，第二，可以使生活更加美好。这个时候产品也差不多要出第一版了，我们就开始修改之前出现的各种bug，但是过不久给了我一个晴天霹雳，之前做的要推倒重来，产品方向出现大范围调整，对于一个程序员来说，自己做的东西还没有到市场去评价的时候就得推到重来，那种心情我相信我们都会懂得。</p>

<p>产品的结构调整意味着我又没有什么活可干了，这个时候我在网站上发贴接收一些外包，然后一边看一些技术书，写一些第三方库。发一个外包贴子当时我自己也没有怎么注意，大概半个月之后有一个人加我QQ,问我有没有做过游戏，我然后跟他说解释说我现在做的是应用，游戏之前自己做过小demo。然后就是见面面谈，见面之后才知道他们是一个大学生创业团队（不过都是北京本地人，家里家境非常好的那种），想做一个游戏应用然后买给第三方去运营，他们都不懂技术，想找一个人一起创业，当时我觉得不靠谱，最主要的是，我现在的工作非常好，目前我还承受不了创业带来的失败的后果，但他不知道技术，虽然不能一起创业但还是可以做朋友，所以之后我一直帮着他出谋划策，然后带着他去某个培训机构去面试一些人，我当一个技术面试（好吧，这是我第一次当一个技术面试官面试别人），当我去问那些人问题时，我想起了去年11月份我找工作的情景，所以我很直白地跟他们说：“如果你们真的知道就知道，不知道千万别装知道，因为我也是从你这个时候过来的”，那一天，虽然面试了很多的人，但可惜的是我们没有收获，没有遇到对眼的人。从那之后，我们的联系很少了，经过一个月的时间，他打了一个电话给我，说人找到了邀请我去参加他们公司成立的paty,后来参加他们的paty，看到他找到的那个人，看了看代码就知道那个技术应该是一个学生。从那次参加paty之后，基本上就没有与他们有什么联系了。</p>

<p>前段时间我有一个亲戚给我介绍一份百合的工作，要我去面试，说实话，换工作根本就不在我计划之内，虽然不想去但又不知道怎么推掉，所以还是答应着去试试，当时觉得自己在iOS这一块，应该不会遇到什么难的问题，所以觉得自己应该没什么问题。百合给我打电话，约的面试时间是2点，我1点多就到那里了，前台给我填着一张调查表，然后就让我去小房间等着，大概一直等到2点多终于来了一个大概三四十岁样子的男子（我猜他应该是经理级别的人），第一个问题就是要我介绍自己在大学里的学习，之后就开始问大量的有关C++和内存方面的知识，由于通知面试到面试只有一天的时间，而且正好那时自己非常忙，所以没有去复习C++方面的知识，再加上自己对面试的认识还不够，导致自己这次面试真的非常的失败，面试结束之后，当时真想有个地洞蹭进去，然后自己灰头土脸地快速逃离现场。在回来的路上，我一直总结这次面试失利的原因，总体来说可以归纳以下几点：1、最主要也是最重要一条：自己对面试的态度有错误。之前一直想着，不想换工作，所以对面试也就没什么在意，经历过这一次之后，我觉得不管以后去哪个公司面试，想不想去，都应该做好充分地准备，作为大公司，他们都会有自己的人材库，所以你如果确实有很高的技术和能力，虽然你这个时候还不想去，但下次想去的时候你会方便很多，但如果这次给你面试的机会，你没有好好把握，下次想去面试的机会都会很困难。2、自己的专业知识还是停在应用层，至于底层的话我就完全不明白了，这是需要我去补救的。3、口才不好，我想大部分的程序员都会存在着这样的问题，本来心里非常明白的一个问题，但就是不知道如何去表达，甚至以致造成听的误解意思。</p>

<p>总体来说，2013年是一个收获的一年，自己也慢慢在成长，虽然我在年初的时候定的一些计划还有三个没有完成（现在看来也完成不了了。。。。），但自己也学了很多的东西。希望在未来的2014年里，自己能多看书，总结自己的一些知识，多写写技术博文。</p>

<p>2013即将成为历史，2014将是我参加工作的第2个年头，希望在工作的第2个年头，自己能够学会如何利用现在公司给与我的平台，去施展自己的抱负，我不想像今年一样地平庸，因为平庸只会慢慢消磨自己的斗争。我不希望自己和别人一样，觉得现在的生活就这样了，完全没有了当初毕业的那份豪气。2014年不管会发生什么，自己绝不能丧失斗志，不能做一天和尚撞一天钟。2014改变自己，敞开双手迎接我的2014！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress在Github搭建一个博客]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/26/octopress/"/>
    <updated>2013-12-26T23:59:57+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/26/octopress</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/26/OctopressAndGithub.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p><a href="http://http://octopress.org/">Octopress</a>是利用<a href="http://http://github.com/mojombo/jekyll">Jekyll</a>博客引擎开发的一个博客系统，生成的静态页面能够很好的在<em>github page</em>上展现。号称是hacker专属的一个博客系统(A blogging framework for hackers.)<!--more--></p>

<p>从自己开始使用Octopress搭建博客到正在写博客，中间差不多花了我三个星期，在这三个星期中，我走了很多的弯路，使用Octopress搭建博客的错误我相信我已经遇到80～90%了，所以想写一篇使用Octopress在Github上怎么搭建博客，一来为了与其他人分享，令想利用Octopress搭建博客的人少走一些弯路，另一方面也是自己对这方面的知识一个积累，首先我说一下我的在mac系统环境下搭建的，本文需要读者熟悉一些shell命令，并掌握基本的git操作。</p>

<p><strong>目录</strong></p>

<pre><code>1、搭建环境
2、安装Octopress
3、配置Octopress
4、将博客部署到GitHub上
5、开始写博客
</code></pre>

<p><strong>1、搭建环境</strong></p>

<p>Octopress需要Ruby环境，RVM(Ruby Version Manager)负责安装和管理Ruby的环境。所以我们先在终端输入如下命令，来安装RVM：</p>

<pre><code>1、curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<p>接着是安装<code>Ruby 2.0.0</code>，在终端依次运行如下命令：</p>

<pre><code>1、rvm install 1.9.3
2、rvm use 1.9.3
3、rvm rubygems latest
</code></pre>

<p>完成上面的操作之后，运行ruby &mdash;v应该可以看到ruby 2.0.0环境已经安装好了。</p>

<p>参考：<code>Installing Ruby With RVM</code></p>

<p>在安装Octopress时还需要make命令，所以还会用到command_line_tools，所以还需要下载Xcode，打开Xcode,到Xcode->preferences->Downloads，里面有一个command_line_tools点击下载。</p>

<p>2、安装Octopress</p>

<p>在安装Octopress之前，请确保你的电脑上已经安装有git了，在终端输入git &mdash;version，如果安装了可以看到电脑中的git版本(一般情况下，mac系统现在都已经自带git了)，如果没有显示相关内容，请先安装git。</p>

<p>git安装之后，利用git命令将<code>octopress</code>从<code>github上clone</code>到本机，如下命令：</p>

<pre><code>1、git clone git://github.com/imathis/octopress.git octopress
2、cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
</code></pre>

<p>接着安装相关依赖项：</p>

<pre><code>1、gem install bundler
3、bundle install
</code></pre>

<p>最后安装默认的<code>Octopress</code>主题。</p>

<pre><code>1、rake install
</code></pre>

<p>如果执行<code>rake install</code>报如下错误：<code>You have already activated rake 0.9.6, but your Gemfile requires rake 0.9.2.2. Using bundle exec may solve this.</code></p>

<p>解决办法：打开<code>Gemfile</code>文件，把<code>gem 'rake', '~&gt; 0.9.0'</code>修改成<code>gem 'rake', '~&gt; 0.9.6'</code></p>

<p>参考： <code>Octopress Setup</code></p>

<p><strong>3、配置Octopress</strong></p>

<p><code>Octopress</code>的作者已经尽量让配置简化了。大多数情况下只需要配置<code>_config.yml</code>和<code>Rakefile</code>文件即可。其中Rakefile是跟博客部署相关，一般情况下并不需要修改这个文件，除非使用了<code>rsync</code>。</p>

<p><code>config.yml</code>是博客重要的一个配置文件，在<code>config.yml</code>文件中有三大配置项：<code>Main Configs</code>、<code>Jekyll &amp; Plugins</code>和<code>3rd Party Settings</code>。</p>

<p>一般，该文件中其中<code>url</code>是必须要填写的，这里的<code>url</code>是在<code>github</code>上创建的一个仓库地址，具体请看第四步中创建的地址。另外再修改一下<code>title</code>、<code>subtitle</code>和<code>author</code>，根据需求，在开启一些第三方组件服务。</p>

<pre><code>url: beyondabel.github.io     #网站地址 
title: abel之家               #网站标题 
subtitle: 天行健，君子以自强不息.地势坤，君子以厚德载物.     #网站副标题 
author: abel                      #网站作者，通常显示在页尾和每篇文章的尾部 
simple_search: http://google.com/search   # 搜索引擎 
description:             #网站的描述，出现在HTML页面中的 meta 中的 description
</code></pre>

<p>更多内容，请看这里的内容：<a href="http://octopress.org/docs/configuring/">Configuring Octopress</a></p>

<p><strong>4、将博客部署到GitHub上</strong></p>

<p><code>Github</code>的<code>Page service</code>可以免费托管博客，并且还可以自定义域名。</p>

<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照这样的方式进行命名：<code>username.github.com</code>或<code>organization.github.com</code>。等后面配置完毕之后，我们就可以在浏览器中使用页面地址<code>http://username.github.com</code>来访问我们的博客。一般来说，我们希望在将博客的源码放到source分支下，并把生成的内容提交到master分支。</p>

<p>创建好仓库之后，我们需要利用octopress的一个配置rake任务来自动配置上面创建的仓库：可以让我们方便的部署<code>GitHub page</code>。在终端输入如下命令：</p>

<pre><code>1、$ rake setup_github_pages
</code></pre>

<p>上面的命令会做一些事情(详细介绍看下面给出的参考链接)。其中最主要的就是创建一个_deploy目录，目录用来存放部署到master分支的内容。期间会要求你输入仓库的url，根据提示，进行输入即可。
完成上面的命令之后，我们就可以生成博客并真正的部署到仓库中了。执行如下命令：</p>

<pre><code>1、rake generate
2、rake deploy
</code></pre>

<p>上面的命令首先生成博客文件，并将生成的博客文件拷贝到<code>_deploy/</code>目录下，然后将这些内容添加到git中，并commit和push到仓库的master分支。</p>

<p>现在可以访问<code>http://username.github.io</code>了。注意：有时候可能会有延时，要等几分钟才能打开。
至此，我们的博客已经完成基本的部署。</p>

<p>如果在部署到仓库之前，需要先预览一下博客，可以在终端输入<code>rake preview</code>命令，然后就能在浏览器中进行本地预览访问了：<code>http://127.0.0.1:4000/</code>或<code>http://localhost:4000/</code>，效果跟仓库中的一样。
参考：<code>Deploying to Github Pages</code></p>

<p>如果本地访问时出现了404错误，请关注一下你生成的文件是否直接在public目录下，如果不在，请修改一下<code>config.rb</code>文件，使<code>http_path = "/"</code>。如果访问<code>http://username.github.com</code>上出现了404错误，看一下你的<code>repositories</code>是否有内容，如果有，请你再次确认你的<code>repositories</code>的名称是否是<code>username.github.io</code>,如果不是，那么请用<code>http://username.github.io/[your repositories name]</code>，如果还是不行，请关注一下，你的账号是否使用邮箱激活了，如果没有，请先激活，然后删除这个<code>repositories</code>重新再来。</p>

<p><strong>5、开始写博客</strong></p>

<p><code>Octopress</code>为我们提供了一些task来创建博文和页面。博文必须存储在<code>source/_posts</code>目录下，并且需要按照Jekyll的命名规范对文章进行命名：<code>YYYY-MM-DD-post-title.markdown</code>。文章的名字会被当做url的一部分，而其中的日期用于对博文的区分和排序。</p>

<p>通过<code>Octopress</code>提供的<code>task</code>可以正确的按照命名规范创建一个博文，并且在博文中会附带常用的一些yaml元数据。只需要在终端输入如下命令：</p>

<pre><code>1、rake new_post["title"]
</code></pre>

<p>其中<code>title</code>为博文的文件名，创建出来的文件默认是<code>markdown</code>格式。上面的命令会创建出这样一个文件：<code>source/_posts/2013-08-03-title.markdown</code>。打开这个文件，可以看到里面有如下一些内容了(告诉Jekyll博客引擎如何处理博文和页面)：</p>

<pre><code>---
layout: post
title: "title"
date: 2013-12-26 16:36
comments: true
categories: 
---
</code></pre>

<p>接着我们就可以在这个文件中写我们的博文啦。完成之后，我们可以预览和部署博文。下面是创建并部署博文的一个完整过程：</p>

<pre><code>1、$ rake new_post["New Post"]
2、$ rake generate
3、$ rake deploy
</code></pre>

<p>参考：<a href="http://octopress.org/docs/blogging/">Blogging Basics</a></p>

<p>到此，我们使用Octopress在Github上博客就搭建好了，这中间如果遇到什么问题，可以给我留言。接下来，我将带给大家如何更换博客样式，如何添加评论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS时间相关各种技巧]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/24/ios-time/"/>
    <updated>2013-12-24T22:33:47+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/24/ios-time</id>
    <content type="html"><![CDATA[<p><strong>一、通过自带的日历得到年月日、时间、以及星期</strong></p>

<!--more-->


<pre><code>NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
NSDate *now;
NSDateComponents *comps = [[NSDateComponents alloc] init];
NSInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSWeekdayCalendarUnit | 
                                     NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;
now=[NSDate date];
comps = [calendar components:unitFlags fromDate:now];
week = [comps weekday];    
month = [comps month];
day = [comps day];
hour = [comps hour];
min = [comps minute];
sec = [comps second];
</code></pre>

<p><strong>二、世界标准时间UTC /GMT 转为当前系统时区对应的时间</strong></p>

<pre><code>- (NSDate *)getNowDateFromatAnDate:(NSDate *)anyDate
{
    //设置源日期时区
    NSTimeZone* sourceTimeZone = [NSTimeZone timeZoneWithAbbreviation:@"UTC"];//或GMT
    //设置转换后的目标日期时区
    NSTimeZone* destinationTimeZone = [NSTimeZone localTimeZone];
    //得到源日期与世界标准时间的偏移量
    NSInteger sourceGMTOffset = [sourceTimeZone secondsFromGMTForDate:anyDate];
    //目标日期与本地时区的偏移量
    NSInteger destinationGMTOffset = [destinationTimeZone secondsFromGMTForDate:anyDate];
    //得到时间偏移量的差值
    NSTimeInterval interval = destinationGMTOffset - sourceGMTOffset;
    //转为现在时间
    NSDate* destinationDateNow = [[[NSDate alloc] initWithTimeInterval:interval sinceDate:anyDate] autorelease];
    return destinationDateNow;
}
</code></pre>

<p><strong>三、NSString格式转化为NSDate</strong></p>

<pre><code>- (NSDate *)stringToDate:(NSString *)strdate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatteralloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];// NSString的时间格式
    NSDate *retdate = [dateFormatter dateFromString:strdate];
    [dateFormatter release];
    return retdate;
}
</code></pre>

<p><strong>四、NSDate转化为NSString</strong></p>

<pre><code>- (NSString *)dateToString:(NSDate *)date
{
    NSDateFormatter *dateFormatter = [[NSDateFormatteralloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSString *strDate = [dateFormatter stringFromDate:date];
    [dateFormatter release];
    return strDate;
}
</code></pre>

<p><strong>五、将本地日期字符串转为UTC日期字符串</strong></p>

<pre><code>//本地日期格式:2013-08-03 12:53:51
//可自行指定输入输出格式
-(NSString *)getUTCFormateLocalDate:(NSString *)localDate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //输入格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];

    NSDate *dateFormatted = [dateFormatter dateFromString:localDate];
    NSTimeZone *timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
    [dateFormatter setTimeZone:timeZone];
    //输出格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    NSString *dateString = [dateFormatter stringFromDate:dateFormatted];
    [dateFormatter release];
    return dateString;
}
</code></pre>

<p><strong>六、将UTC日期字符串转为本地时间字符串</strong></p>

<pre><code>//输入的UTC日期格式2013-08-03T04:53:51+0000
-(NSString *)getLocalDateFormateUTCDate:(NSString *)utcDate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //输入格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    NSTimeZone *localTimeZone = [NSTimeZone localTimeZone];
    [dateFormatter setTimeZone:localTimeZone];

    NSDate *dateFormatted = [dateFormatter dateFromString:utcDate];
    //输出格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSString *dateString = [dateFormatter stringFromDate:dateFormatted];
    [dateFormatter release];
    return dateString;
}
</code></pre>

<p><strong>七、iOS开发之格式化日期时间</strong></p>

<p>字符说明</p>

<p>(:)时间分隔符。在某些区域设置中，可以使用其他字符表示时间分隔符。时间分隔符在格式化时间值时分隔小时、分钟和秒。格式化输出中用作时间分隔符的实际字符由您的应用程序的当前区域性值确定。</p>

<p>(/)日期分隔符。在某些区域设置中，可以使用其他字符表示日期分隔符。日期分隔符在格式化日期值时分隔日、月和年。格式化输出中用作日期分隔符的实际字符由您的应用程序的当前区域性确定。</p>

<p>(%)用于表明不论尾随什么字母，随后字符都应该以单字母格式读取。也用于表明单字母格式应以用户定义格式读取。有关更多详细信息，请参见下面的内容。</p>

<p>D将日显示为不带前导零的数字（如 1）。如果这是用户定义的数字格式中的唯一字符，请使用 %D。</p>

<p>DD将日显示为带前导零的数字（如 01）。</p>

<p>EEE将日显示为缩写形式（例如 SUN）。</p>

<p>EEEE将日显示为全名（例如 SUNDAY）。</p>

<p>M将月份显示为不带前导零的数字（如一月表示为 1）。如果这是用户定义的数字格式中的唯一字符，请使用 %M。</p>

<p>MM将月份显示为带前导零的数字（例如 01/12/01）。</p>

<p>MMM将月份显示为缩写形式（例如 JAN）。</p>

<p>MMMM将月份显示为完整月份名（例如 JANUARY）。</p>

<p>GG显示时代/纪元字符串（例如 A.D.）</p>

<p>H使用 12 小时制将小时显示为不带前导零的数字（例如 1:15:15 PM）。如果这是用户定义的数字格式中的唯一字符，请使用 %H。</p>

<p>HH使用 12 小时制将小时显示为带前导零的数字（例如 01:15:15 PM）。</p>

<p>H使用 24 小时制将小时显示为不带前导零的数字（例如 1:15:15）。如果这是用户定义的数字格式中的唯一字符，请使用 %H。</p>

<p>HH使用 24 小时制将小时显示为带前导零的数字（例如 01:15:15）。</p>

<p>M将分钟显示为不带前导零的数字（例如 12:1:15）。如果这是用户定义的数字格式中的唯一字符，请使用 %M。</p>

<p>MM将分钟显示为带前导零的数字（例如 12:01:15）。</p>

<p>S将秒显示为不带前导零的数字（例如 12:15:5）。如果这是用户定义的数字格式中的唯一字符，请使用 %S。</p>

<p>SS将秒显示为带前导零的数字（例如 12:15:05）。</p>

<p>F显示秒的小数部分。例如，FF 将精确显示到百分之一秒，而 FFFF 将精确显示到万分之一秒。用户定义格式中最多可使用七个 F 符号。如果这是用户定义的数字格式中的唯一字符，请使用 %F。</p>

<p>T使用 12 小时制，并对中午之前的任一小时显示大写的 A，对中午到 11:59 P.M 之间的任一小时显示大写的 P。如果这是用户定义的数字格式中的唯一字符，请使用 %T。</p>

<p>TT对于使用 12 小时制的区域设置，对中午之前任一小时显示大写的 AM，对中午到 11:59 P.M 之间的任一小时显示大写的 PM。对于使用 24 小时制的区域设置，不显示任何字符。</p>

<p>Y将年份 (0-9) 显示为不带前导零的数字。如果这是用户定义的数字格式中的唯一字符，请使用 %Y。</p>

<p>YY以带前导零的两位数字格式显示年份（如果适用）。</p>

<p>YYY以四位数字格式显示年份。</p>

<p>YYYY以四位数字格式显示年份。</p>

<p>Z显示不带前导零的时区偏移量（如 -8）。如果这是用户定义的数字格式中的唯一字符，请使用 %Z。</p>

<p>ZZ显示带前导零的时区偏移量（例如 -08）</p>

<p>ZZZ显示完整的时区偏移量（例如 -08:00）</p>

<p>格式显示</p>

<pre><code>M/D/YY    12/7/58
D-MMM    7-DEC
D-MMMM-YY     7-DECEMBER-58
D MMMM      7 DECEMBER
MMMM YY    DECEMBER 58
HH:MM TT     08:50 PM
H:MM:SS T     8:50:35 P
H:MM    20:50
H:MM:SS    20:50:35
M/D/YYYY H:MM     12/7/1958 20:50   
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的博客搬家啦～]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/01/my-new-blog/"/>
    <updated>2013-12-01T23:37:45+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/01/my-new-blog</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/01/my-new-blog.png" alt="image" /></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;我是一个非常喜欢折腾的程序猿，之前我一直在CSDN上写博文，但由于一些种种的原因，后来放弃了CSDN,之后一直都有搭建个人站点的想法,在网上搜索了如何搭建个人站点,网上有很多的人建议用Octopress+Github,转而开始用Octopress搭建博客<!--more-->，从开始弄Octopress到成功在Github上发布博文已经差不多一个月了，虽然网上有太多关于得用Octopress搭建Github博客的博文，但对于一个小白的我使用Octopress搭建Github博客过程的坚苦也只有自己知道，所以在下一篇博文中我将会记录我使用Octopress搭建Github博客的点点滴滴。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;搭建博客的主要原因一是可以与大家分享交流，二是可以总结一下自己。
使用Octopress+Github与CSDN、百度、新郎、博客园相比，它更自由，可以自定义自己的时尚元素，有一些我非常喜欢的style.如果想使用Octopress+Github搭建博客，将会经历如下步骤：</p>

<p>1.首先，注册一个github账号。</p>

<p>2.配置环境</p>

<p>3.下载Octopress包</p>

<p>4.配置Octopress</p>

<p>5.绑定Github账号</p>

<p>6.把Octopress提交到Github</p>

<p>如果想用域名可以访问的话，还需要经历如下的步骤：</p>

<p>7.域名注册</p>

<p>8.购买虚拟主机</p>

<p>9.域名与虚拟主机中的IP进行绑定。</p>

<p>到此，博客就基本搭建好了～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下CocoaPods安装步骤]]></title>
    <link href="http://beyondabel.github.io/blog/2013/11/13/mac-install-cocoapods/"/>
    <updated>2013-11-13T19:16:34+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/11/13/mac-install-cocoapods</id>
    <content type="html"><![CDATA[<p>介绍：
开发应用的时候第三方的库是不可缺少的，它能提高开发的效率。一些经常用到的库，在新的项目里用是，你又得手工的Add到项目里，用的到库多起来了，就不方便管理了。CocoaPods这个软件，可以方便的帮你管理Xcode里的第三方的库。</p>

<!--more-->


<p>安装步骤：
1、打开终端在终端输入</p>

<pre><code> sudo gem install -V cocoapods 
</code></pre>

<p>2、等待下载完成后，会出现</p>

<pre><code>/usr/bin/xcodeproj
Building native extensions.  This could take a while...
ERROR:  Error installing cocoapods:

ERROR: Failed to build gem native extension.

/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby extconf.rb
checking for -std=c99 option to compiler... yes
checking for CoreFoundation... yes
checking for CoreFoundation/CoreFoundation.h... yes
checking for CoreFoundation/CFStream.h... yes
checking for CoreFoundation/CFPropertyList.h... yes
checking for ruby/st.h... yes
creating extconf.h
creating Makefile

make
xcrun cc -I. -I. -I/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin12.0 -I. -
DRUBY_EXTCONF_H=\"extconf.h\"  -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE   -fno-common -arch i386 -arch x86_64 -g -Os -pipe -fno-common -DENABLE_DTRACE  -fno-common  -pipe -fno-common  -std=c99  -c xcodeproj_ext.c
xcrun: Error: could not stat active Xcode path '/Applications/Xcode5-DP3.app/Contents/Developer'. (No such file or directory)
cc -arch i386 -arch x86_64 -pipe -bundle -undefined dynamic_lookup -o xcodeproj_ext.bundle xcodeproj_ext.o -L. -L/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib -L. -arch i386 -arch x86_64  -ObjC -framework CoreFoundation    -lruby  -lpthread -ldl -lobjc 
clang: error: no such file or directory: 'xcodeproj_ext.o'
make: *** [xcodeproj_ext.bundle] Error 1


Gem files will remain installed in /Library/Ruby/Gems/1.8/gems/xcodeproj-0.5.2 for inspection.
Results logged to /Library/Ruby/Gems/1.8/gems/xcodeproj-0.5.2/ext/xcodeproj/gem_make.out
</code></pre>

<p>说明：出现上面错误原因是因为找不到xcode
解决办法：在终端输入sudo xcode-select &mdash;switch /Applications/Xcode5-DP5.app/Contents/Developer（Xcode5-DP5是Xcode版本号）</p>

<p>3、更新cocoapods 在终端上输入sudo gem update -V
如果更新出错或者发现cocoapods不是最新版本的话，最好就是去下载一个最新版本，然后在本地安装</p>

<p>4、搜索  先试试搜索功能，你需要什么库，可以用pod来搜索，比如要用AFNetworking这个库：pod search是搜索命名，后面写上库名称就行了。搜索pod search AFNetworking</p>

<p>能够搜索出来说明cocoapods安装成功，下面我就来说说怎么使用cocoapods.</p>

<p>1、创建一个xcode项目，并通过终端进入一个xcode项目目录。在终端输入</p>

<pre><code>vi Podfile
在Podfile里写入
platform :ios, '5.0'
pod 'AFNetworking', '~&gt;1.1.0'
</code></pre>

<p>2、在终端进入项目目录，在终端上输入 pod install</p>

<pre><code> 你会发现这个目录多了*.xcworkspace pod等文件。这是pod生成的项目管理文件，打开*.xcworkspace 项目文件，在Xcode里看到是这样的目录结构：

 ![image](http://)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS设计模式之单例模式]]></title>
    <link href="http://beyondabel.github.io/blog/2013/10/30/singleton/"/>
    <updated>2013-10-30T12:55:59+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/10/30/singleton</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/10/30/singleton.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>单例模式是iOS常用设计模式中的一种。单例设计模式的作用是使得这个类的一个对象成为系统中的唯一实例，因此需要用一种唯一的方法去创建这个对象并返回这个对象的地址。那么，我们何时使用单例模式呢？</p>

<!--more-->


<p>1、类只能有一个实例，而且必须从一个为人熟知的访问点对其访问。</p>

<p>2、这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。</p>

<p>那么用Objective-C如何实现单例模式呢？下面我们来新建一个Singleton类，在Singleton.h中实现如下</p>

<pre><code>@interface Singleton : NSObject 
+ (Singleton *) sharedInstance;
@end 
</code></pre>

<p>在Singleton.m</p>

<pre><code>@implementation Singleton 
static Singleton * sharedSingleton = nil;

+ (Singleton *) sharedInstance  { 
    if (sharedSingleton == nil) {    
        sharedSingleton = [[Singleton alloc] init]; 
    } 
    return sharedSingleton;
}  

@end 
</code></pre>

<p>这样就创建一个简单的单例模式，实际上有一部分程序员也是这样实现的，但实际上这是一个不“严格”版本，在实际中使用，可能会遇到发起调用的对象不能以其他分配方式实例化单例对象，否则，就会创建多个实例。（之前有人和我讨论过这个问题，说使用者应该严格按照接口来使用，当实际上Singleton是一个对象，我们不能保证使用者不会使用其他的方法去创建（比如alloc）,这个时候他就会创建多个实例，这样就会出现这些无法感知的bug）</p>

<p>下面我对<code>Singleton.m</code>的进行改进</p>

<pre><code>@implementation Singleton  
 static Singleton * sharedSingleton = nil;  
+ (Singleton *) sharedInstance  {  
    if (sharedSingleton == nil) {  
        sharedSingleton = [[super allocWithZone:NULL] init];  
    }  
    return sharedSingleton;  
}  

+ (id) allocWithZone:(struct _NSZone *)zone  {  
    return [[self sharedInstance] retain];  
}  

- (id) copyWithZone:(NSZone *) zone  {  
    return self;  
}  

- (id) retain  {  
    return self;  
}  

- (NSUInteger) retainCount  {  
    return NSUIntegerMax;  
}  


- (void) release  {  
//  
}  

- (id) autorelease  {  
    return self;  
}  
@end 
</code></pre>

<p>也许你注意到了，我重载了<code>allocWithZone:</code>，保持了从<code>sharedInstance</code>方法返回的单例对象，使用者哪怕使用<code>alloc</code>时也会返回唯一的实例（<code>alloc</code>方法中会先调用<code>allocWithZone:</code>创建对象）。而<code>retain</code>等内存管理的函数也被重载了，这样做让我们有了把<code>Singleton</code>类变得“严格”了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[禁止键盘弹出时UIWebView自动滑动]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/28/ios-webview-keybord/"/>
    <updated>2013-09-28T23:01:15+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/28/ios-webview-keybord</id>
    <content type="html"><![CDATA[<p>之前在做公司项目的时候，需要做一个页面编辑功能，当我们点击编辑器的时候，网页会自动的滑动，结果导致编辑器的fram发生变化。为了解决这个问题，我们需要去禁止webView的自动滑动，我们只需要重写viewForZoomingInScrollView方法就可以了</p>

<!--more-->


<pre><code>webview.scrollView.delegate=self;

-(UIView*)viewForZoomingInScrollView:(UIScrollView*)scrollView 
{
    return nil;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网页颜色值转化成UIColor]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/27/webcolor-uicolor/"/>
    <updated>2013-09-27T19:14:03+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/27/webcolor-uicolor</id>
    <content type="html"><![CDATA[<p>在做项目过程中，有时设计人员给我们往往是一个设计图，而我们用PS取值的时候可以得到一个红绿蓝和一个网页的颜色值，用红绿蓝往往不是很方便，后来我们在项目工具中写一个方法，专门把网页的颜色值转化成UIColor，这样一来，方便了许多。</p>

<!--more-->


<pre><code>+ (UIColor *)colorFromHexString:(NSString *)hexString {
    unsigned rgbValue = 0;
    NSScanner *scanner = [NSScannerscannerWithString:hexString];
    [scanner setScanLocation:1];// bypass '#' character
    [scannerscanHexInt:&amp;rgbValue];
    return [UIColorcolorWithRed:((rgbValue &amp; 0xFF0000) &gt;&gt; 16)/255.0green:((rgbValue &amp; 0xFF00) &gt;&gt; 8)/255.0 blue:(rgbValue &amp; 0xFF)/255.0 alpha:1.0];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程之GCD]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/26/ios-gcd-one/"/>
    <updated>2013-09-26T15:39:29+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/26/ios-gcd-one</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/26/gcd.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>GCD（Grand Central Dispatch）是一套低层API，提供了一种新的方法来进行并发程序编写。允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>

<!--more-->


<p>GCD的API很大程度上基于block，当然，GCD也可以脱离block来使用，比如使用传统c机制提供函数指针和上下文指针。实践证明，当配合block使用时，GCD非常简单易用且能发挥其最大能力。</p>

<p>GCD相比传统多线程编程的优势：</p>

<p>从使用来看: GCD比之thread跟简单易用。由于GCD基于work unit而非像thread那样基于运算，所以GCD可以控制诸如等待任务结束、监视文件描述符、周期执行代码以及工作挂起等任务。基于block的血统导致它能极为简单得在不同代码作用域之间传递上下文。</p>

<p>从效率看: GCD被实现得如此轻量和优雅，使得它在很多地方比之专门创建消耗资源的线程更实用且快速。这关系到易用性：导致GCD易用的原因有一部分在于你可以不用担心太多的效率问题而仅仅使用它就行了。</p>

<p>从性能上来看: GCD自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。</p>

<p>注：尽管GCD是纯C语言，但它被组建成面向对象的风格，被称为dispatch object。它像cocoa对象一样是引用计数的。使用dispatch_release和dispatch_retain函数来操作dispatch object的引用计数来进行内存管理。如果你使用了ARC，但由于它不是OC对象，所以并不参与垃圾回收，所以即使你使用了ARC，也记得一定要对内存进行手动管理。</p>

<p>GCD的基本概念就是dispatch queue。dispatch queue是一个对象，它可以接受任务，并将任务以先到先执行的顺序来执行。dispatch queue可以是并发的或串行的。并发任务会像NSOperationQueue那样基于系统负载来合适地并发进行，串行队列同一时间只执行单一任务。</p>

<p>GCD中有三种队列类型：</p>

<p>main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。</p>

<p>Global queues: 全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。</p>

<p>用户创建队列: 用函数 dispatch_queue_create 创建的队列. 这些队列是串行的，正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发过程中出现错误整理]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/25/ios-developerment-error/"/>
    <updated>2013-09-25T19:10:57+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/25/ios-developerment-error</id>
    <content type="html"><![CDATA[<p>1、No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6).</p>

<!--more-->


<p>今天上午开完会，一回来真机调试就报 No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6)错误。虚拟机没事，一旦用真机就报这个错误，开始以为是我安装几个软件之后，安装不成功，系统问题。然后就是重装系统，都不成功。最终解决办法：</p>

<p>1.把Build Active Architecture Only 下面的Debug 设为NO release 设置为YES
2.Valid Architectures 设置为 armv7 armv6 就OK 了。</p>

<p>1.Xcode编译出现错误如下：CodeSign error: code signing is required for product type &lsquo;Application&rsquo; in SDK &lsquo;iOS 5.0&rsquo;
解决方法如下：
选择工程－>Build Settings &ndash;> Code Signing &ndash;> Code Signing Identity &ndash;> Debug &ndash;> Any ios SDK 将选项改为：iPhone Developer</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程总述]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/24/thread-overview/"/>
    <updated>2013-09-24T10:34:29+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/24/thread-overview</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/26/multithreading.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。在系统级别内，程序并排执行，系统分配到每个程序的执行时间是基于该程序的所需时间和其他程序的所需时间来决定的。然而在每个应程序的内部，存在一个或多个执行线程，它同时或在一个几乎同时发生的方式里执行不同的任务。系统本身管理这些执行的线程，调度它们在可用的内核上运行，并在需要让其他线程执行的时候抢先打断它们。</p>

<!--more-->


<p>从技术角度来看，一个线程就是一个需要管理执行代码的内核级和应用级数据结构组合。内核级结构协助调度线程事件，并抢占式调度一个线程到可用的内核之上。应用级结构包括用于存储函数调用的调用堆栈和应用程序需要管理和操作线程属性和状态的结构。</p>

<p>在非并发的应用程序，只有一个执行线程。该线程开始和结束于你应用程序的main循环，一个个方法和函数的分支构成了你整个应用程序的所有行为。与此相反，支持并发的应用程序开始可以在需要额外的执行路径时候创建一个或多个线程。每个新的执行路径有它自己独立于应用程序main循环的定制开始循环。在应用程序中存在多个线程提供了两个非常重要的的潜在优势：</p>

<p>多个线程可以提高应用程序的感知响应。</p>

<p>多个线程可以提高应用程序在多核系统上的实时性能。</p>

<p>如果你的应用程序只有单独的线程，那么该独立程序需要完成所有的事情。它必须对事件作出响应，更新您的应用程序的窗口，并执行所有实现你应用程序行为需要的计算。拥有单独线程的主要问题是在同一时间里面它只能执行一个任务。那么当你的应用程序需要很长时间才能完成的时候会发生什么呢？当你的代码忙于计算你所需要的值的时候，你的程序就会停止响应用户事件和更新它的窗口。如果这样的情况持续足够长的时间，用户就会误认为你的程序被挂起了，并试图强制退出。如果你把你的计算任务转移到一个独立的线程里面，那么你的应用程序主线程就可以自由并及时响应用户的交互。</p>

<p>当然多线程并不是解决程序性能问题的灵丹妙药。多线程带来好处同时也伴随着潜在问题。应用程序内拥有多个可执行路径，会给你的代码增加更多的复杂性。每个线程需要和其他线程协调其行为，以防止它破坏应用程序的状态信息。因为应用程序内的多个线程共享内存空间，它们访问相同的数据结构。如果两个线程试图同时处理相同的数据结构，一个线程有可能覆盖另外线程的改动导致破坏该数据结构。即使有适当的保护，你仍然要注意由于编译器的优化导致给你代码产生很微妙的（和不那么微妙）的Bug。</p>

<p><strong>线程术语</strong></p>

<p>在讨论多线程和它支持的相关技术之前，我们有必要先了解一些基本的术语。如果你熟悉Carbon的多处理器服务API或者UNIX系统的话，你会发现本文档里面“任务(task)”被用于不同的定义。在Mac OS的早期版本，术语“任务(task)”是用来区分使用多处理器服务创建的线程和使用Carbon线程管理API创建的线程。在UNIX系统里面，术语“任务（task）”也在一段时间内被用于指代运行的进程。在实际应用中，多处理器服务任务是相当于抢占式的线程。</p>

<p>由于Carbon线程管理器和多处理器服务API是Mac OS X的传统技术，本文件采用下列术语：
线程(线程)用于指代独立执行的代码段。</p>

<p>进程(process)用于指代一个正在运行的可执行程序，它可以包含多个线程。</p>

<p>任务(task)用于指代抽象的概念，表示需要执行工作。</p>

<p><strong>多线程的替代方法</strong></p>

<p>你自己创建多线程代码的一个问题就是它会给你的代码带来不确定性。多线程是一个相对较低的水平和复杂的方式来支持你的应用程序并发。如果你不完全理解你的设计选择的影响，你可能很容易遇到同步或定时问题，其范围可以从细微的行为变化到严重到让你的应用程序崩溃并破坏用户数据。</p>

<p>你需要考虑的另一个因素是你是否真的需要多线程或并发。多线程解决了如何在同一个进程内并发的执行多路代码路径的问题。然而在很多情况下你是无法保证你所在做的工作是并发的。多线程引入带来大量的开销，包括内存消耗和CPU占用。你会发现这些开销对于你的工作而言实在太大，或者有其他方法会更容易实现。</p>

<p>注意:当使用fork函数加载独立进程的时候，你必须总是在fork后面调用exec或者类似的函数。基于Core Foundation、Cocao或者Core Data框架（无论显式还是隐式关联）的应用程序随后调用exec函数或者类似的函数都会导出不确定的结果。</p>

<p><strong>线程支持</strong></p>

<p>如果你已经有代码使用了多线程，Mac OS X和iOS提供几种技术来在你的应用程序里面创建多线程。此外，两个系统都提供了管理和同步你需要在这些线程里面处理的工作。以下几个部分描述了一些你在Mac OS X和iOS上面使用多线程的时候需要注意的关键技术。</p>

<p><strong>线程包</strong></p>

<p>虽然多线程的底层实现机制是Mach的线程，你很少（即使有）使用Mach级的线程。相反，你会经常使用到更多易用的POSIX 的API或者它的衍生工具。Mach的实现没有提供多线程的基本特征，但是包括抢占式的执行模型和调度线程的能力，所以它们是相互独立的。</p>

<p>   在应用层上，其他平台一样所有线程的行为本质上是相同的。线程启动之后，线程就进入三个状态中的任何一个:运行(running)、就绪(ready)、阻塞(blocked)。如果一个线程当前没有运行，那么它不是处于阻塞，就是等待外部输入，或者已经准备就绪等待分配CPU。线程持续在这三个状态之间切换，直到它最终退出或者进入中断状态。</p>

<p>当你创建一个新的线程，你必须指定该线程的入口点函数（或Cocoa线程时候为入口点方法）。该入口点函数由你想要在该线程上面执行的代码组成。但函数返回的时候，或你显式的中断线程的时候，线程永久停止，且被系统回收。因为线程创建需要的内存和时间消耗都比较大，因此建议你的入口点函数做相当数量的工作，或建立一个运行循环允许进行经常性的工作。</p>

<p>为了获取更多关于线程支持的可用技术并且如何使用它们，请阅读“线程管理部分”。</p>

<p><strong>Run Loops</strong></p>

<pre><code>注:为了便于记忆，文本后面部分翻译Run Loops的时候基本采用原义，而非翻译为“运行循环”。
</code></pre>

<p>  一个run loop是用来在线程上管理事件异步到达的基础设施。一个run loop为线程监测一个或多个事件源。当事件到达的时候，系统唤醒线程并调度事件到run loop,然后分配给指定程序。如果没有事件出现和准备处理，run loop把线程置于休眠状态。</p>

<p>你创建线程的时候不需要使用一个run loop，但是如果你这么做的话可以给用户带来更好的体验。Run Loops可以让你使用最小的资源来创建长时间运行线程。因为run loop在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了消耗CPU周期轮询，并防止处理器本身进入休眠状态并节省电源。</p>

<p>为了配置run loop,你所需要做的是启动你的线程，获取run loop的对象引用，设置你的事件处理程序，并告诉run loop运行。Cocoa和Carbon提供的基础设施会自动为你的主线程配置相应的run loop。如果你打算创建长时间运行的辅助线程，那么你必须为你的线程配置相应的run loop。</p>

<p>关于run loops的详细信息和如何使用它们的例子会在“Run Loops”部分介绍。</p>

<p><strong>同步工具</strong></p>

<p>线程编程的危害之一是在多个线程之间的资源争夺。如果多个线程在同一个时间试图使用或者修改同一个资源，就会出现问题。缓解该问题的方法之一是消除共享资源，并确保每个线程都有在它操作的资源上面的独特设置。因为保持完全独立的资源是不可行的，所以你可能必须使用锁，条件，原子操作和其他技术来同步资源的访问。</p>

<p>锁提供了一次只有一个线程可以执行代码的有效保护形式。最普遍的一种锁是互斥排他锁，也就是我们通常所说的“mutex”。当一个线程试图获取一个当前已经被其他线程占据的互斥锁的时候，它就会被阻塞直到其他线程释放该互斥锁。系统的几个框架提供了对互斥锁的支持，虽然它们都是基于相同的底层技术。此外Cocoa提供了几个互斥锁的变种来支持不同的行为类型，比如递归。获取更多关于锁的种类的信息，请阅读“锁”部分内容。</p>

<p>除了锁，系统还提供了条件，确保在你的应用程序任务执行的适当顺序。一个条件作为一个看门人，阻塞给定的线程，直到它代表的条件变为真。当发生这种情况的时候，条件释放该线程并允许它继续执行。POSIX级别和基础框架都直接提供了条件的支持。（如果你使用操作对象，你可以配置你的操作对象之间的依赖关系的顺序确定任务的执行顺序，这和条件提供的行为非常相似）。</p>

<p>尽管锁和条件在并发设计中使用非常普遍，原子操作也是另外一种保护和同步访问数据的方法。原子操作在以下情况的时候提供了替代锁的轻量级的方法，其中你可以执行标量数据类型的数学或逻辑运算。原子操作使用特殊的硬件设施来保证变量的改变在其他线程可以访问之前完成。</p>

<p>获取更多关于可用同步工具信息，请阅读“同步工具”部分。</p>

<p><strong>线程间通信</strong></p>

<p>虽然一个良好的设计最大限度地减少所需的通信量，但在某些时候，线程之间的通信显得十分必要。（线程的任务是为你的应用程序工作，但如果从来没有使用过这些工作的结果，那有什么好处呢？）线程可能需要处理新的工作要求，或向你应用程序的主线程报告其进度情况。在这些情况下，你需要一个方式来从其他线程获取信息。幸运的是，线程共享相同的进程空间，意味着你可以有大量的可选项来进行通信。
线程间通信有很多种方法，每种都有它的优点和缺点。“配置线程局部存储”列出了很多你可以在Mac OS X上面使用的通信机制。（异常的消息队列和Cocoa分布式对象，这些技术也可在iOS用来通信）。本表中的技术是按照复杂性的顺序列出。</p>

<p><strong>设计技巧</strong></p>

<p>以下各节帮助你实现自己的线程提供了指导，以确保你代码的正确性。部分指南同时提供如何利用你的线程代码获得更好的性能。任何性能的技巧，你应该在你更改你代码之前、期间、之后总是收集相关的性能统计数据。</p>

<p><strong>避免显式创建线程</strong></p>

<p>手动编写线程创建代码是乏味的，而且容易出现错误，你应该尽可能避免这样做。Mac OS X和iOS通过其他API接口提供了隐式的并发支持。你可以考虑使用异步API，GCD方式，或操作对象来实现并发，而不是自己创建一个线程。这些技术背后为你做了线程相关的工作，并保证是无误的。此外，比如GCD和操作对象技术被设计用来管理线程，比通过自己的代码根据当前的负载调整活动线程的数量更高效。 关于更多GCD和操作对象的信息，你可以查阅“并发编程指南(Concurrency Programming Guid)”。</p>

<p><strong>保持你的线程合理的忙</strong></p>

<p>如果你准备人工创建和管理线程，记得多线程消耗系统宝贵的资源。你应该尽最大努力确保任何你分配到线程的任务是运行相当长时间和富有成效的。同时你不应该害怕中断那些消耗最大空闲时间的线程。线程使用一个平凡的内存量，它的一些有线，所以释放一个空闲线程，不仅有助于降低您的应用程序的内存占用，它也释放出更多的物理内存使用的其他系统进程。线程占用一定量的内存，其中一些是有线的，所以释放空闲线程不但帮助你减少了你应用程序的内存印记，而且还能释放出更多的物理内存给其他系统进程使用。</p>

<p>重要:在你中断你的空闲线程开始之前，你必须总是记录你应用程序当前的性能基线测量。当你尝试修改后，采取额外的测量来确保你的修改实际上提高了性能，而不是对它操作损害。</p>

<p><strong>避免共享数据结构</strong></p>

<p>避免造成线程相关资源冲突的最简单最容易的办法是给你应用程序的每个线程一份它需求的数据的副本。当最小化线程之间的通信和资源争夺时并行代码的效果最好。</p>

<p>创建多线程的应用是很困难的。即使你非常小心，并且在你的代码里面所有正确的地方锁住共享资源，你的代码依然可能语义不安全的。比如，当在一个特定的顺序里面修改共享数据结构的时候，你的代码有可能遇到问题。以原子方式修改你的代码，来弥补可能随后对多线程性能产生损耗的情况。把避免资源争夺放在首位通常可以得到简单的设计同样具有高性能的效果。</p>

<p><strong>多线程和你的用户界面</strong></p>

<p>如果你的应用程序具有一个图形用户界面，建议你在主线程里面接收和界面相关的事件和初始化更新你的界面。这种方法有助于避免与处理用户事件和窗口绘图相关的同步问题。一些框架，比如Cocoa,通常需要这样操作，但是它的事件处理可以不这样做，在主线程上保持这种行为的优势在于简化了管理你应用程序用户界面的逻辑。</p>

<p>有几个显著的例外，它有利于在其他线程执行图形操作。比如，QuickTime API包含了一系列可以在辅助线程执行的操作，包括打开视频文件，渲染视频文件，压缩视频文件，和导入导出图像。类似的，在Carbon和Cocoa里面，你可以使用辅助线程来创建和处理图片和其他图片相关的计算。使用辅助线程来执行这些操作可以极大提高性能。如果你不确定一个操作是否和图像处理相关，那么你应该在主线程执行这些操作。</p>

<p>关于QuickTime线程安全的信息，查阅Technical Note TN2125:“QuickTime的线程安全编程”。关于Cocoa线程安全的更多信息，查阅“线程安全总结”。关于Cocoa绘画信息，查阅Cocoa绘画指南（Cocoa Drawing Guide）。</p>

<p><strong>了解线程退出时的行为</strong></p>

<p>进程一直运行直到所有非独立线程都已经退出为止。默认情况下，只有应用程序的主线程是以非独立的方式创建的，但是你也可以使用同样的方法来创建其他线程。当用户退出程序的时候，通常考虑适当的立即中断所有独立线程，因为通常独立线程所做的工作都是是可选的。如果你的应用程序使用后台线程来保存数据到硬盘或者做其他周期行的工作，那么你可能想把这些线程创建为非独立的来保证程序退出的时候不丢失数据。</p>

<p>以非独立的方式创建线程（又称作为可连接的）你需要做一些额外的工作。因为大部分上层线程封装技术默认情况下并没有提供创建可连接的线程，你必须使用POSIX API来创建你想要的线程。此外，你必须在你的主线程添加代码，来当它们最终退出的时候连接非独立的线程。更多有关创建可连接的线程信息，请查阅“设置线程的脱离状态”部分。</p>

<p>如果你正在编程Cocoa的程序，你也可以通过使用applicationShouldTerminate:的委托方法来延迟程序的中断直到一段时间后或者完成取消。当延迟中断的时候，你的程序需要等待直到任何周期线程已经完成它们的任务且调用了replyToApplicationShouldTerminate:方法。关于更多这些方法的信息，请查阅NSApplication Class Reference。</p>

<p><strong>处理异常</strong></p>

<p>当抛出一个异常时，异常的处理机制依赖于当前调用堆栈执行任何必要的清理。因为每个线程都有它自己的调用堆栈，所以每个线程都负责捕获它自己的异常。如果在辅助线程里面捕获一个抛出的异常失败，那么你的主线程也同样捕获该异常失败：它所属的进程就会中断。你无法捕获同一个进程里面其他线程抛出的异常。</p>

<p>如果你需要通知另一个线程（比如主线程）当前线程中的一个特殊情况，你应该捕捉异常，并简单地将消息发送到其他线程告知发生了什么事。根据你的模型和你正在尝试做的事情，引发异常的线程可以继续执行（如果可能的话），等待指示，或者干脆退出。</p>

<pre><code>注意:在Cocoa里面，一个NSException对象是一个自包含对象，一旦它被引发了，那么它可以从一个
    线程传递到另外一个线程。
</code></pre>

<p>在一些情况下，异常处理可能是自动创建的。比如，Objective-C中的@synchronized包含了一个隐式的异常处理。</p>

<p><strong>干净地中断你的线程</strong></p>

<p>线程自然退出的最好方式是让它达到其主入口结束点。虽然有不少函数可以用来立即中断线程，但是这些函数应仅用于作为最后的手段。在线程达到它自然结束点之前中断一个线程阻碍该线程清理完成它自己。</p>

<p>1、iOS有三种多线程编程的技术，分别是：</p>

<p>1.NSThread</p>

<p>2.Cocoa NSOperation （IOS多线程编程之NSOperation和NSOperationQueue的使用）</p>

<p>3.GCD 全称：Grand Central Dispatch（ IOS多线程编程之Grand Central Dispatch(GCD)介绍和使用）</p>

<p>这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的。</p>

<p>2、三种方式的优缺点介绍：</p>

<p>NSThread:</p>

<p>优点：NSThread 比其他两个轻量级</p>

<p>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</p>

<p>Cocoa operation</p>

<p>优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。</p>

<p>Cocoa operation相关的类是 NSOperation,NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation和NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。</p>

<p>GCD:Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。现在的iOS系统都升级到6了，所以不用担心该技术不能使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试中常遇到的几个问题]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/10/interview/"/>
    <updated>2013-09-10T11:28:02+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/10/interview</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/10/interview.png" alt="image" /></p>

<p>引言</p>

<p>对了以技术出身的程序员来说，面试题的积累是非常有必要的。Abel在这整理几个iOS面试中常常会问到的几个问题。</p>

<!--more-->


<p><strong>1、#import与#include的区别，以及@class</strong></p>

<pre><code>1.import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。
2.在头文件中， 一般只需要知道被引用的类的名称就可以了。 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。
3.在编译效率方面考虑，如果你有100个头文件都#import了同一个头文件，或者这些文件是依次引用的，如A–&gt;B, B–&gt;C, C–&gt;D这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用 @class则不会。
4.如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现。
所以，一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.
</code></pre>

<p>综上所述#include，#import与@class的区别可以做一下理解：</p>

<pre><code>  #include与#import在引用一个类的时候会包含这个类的所有信息包括变量方法等，但是这样做会对编译效率造成影响.比如有100个类 都#import了ClassA，那么在编译的时候这100个类都会去对ClassA处理.又比如A被B引用，B被C引用，C被D引用.....此时如果 A被修改，那么后面的B，C，D.....都需要重新进行编译.
  #import处理了重复引用的问题，还有一个用法会引起编译错误的就是在ClassA中#import ClassB 在ClassB中#import ClassA（交叉编译）那么在编译的时候也会出现未知错误。
</code></pre>

<p><strong>2、堆和栈的区别?定义一个变量时，这个变量是在堆上还是在栈上？什么时候这个变量的内存会被释放？</strong></p>

<pre><code>一、预备知识—程序的内存分配 
一个由C/C++编译的程序占用的内存分为以下几个部分 
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 操作方式类似于数据结构中的栈。 
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 - 程序结束后由系统释放。 
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 
5、程序代码区—存放函数体的二进制代码。 


二、例子程序 
这是一个前辈写的，非常详细 
//main.cpp 
int a = 0; 全局初始化区 
char *p1; 全局未初始化区 
main() 
{ 
    int b; 栈 
    char s[] = "abc"; 栈 
    char *p2; 栈 
    char *p3 = "123456"; 123456\0在常量区，p3在栈上。 
    static int c =0； 全局（静态）初始化区 
    p1 = (char *)malloc(10); 
    p2 = (char *)malloc(20); 
    分配得来得10和20字节的区域就在堆区。 
    strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456" 优化成一个地方。 
} 


二、堆和栈的理论知识 
2.1申请方式 
stack: 
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 
heap: 
需要程序员自己申请，并指明大小，在c中malloc函数 
如p1 = (char *)malloc(10); 
在C++中用new运算符 
如p2 = new char[10]; 
但是注意p1、p2本身是在栈中的。 
2.2 申请后系统的响应 
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的 首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部 分重新放入空闲链表中。 

2.3申请大小的限制 
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

2.4申请效率的比较： 
栈由系统自动分配，速度较快。但程序员是无法控制的。 
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 

2.5堆和栈中的存储内容 
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 

2.6存取效率的比较 
char s1[] = "aaaaaaaaaaaaaaa"; 
char *s2 = "bbbbbbbbbbbbbbbbb"; 
aaaaaaaaaaa是在运行时刻赋值的； 
而bbbbbbbbbbb是在编译时就确定的； 
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 
比如： 
#include 
void main() 
{ 
    char a = 1; 
    char c[] = "1234567890"; 
    char *p ="1234567890"; 
    a = c[1]; 
    a = p[1]; 
return; 
} 
对应的汇编代码 
10: a = c[1]; 
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] 
0040106A 88 4D FC mov byte ptr [ebp-4],cl 
11: a = p[1]; 
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] 
00401070 8A 42 01 mov al,byte ptr [edx+1] 
00401073 88 45 FC mov byte ptr [ebp-4],al 
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 

2.7小结： 
堆和栈的区别可以用如下的比喻来看出： 
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。
</code></pre>

<p><strong>3、进程和线程的区别</strong></p>

<pre><code>通俗的解释
一个系统运行着很多进程，可以比喻为一条马路上有很多马车,不同的进程可以理解为不同的马车,而同一辆马车可以有很多匹马来拉----这些马就是线程,假设道路的宽度恰好可以通过一辆马车,道路可以认为是临界资源,那么马车成为分配资源的最小单位（进程）,而同一个马车被很多匹马驱动（线程）----即最小的运行单位,每辆马车马匹数&gt;=1，所以马匹数=1的时候进程和线程没有严格界限，只存在一个概念上的区分度，马匹数&gt;1的时候才可以严格区分进程和线程

专业的解释：
简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。
+++++++++++++++++++++++++++++++++++++++++++++++

进程概念
进程是表示资源分配的基本单位，又是调度运行的基本单位。例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I／O设备等。然后，把该进程放人进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以，进程是系统中的并发执行的单位。
在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。

线程概念
线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。例如，假设用户启动了一个窗口中的数据库应用程序，操作系统就将对数据库的调用表示为一个进程。假设用户要从数据库中产生一份工资单报表，并传到一个文件中，这是一个子任务；在产生工资单报表的过程中，用户又可以输人数据库查询请求，这又是一个子任务。这样，操作系统则把每一个请求――工资单报表和新输人的数据查询表示为数据库进程中的独立的线程。线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就是为了方便而有效地实现这种并发性

引入线程的好处
（1）易于调度。
（2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。
（3）开销少。创建线程比创建进程要快，所需开销很少。。
（4）利于充分发挥多处理器的功能。通过创建多线程进程（即一个进程可具有两个或更多个线程），每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。
++++++++++++++++++++++++++++++++++++++++++++++++
进程和线程的关系：
（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。

（3）处理机分给线程，即真正在处理机上运行的是线程。

（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

线程是指进程内的一个执行单元,也是进程内的可调度实体.

与进程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

进程间的通信方式：
1.管道（pipe）及有名管道（named pipe）：

管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
2.信号（signal）：
信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
3.消息队列（message queue）：
消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
4.共享内存（shared memory）：
可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
5.信号量（semaphore）：
主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
6.套接字（socket）；
这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
线程之间的同步通信：
1.信号量 二进制信号量 互斥信号量 整数型信号量 记录型信号量
2.消息     消息队列 消息邮箱
3.事件event

互斥型信号量：必须是同一个任务申请，同一个任务释放，其他任务释放无效。同一个任务可以递归申请。（互斥信号量是二进制信号量的一个子集）

二进制信号量：一个任务申请成功后，可以由另一个任务释放。（与互斥信号量的区别）

整数型信号量：取值不局限于0和1,可以一个任务申请，另一个任务释放。（包含二进制信号量，二进制信号量是整数型信号量的子集）

二进制信号量实现任务互斥：
   打印机资源只有一个，a b c三个任务共享，当a取得使用权后，为了防止其他任务错误地释放了信号量（二进制信号量允许其他任务释放），必须将打印机房的门关起来(进入临界段)，用完后，释放信号量，再把门打开(出临界段)，其他任务再进去打印。(而互斥型信号量由于必须由取得信号量的那个任务释放，故不会出现其他任务错误地释放了信号量的情况出现，故不需要有临界段。互斥型信号量是二进制信号量的子集。)

二进制信号量实现任务同步：
 a任务一直等待信号量，b任务定时释放信号量，完成同步功能

记录型信号量（record semaphore)：
   每个信号量s除一个整数值value（计数）外，还有一个等待队列List，其中是阻塞在该信号量的各个线程的标识。当信号量被释放一个，值被加一后，系统自动从等待队列中唤醒一个等待中的线程，让其获得信号量，同时信号量再减一。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

同步和互斥的区别：
 当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。

 所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的

 所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
</code></pre>
]]></content>
  </entry>
  
</feed>
