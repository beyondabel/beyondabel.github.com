<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel之家]]></title>
  <link href="http://beyondabel.github.io/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2014-02-13T09:57:04+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS安全攻防（一）：Hack必备的命令与工具]]></title>
    <link href="http://beyondabel.github.io/blog/2014/02/11/iossafety-hacktools/"/>
    <updated>2014-02-11T23:32:27+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/02/11/iossafety-hacktools</id>
    <content type="html"><![CDATA[<p>Hack必备的命令与工具</p>

<p>你的应用正在被其他对手反向工程、跟踪和操作！你的应用是否依旧裸奔豪不防御？
郑重声明一下，懂得如何攻击才会懂得如何防御，一切都是为了之后的防御作准备。废话少说，进入正题。
今天总结一下为hack而做的准备工作。</p>

<!--more-->


<p>常用的命令和工具</p>

<pre><code>ps           ——显示进程状态，CPU使用率，内存使用情况等
sysctl       ——检查设定Kernel配置
netstat     ——显示网络连接，路由表，接口状态等
route        ——路由修改
renice       ——调整程序运行的优先级
ifconfig    ——查看网络配置
tcpdump   ——截获分析网络数据包
lsof           ——列出当前系统打开的文件列表，别忘记一切皆文件，包括网络连接、硬件等
otool ①     ——查看程序依赖哪些动态库信息，反编代码段……等等等等
nm ②        ——显示符号表
ldid ③      ——签名工具
gdb          ——调试工具
patch       ——补丁工具
SSH         ——远程控制
</code></pre>

<p>备注：</p>

<p>① otool，可查看可执行程序都链接了那些库：</p>

<pre><code>   otool  -L WQAlbum 
</code></pre>

<p>可以得到：</p>

<pre><code>WQAlbum:
    /System/Library/Frameworks/StoreKit.framework/StoreKit (compatibility version 1.0.0, current version 1.0.0)
    /System/Library/Frameworks/AdSupport.framework/AdSupport (compatibility version 1.0.0, current version 1.0.0)
    /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.5)
    /System/Library/Frameworks//MediaPlayer.framework/MediaPlayer (compatibility version 1.0.0, current version 1.0.0)
    /System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices (compatibility version 1.0.0, current version 40.0.0)
    /System/Library/Frameworks/CoreMedia.framework/CoreMedia (compatibility version 1.0.0, current version 1.0.0)
    ……
</code></pre>

<p>可以反编译WQAlbum的<strong>TEXT</strong>段内容, 截前10行：</p>

<pre><code>otool -tV WQAlbum |head -n 10 
</code></pre>

<p>可以得到：</p>

<pre><code>WQAlbum:
(__TEXT,__text) section
start:
00002de0    pushl   $0x00
00002de2    movl    %esp,%ebp
00002de4    andl    $0xf0,%esp
00002de7    subl    $0x10,%esp
00002dea    movl    0x04(%ebp),%ebx
……
</code></pre>

<p>② nm，显示程序符号表，用我自己的应用程序私人相册现身说法一下：
nm -g WQAlbum  （ -g 代表 global）</p>

<p>可以得到：</p>

<pre><code>001e5eec S _OBJC_IVAR_$_WQPhotoViewController.albumObject
001e5efc S _OBJC_IVAR_$_WQPhotoViewController.int_current
001e5f00 S _OBJC_IVAR_$_WQPhotoViewController.int_total
</code></pre>

<p>其中，WQPhotoViewController为类名，albumObject为该类的成员</p>

<p>③ ldid，是iPhoneOS.platform提供的签名工具，我们自己编译的程序需要签上名才能跑在iPhone/iPad上，使用方法</p>

<pre><code>export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/codesign_allocate
ldid -S helloworld 
</code></pre>

<p>编译Hello world</p>

<p>1.首先找到编译器：</p>

<p>arm-apple-darwin10-llvm-gcc-4.2 就是了。
为了方便起见，可以在.bashrc或者profile 配置下环境变量，方便编译。</p>

<p>2.找到SDK</p>

<p>编译我们自己的程序的时候需要指定该目录下的SDK。</p>

<p>3.来个经典Hello world ：</p>

<pre><code>#include &lt;stdio.h&gt;                                                                                             
int main(){  
   printf("Hello world !!!\n");  
   return 0;  
}  
</code></pre>

<p>4.编译</p>

<p>其中 -isysroot用来指定build时的SDK</p>

<p>5.校验</p>

<p>file查看一下类型，没问题。</p>

<p>6.SCP给iPhone、iPad</p>

<p>前提是，设备已经越狱并且安装了SSH,且必须在同一网段。</p>

<pre><code>$scp helloworld root@x.x.x.x:hello world
</code></pre>

<p>7.登录设备签名</p>

<pre><code>$ssh -l root x.x.x.x
#ldid -S helloworld
</code></pre>

<p>8.执行程序</p>

<pre><code>#./helloworld
Hello world !!!
</code></pre>

<p>运行成功，这就完成了最简单的手动执行自己的应用程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABELWebImageKit使用介绍]]></title>
    <link href="http://beyondabel.github.io/blog/2014/02/10/abelwebimagekit/"/>
    <updated>2014-02-10T20:30:17+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/02/10/abelwebimagekit</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>ABELWebImageKit托管在github上：<a href="https://github.com/beyondabel/ABELWebImage">https://github.com/beyondabel/ABELWebImage</a></p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、ABELWebImageKit介绍
2、ABELWebImageKit库结构的简单分析
3、ABELWebImageKit库的图片管理
4、ABELWebImageKit库使用的简单举例
</code></pre>

<p><strong>1、ABELWebImageKit介绍</strong></p>

<p>这个库提供一个ABELImageView类以支持加载来自网络的远程图片。具有缓存管理、异步下载、同一个URL下载次数控制和优化等特征。将ABELWebImageKit类库添加入工程时，一定注意需要添加ImageIO.framework。UIImage+Tools依赖这个framework。</p>

<p><strong>2、ABELWebImageKit库结构的简单分析</strong></p>

<p>ABELImageView：ABELImageView继承于UIImageView的，它主要用于加载来自网络的远程图片。其中avater用于区别是否为头像图片（默认非头像）。</p>

<p>ABELWebImageCacheManager：ABELWebImageCacheManager是一个单例，对图片进行管理的中转站，读取图片（向下层读取Cache或者读取网络），实现ABELWebImageCache和ABELWebImageRequest的回调。</p>

<p>ABELWebImageCache：根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）     实现图片和内存清理工作。
ABELWebImageRequest：根据URL向网络读取数据</p>

<p><strong>3、ABELWebImageKit库的图片管理</strong></p>

<p>ABELWebImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。</p>

<p>内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。当ABELWebImageCacheManager向ABELWebImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。</p>

<p><strong>4、ABELWebImageKit库使用的简单举例</strong></p>

<pre><code>self.avatarImageView = [[ABELImageView alloc] init];
// 设置avatar为YES为显示圆形头像图片，否则为普通的图片
self.avatarImageView.avatar = YES;
self.avatarImageView.frame = CGRectMake(15, 10, 40, 40);
[self.avatarImageView setImageWithURL:[NSURL URLWithString:URLString]]
[self.contentView addSubview:self.avatarImageView];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISwitch详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/11/uiswitch/"/>
    <updated>2014-01-11T12:34:31+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/11/uiswitch</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISwitch继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）,您可以使用UISwitch类来创建和管理使用开/关按钮。例如，在对选项，如飞行模式和蓝牙设置应用程序。这些对象被称为交换机。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
</code></pre>

<p><strong>1、基本属性及方法</strong>
// 开关是否打开</p>

<pre><code>BOOL on;
</code></pre>

<p>// 这个frame会被忽略，他会强制设置大小</p>

<pre><code>- (id)initWithFrame:(CGRect)frame;
</code></pre>

<p>// 打开/关闭调用函数(animated：是否使用动画)</p>

<pre><code>- (void)setOn:(BOOL)on animated:(BOOL)animated;
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 开关打开时颜色</p>

<pre><code>UIColor *onTintColor;
</code></pre>

<p><strong>3、iOS6新增</strong>
// 背影颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 开关的圆形滑钮的颜色</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 开关打开时自定义图片</p>

<pre><code>UIImage *onImage;
</code></pre>

<p>// 开关关闭时自定义图片</p>

<pre><code>UIImage *offImage;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISlider详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/11/uislider/"/>
    <updated>2014-01-11T12:34:24+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/11/uislider</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISlider继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。UISlider对象是用来从一个连续的数值范围内选择单个值的可视化控制。滑块总是显示为水平条形图。一个指标，注意到滑块的当前值，并且可以由用户进行移动来改变该设置。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、设置初始值
2、改变UISlider的外观
3、供子类重写的方法
</code></pre>

<p><strong>1、设置初始值</strong></p>

<p>// 指定初始值</p>

<pre><code>float value;
</code></pre>

<p>// 指定可变最小值</p>

<pre><code>float minimumValue;
</code></pre>

<p>// 指定可变最大值</p>

<pre><code>float maximumValue;
</code></pre>

<p><strong>2、改变UISlider的外观</strong></p>

<p>//  设置滑轮左边图片</p>

<pre><code>UIImage *minimumValueImage;
</code></pre>

<p>// 设置滑轮右边图片</p>

<pre><code>UIImage *maximumValueImage;
</code></pre>

<p>//  （默认YES）</p>

<pre><code>BOOL continuous;
</code></pre>

<p>//  滑轮左边颜色如果设置了左边的图片就不会显示（iOS 5.0）</p>

<pre><code>UIColor *minimumTrackTintColor;
</code></pre>

<p>// 滑轮右边颜色如果设置了右边的图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *maximumTrackTintColor;
</code></pre>

<p>// 设置了滑轮的颜色如果设置了滑轮的样式图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 动态设置滑动值</p>

<pre><code>- (void)setValue:(float)value animated:(BOOL)animated;
</code></pre>

<p>// 定制自己的滑块图片</p>

<pre><code>- (void)setThumbImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置左边的图片</p>

<pre><code>- (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置右边的图片</p>

<pre><code>- (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>//  根据状态返回滑动图片</p>

<pre><code>- (UIImage *)thumbImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态左边的图片</p>

<pre><code>- (UIImage *)minimumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态右边的图片</p>

<pre><code>- (UIImage *)maximumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 当前的滑动图片（只读）</p>

<pre><code>UIImage* currentThumbImage;
</code></pre>

<p>// 当前左边的图片（只读）</p>

<pre><code>UIImage* currentMinimumTrackImage;
</code></pre>

<p>// 当前右边的图片（只读）</p>

<pre><code>UIImage* currentMaximumTrackImage;
</code></pre>

<p><strong>3、供子类重写的方法</strong></p>

<p>// 以下四种方法用于子类覆盖,用来自定义thumb、track的CGRect</p>

<pre><code>- (CGRect)minimumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)maximumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)trackRectForBounds:(CGRect)bounds;
- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISegmentedControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/10/uisegmentedcontrol/"/>
    <updated>2014-01-10T12:34:00+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/10/uisegmentedcontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISegmentedControl对象是一个水平控制使多个区段，每个区段用作离散的按钮。分段控件提供了一次小型的手段组合在一起的一些控制。</p>

<p>UISegmentedControl继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）.</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS 5.0新增
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化UISegmentedControl（items可以是NSString类型或者UIImages）</p>

<pre><code>- (id)initWithItems:(NSArray *)items;
</code></pre>

<p>//设置样式 （该样式只在ios2.0~7.0有效果）</p>

<pre><code>UISegmentedControlStyle segmentedControlStyle;
</code></pre>

<p>//设置在点击后是否恢复原样（默认是NO）</p>

<pre><code>BOOL momentary;
</code></pre>

<p>// 设置总选项数</p>

<pre><code>NSUInteger numberOfSegments;
</code></pre>

<p>//是否根据segment的内容改变segment的宽度 (只使用ios5.0，默认为NO)</p>

<pre><code>BOOL apportionsSegmentWidthsByContent;
</code></pre>

<p>//在指定的索引插入一个选项并设置题目</p>

<pre><code>- (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//在指定的索引插入一个选项并设置图片</p>

<pre><code>- (void)insertSegmentWithImage:(UIImage *)image  atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除指定索引的选项</p>

<pre><code>- (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除所有的选项</p>

<pre><code>- (void)removeAllSegments;
</code></pre>

<p>//设置指定索引题目</p>

<pre><code>- (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的标题</p>

<pre><code>- (NSString *)titleForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引的图片</p>

<pre><code>- (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的图片</p>

<pre><code>- (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项的宽度（默认是0）</p>

<pre><code>- (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的宽度</p>

<pre><code>- (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置选项中图片等的左上角的位置</p>

<pre><code>- (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取选项中图片等的左上角的位置</p>

<pre><code>- (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项不可选</p>

<pre><code>- (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//判断指定索引选项是否可选</p>

<pre><code>- (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置默认选项索引</p>

<pre><code>NSInteger selectedSegmentIndex; 
</code></pre>

<p>//设置UISegmentedControl的颜色</p>

<pre><code>UIColor *tintColor; 
</code></pre>

<p><strong>2、iOS 5.0新增</strong></p>

<p>//设置在某个状态下的背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>//获取在某个状态下的背景图片</p>

<pre><code>- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics   
</code></pre>

<p>//设置分割线背景图片</p>

<pre><code>- (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetCT
</code></pre>

<p>//获取分割线背景图片</p>

<pre><code>- (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMeE 
</code></pre>

<p>//设置文字显示样式</p>

<pre><code>- (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
</code></pre>

<p>//获取文字显示样式</p>

<pre><code>- (NSDictionary *)titleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//设置选项中内容的调整位置</p>

<pre><code>- (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics; 
</code></pre>

<p>//获取选项中内容的调整位置</p>

<pre><code>- (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIPageControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/09/uipagecontrol/"/>
    <updated>2014-01-09T12:33:46+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/09/uipagecontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIPageControl继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。您可以使用UIPageControl类来创建和管理页面控件。一个页面控件显示一个水平一系列的点，每个对应一个页面应用程序的文档（或其他数据模型实体）中。当前浏览的页面是由一个白色的圆点表示。</p>

<p>当用户点击一个页面控件移动到下一页或上一页，控制处理由委托发送UIControlEventValueChanged事件。然后委托可以评估当前属性来确定要显示的页面。网页控制在任何一个方向前进只有一个页面。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS6.0新增
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 指定页面个数（默认为0）</p>

<pre><code>NSInteger numberOfPages;
</code></pre>

<p>// 当前选中的页面（默认为0，范围为0 ～ numberOfPages-1）</p>

<pre><code>NSInteger currentPage;
</code></pre>

<p>// 如果在numberOfPages为1的情况下隐藏指示器，可以将hideForSinglePage的值设为YES。默认情况下，即使只有一个页面，指示器也会显示进来。</p>

<pre><code>BOOL hidesForSinglePage;
</code></pre>

<p>// 如果你希望直到有时间执行完你的操作之后，才更新当前指示器当前指示页，可以将 defersCurrentPageDisPlay 设为YES。这样的话你必须调用控件的 updateCurentPageDisPlay 来更新当前页</p>

<pre><code>BOOL defersCurrentPageDisplay;
</code></pre>

<p>// 更新当前页</p>

<pre><code>- (void)updateCurrentPageDisplay;
</code></pre>

<p>// 返回接受者的边界大小，与容纳被给的页面数有关</p>

<pre><code>- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;
</code></pre>

<p><strong>2、iOS6.0新增</strong>
// 未选中的点的颜色</p>

<pre><code>UIColor *pageIndicatorTintColor;
</code></pre>

<p>// 当前点颜色</p>

<pre><code>UIColor *currentPageIndicatorTintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIDatePicker详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/09/uidatepicker/"/>
    <updated>2014-01-09T12:33:27+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/09/uidatepicker</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>该的UIDatePicker类实现使用多个车轮转动，以允许用户选择日期和时间的对象。UIDatePicker iPhone的例子是定时器和时钟应用程序的闹钟（设置闹钟）窗格。您也可以使用日期选择器作为一个倒数计时器。</p>

<p>如果配置正确，一个的UIDatePicker对象发送一个动作消息，当一个用户完成旋转的轮子之一更改日期或时间，相关的控制事件是UIControlEventValueChanged 。一个的UIDatePicker对象呈现倒数计时，但没有实现它，应用程序必须设立的NSTimer对象，并为他们倒计数更新秒。</p>

<p>UIDatePicker不是从UIPickerView的继承，而是继承于UIControl（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。，但它管理的自定义选择器视图对象作为一个子视图。</p>

<!--more-->


<pre><code>typedef enum {
    //根据区域设置,显示小时,分钟,并指定AM/PM(例如:6|53|PM)
    UIDatePickerModeTime,
    //根据区域设置,显示月,日,年(例如:November|15|2007)
    UIDatePickerModeDate, 
    //根据区域设置,显示日期(星期,月,日),小时,分钟,并指定AM/PM(例如:Wed Nov 15|6|53|PM)
    UIDatePickerModeDateAndTime,
    //显示小时,分钟(例如:1|53)  
    UIDatePickerModeCountDownTimer
} UIDatePickerMode;
</code></pre>

<p>// 设置UIDatePicker的显示模式(默认为UIDatePickerModeDateAndTime)</p>

<pre><code>UIDatePickerMode datePickerMode; 
</code></pre>

<p>//设置为语言显示</p>

<pre><code>NSLocale   *locale;   
</code></pre>

<p>// 设置日历</p>

<pre><code>NSCalendar *calendar;
</code></pre>

<p>// 设置时区</p>

<pre><code>NSTimeZone *timeZone; 
</code></pre>

<p>// 设置当前显示时间</p>

<pre><code>NSDate *date;
</code></pre>

<p>//如果animated为YES,时间轮会自动显示新的时间</p>

<pre><code>- (void)setDate:(NSDate *)date animated:(BOOL)animated;        
</code></pre>

<p>// 设置显示最小时间</p>

<pre><code>NSDate *minimumDate;
</code></pre>

<p>// 设置显示最大时间（此处为当前时间）</p>

<pre><code>NSDate *maximumDate;
</code></pre>

<p>//用于UIDatePickerModeCountDownTimer,否则忽略.默认为0.0.最大限制为23:59 (86,399秒)</p>

<pre><code>NSTimeInterval countDownDuration;
</code></pre>

<p>//设置分钟之间的间隔.间隔必须均匀的分为60.默认为1.最小为1,最大为30</p>

<pre><code>NSInteger      minuteInterval;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIButton详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/08/uibutton/"/>
    <updated>2014-01-08T12:33:18+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/08/uibutton</id>
    <content type="html"><![CDATA[<p>引言</p>

<p>UIButton的类是一个UIControl子类（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>），它实现了在触摸屏上的按钮。触摸一个按钮拦截事件和动作消息发送到目标对象时，它的挖掘。设定的目标和行动方法都继承自UIControl。这个类提供了方法来设置标题，图像，按钮等外观属性。通过使用set方法，你可以指定一个不同的外观为每个按钮状态。</p>

<!--more-->


<p>目录</p>

<p>// 初始化 button 样式</p>

<pre><code>+ (id)buttonWithType:(UIButtonType)buttonType;
</code></pre>

<p>// 每边（左，右，顶部和底部）可以有不同的值。使用UIEdgeInsetsMake功能设置图片和文字的位置(默认为UIEdgeInsetsZero)</p>

<pre><code>UIEdgeInsets contentEdgeInsets; 
</code></pre>

<p>// 设置标题、图片的边缘值（默认UIEdgeInsetsZero）</p>

<pre><code>UIEdgeInsets titleEdgeInsets;                
</code></pre>

<p>// 决定是否点击按钮会导致其发光</p>

<pre><code>BOOL         reversesTitleShadowWhenHighlighted; 
</code></pre>

<p>// 图像插图或一开始就为每个边缘</p>

<pre><code>UIEdgeInsets imageEdgeInsets;                
</code></pre>

<p>// 决定是否按钮时，突出显示图像的变化。</p>

<pre><code>BOOL         adjustsImageWhenHighlighted;    
</code></pre>

<p>// 决定是否形象的变化时，该按钮被禁用</p>

<pre><code>BOOL         adjustsImageWhenDisabled;       
</code></pre>

<p>// 决定是否点击按钮会导致其发光</p>

<pre><code>BOOL         showsTouchWhenHighlighted;      
</code></pre>

<p>// 设置背景颜色(iOS 5.0)</p>

<pre><code>UIColor     *tintColor;
</code></pre>

<p>// button样式(只读)</p>

<pre><code>UIButtonType buttonType;
</code></pre>

<p>// 设置某个状态下的title</p>

<pre><code>- (void)setTitle:(NSString *)title forState:(UIControlState)state;                    
</code></pre>

<p>// 设置某个状态下的title颜色</p>

<pre><code>- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的阴影颜色</p>

<pre><code>- (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的图片</p>

<pre><code>- (void)setImage:(UIImage *)image forState:(UIControlState)state;                      
</code></pre>

<p>// 设置某个状态下的背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的title属性（iOS 6.0）</p>

<pre><code>- (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state; 
</code></pre>

<p>// 返回一个按钮的状态中使用的字体内容。</p>

<pre><code>- (NSString *)titleForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的字体颜色。</p>

<pre><code>- (UIColor *)titleColorForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的阴影颜色。</p>

<pre><code>- (UIColor *)titleShadowColorForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的图像。</p>

<pre><code>- (UIImage *)imageForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的背景图像</p>

<pre><code>- (UIImage *)backgroundImageForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的内容属性（iOS 6.0）</p>

<pre><code>- (NSAttributedString *)attributedTitleForState:(UIControlState)state;
</code></pre>

<p>// 当前状态的title(只读)</p>

<pre><code>NSString *currentTitle;
</code></pre>

<p>// 当前状态的title字体颜色(只读)</p>

<pre><code>UIColor  *currentTitleColor;
</code></pre>

<p>// 当前状态的阴影(只读)</p>

<pre><code>UIColor  *currentTitleShadowColor;
</code></pre>

<p>// 当前状态的图片(只读)</p>

<pre><code>UIImage  *currentImage;
</code></pre>

<p>// 当前状态的背景图片(只读)</p>

<pre><code>UIImage  *currentBackgroundImage;
</code></pre>

<p>// 当前状态的title的内容属性(只读 iOS 6.0)</p>

<pre><code>NSAttributedString *currentAttributedTitle;
</code></pre>

<p>// UIButton的titleLabel(只读)</p>

<pre><code>UILabel     *titleLabel;
</code></pre>

<p>// UIButton的contentImageView(只读)</p>

<pre><code>UIImageView *imageView;
</code></pre>

<p>// 返回矩形的接收绘制其背景。</p>

<pre><code>- (CGRect)backgroundRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 返回矩形的接收提请其全部内容。</p>

<pre><code>- (CGRect)contentRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 返回title的绘制范围</p>

<pre><code>- (CGRect)titleRectForContentRect:(CGRect)contentRect;
</code></pre>

<p>// 返回图片的绘制范围</p>

<pre><code>- (CGRect)imageRectForContentRect:(CGRect)contentRect;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITableView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/07/uitableview/"/>
    <updated>2014-01-07T12:33:02+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/07/uitableview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UITableView简单来说是一个表视图，继承于UIScrollView（有关UIScrollView请参照<a href="http://beyondabel.github.io/blog/2014/01/05/uiscrollView/">《iOS组件之UIScrollView详解》</a>），用于显示和编辑信息的分层列表。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、tableView的基本属性及方法
2、访问tableView的画图区
3、访问cells和sections
4、滚动tableView
5、插入、删除、移动行和sections
6、管理和编辑cell
7、管理sections
8、配置
9、iOS5.0新增
10、iOS6.0新增
11、iOS7.0
12、UITableViewDataSource协议
    12.1必须实现
    12.2可选
        12.2.1编辑模式
    12.2.2数据操作  
13、UITableViewDelegate协议（可选）
    13.1定制化
    13.2iOS6新增
    13.3可变高度支持
    13.4iOS7.0新增
    13.5header 和 footer Section 信息
    13.6附属公开的接口
    13.7选择
    13.8编辑
    13.9移动
    13.10缩格
    13.11复制/粘贴
</code></pre>

<p><strong>1、tableView的基本属性及方法</strong></p>

<p>// 初始化</p>

<pre><code>- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;
</code></pre>

<p>// 设置tableView的样式（只读）</p>

<pre><code>UITableViewStyle style;
</code></pre>

<p>// 设置数据资源代理</p>

<pre><code>id &lt;UITableViewDataSource&gt; dataSource;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UITableViewDelegate&gt; delegate;
</code></pre>

<p>// 设置每个row的高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat rowHeight;
</code></pre>

<p>// 设置sectionHeader高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionHeaderHeight;   
</code></pre>

<p>// 设置sectionFooter高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionFooterHeight;   
</code></pre>

<p>//  设置tableView的背景view</p>

<pre><code>UIView *backgroundView;
</code></pre>

<p>// 刷新tableView</p>

<pre><code>- (void)reloadData;
</code></pre>

<p>// 刷新tableView中的section</p>

<pre><code>- (void)reloadSectionIndexTitles;
</code></pre>

<p>// sections的数量</p>

<pre><code>- (NSInteger)numberOfSections;
</code></pre>

<p>// 下标为section中的row数量</p>

<pre><code>- (NSInteger)numberOfRowsInSection:(NSInteger)section;
</code></pre>

<p><strong>2、访问tableView的画图区</strong></p>

<p>// 返回指定section的矩形</p>

<pre><code>- (CGRect)rectForSection:(NSInteger)section; 
</code></pre>

<p>// 返回indexPath指定行的矩形</p>

<pre><code>- (CGRect)rectForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的footer矩形</p>

<pre><code>- (CGRect)rectForFooterInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的header矩形</p>

<pre><code>- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>3、访问cells和sections</strong></p>

<p>// 通过cell得到这个cell在tableView的位置</p>

<pre><code>- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;
</code></pre>

<p>// 根据一个几何点返回indexPath,如果超过边界返回nil</p>

<pre><code>- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;
</code></pre>

<p>// 根据一个几何的矩形返回矩形所覆盖的行,返回是一个indexPath数组</p>

<pre><code>- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;         
</code></pre>

<p>//  根据IndexPath返回cell</p>

<pre><code>- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;            
</code></pre>

<p>//</p>

<pre><code>- (NSArray *)visibleCells;
- (NSArray *)indexPathsForVisibleRows;
</code></pre>

<p><strong>4、滚动tableView</strong></p>

<p>// 滚动到指定位置</p>

<pre><code>- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<p>//  同上</p>

<pre><code>- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<p><strong>5、插入、删除、移动行和sections</strong></p>

<p>// 和endUpdates一起用，让插入、删除、选择操作同时动画，没用过</p>

<pre><code>- (void)beginUpdates;
</code></pre>

<p>//</p>

<pre><code>- (void)endUpdates;
</code></pre>

<p>//根据indexPath数组插入行</p>

<pre><code>- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//根据indexPath数组删除行</p>

<pre><code>- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动一行到另一行</p>

<pre><code>- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//插入sections</p>

<pre><code>- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//删除sections</p>

<pre><code>- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动section</p>

<pre><code>- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p><strong>6、管理和编辑cell</strong></p>

<p>// YES进入编辑模式，tableview cell会出现插入、删除、重排序的控件</p>

<pre><code>BOOL editing;
</code></pre>

<p>// 设置进入退出编辑模式</p>

<pre><code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<p><strong>7、管理sections</strong></p>

<p>//是否允许用户选取一行</p>

<pre><code>BOOL allowsSelection;
</code></pre>

<p>//返回选定行的indexPath,单行</p>

<pre><code>- (NSIndexPath *)indexPathForSelectedRow;
</code></pre>

<p>// 根据indexPath选择一行</p>

<pre><code>- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;
</code></pre>

<p>// 根据indexPath取消选择这一行</p>

<pre><code>- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;
</code></pre>

<p><strong>8、配置</strong></p>

<p>// 指定当tableView中多少行的时候开始显示IndexList，默认的设置是NSIntegerMax，即默认是不显示indexList的</p>

<pre><code>NSInteger sectionIndexMinimumDisplayRowCount;
</code></pre>

<p>// 分隔线的样式(默认为UITableViewCellSeparatorStyleSingleLine)</p>

<pre><code>UITableViewCellSeparatorStyle separatorStyle;
</code></pre>

<p>// cell之间的分割线</p>

<pre><code>UIColor *separatorColor;              
</code></pre>

<p>// 设置headerView</p>

<pre><code>UIView *tableHeaderView;                            
</code></pre>

<p>// 设置footerView</p>

<pre><code>UIView *tableFooterView;                            
</code></pre>

<p>// 必须要实现的方法，与tableView同生同死</p>

<pre><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;  
</code></pre>

<p><strong>9、iOS5.0新增</strong></p>

<p>// 移动section</p>

<pre><code>- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;
</code></pre>

<p>// 移动一行到另一行</p>

<pre><code>- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;
</code></pre>

<p>// 返回选定行的indexPath数组，多行</p>

<pre><code>- (NSArray *)indexPathsForSelectedRows;
</code></pre>

<p>//</p>

<pre><code>- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;
</code></pre>

<p>//  编辑模式时是否可选取一行</p>

<pre><code>BOOL allowsSelectionDuringEditing;
</code></pre>

<p>//  是否选取多行，缺省为NO(iOS 5.0)</p>

<pre><code>BOOL allowsMultipleSelection;
</code></pre>

<p>//  编辑模式时可否选取多行</p>

<pre><code>BOOL allowsMultipleSelectionDuringEditing;
</code></pre>

<p><strong>10、iOS6.0新增</strong></p>

<p>// 我想在numberOfRowsInSection方法内获取该section的header View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;
</code></pre>

<p>// 我想在numberOfRowsInSection方法内获取该section的footer View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;
</code></pre>

<p>// 设置索引号颜色</p>

<pre><code>UIColor *sectionIndexColor;
</code></pre>

<p>// 设置索引号背景颜色</p>

<pre><code>UIColor *sectionIndexTrackingBackgroundColor;
</code></pre>

<p>// 注册（没有测试有什么用)</p>

<pre><code>- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier; 
- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier;
- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;
- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;
</code></pre>

<p><strong>11、iOS7.0</strong></p>

<p>// 预设SectionFooter的高度</p>

<pre><code>CGFloat estimatedSectionFooterHeight;
UIEdgeInsets separatorInset;
UIColor *sectionIndexBackgroundColor;
</code></pre>

<p>// 预设row的高度</p>

<pre><code>CGFloat estimatedRowHeight;     
</code></pre>

<p>// 预设SectionHeader的高度</p>

<pre><code>CGFloat estimatedSectionHeaderHeight; 
</code></pre>

<p><strong>12、UITableViewDataSource协议</strong></p>

<p><strong>12.1必须实现</strong>
// 返回每个section中row的数量</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
</code></pre>

<p>// 返回每个UITableViewCell</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>12.2可选</strong></p>

<p>// 返回section的个数</p>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;              
</code></pre>

<p>//  section headerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section; 
</code></pre>

<p>// section footerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>12.2.1编辑模式</strong></p>

<p>// 设置可编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>12.2.1.1移动</strong></p>

<p>// 设置是否可移动</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 设置索引号</p>

<pre><code>- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView
</code></pre>

<p>// 点击索引触发</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index;
</code></pre>

<p><strong>12.2.2数据操作</strong></p>

<p>// 插入/删除指定数据</p>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 重新排序/移动数据操作</p>

<pre><code>- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
</code></pre>

<p><strong>13、UITableViewDelegate协议（可选）</strong></p>

<p><strong>13.1定制化</strong></p>

<p>// cell将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.2iOS6新增</strong></p>

<p>// HeaderView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// cell结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;
</code></pre>

<p>// HeaderView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p><strong>13.3可变高度支持</strong></p>

<p>// 根据indexPath返回row的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 根据indexPath返回HeaderView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据indexPath返回FooterView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.4iOS7.0新增</strong></p>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的cell的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Header的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Footer的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.5header 和 footer Section 信息</strong></p>

<p>// 根据section创建header section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据section创建footer section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.6附属公开的接口</strong></p>

<p>// 回调设置辅助按钮被点击后的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.7选择</strong></p>

<p>// 回调设置某行是否当被点击后处于高亮状态</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行处于高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行失去高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调某行将要被选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行将要被取消选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经被选中点击的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经取消选中的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.8编辑</strong></p>

<p>// 回调设置某行进入了哪种编辑模式</p>

<pre><code>- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置某行进入删除模式的删除按钮名字</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 是否允许对row进行编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 开始编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 结束编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.9移动</strong></p>

<p>// 移动Row时会把触发，在交换Row位置的时候，必须同时交换DataSource中数据的位置。</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;               
</code></pre>

<p><strong>13.10缩格</strong></p>

<p>// 设置内容缩进</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.11复制/粘贴</strong></p>

<p>// 回调设置某行被长按是否出现菜单栏</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置菜单栏是否显示哪些菜单栏选项</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>

<p>// 回调点击菜单栏选项触发的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/06/uicontrol/"/>
    <updated>2014-01-06T12:32:49+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/06/uicontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIControl的是控制对象,继承于UIView（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>），如传达用户意图的应用程序按钮和滑块的基类。你不能使用uicontrol的类直接实例化控件。相反，它定义了它的所有子类的通用接口和行为结构。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 控件默认是启用的。要禁用控件，可以将enabled属性设置为NO，这将导致控件忽略任何触摸事件。被禁用后，控件还可以用不同的方式显示自己，比如变成灰色不可用。虽然是由控件的子类完成的，这个属性却存在于UIControl中。</p>

<pre><code>BOOL enabled;
</code></pre>

<p>// 当用户选中控件时，UIControl类会将其selected属性设置为YES。子类有时使用这个属性来让控件选择自身，或者来表现不同的行为方式。</p>

<pre><code>BOOL selected;
</code></pre>

<p>//</p>

<pre><code>BOOL highlighted;
</code></pre>

<p>// 控件如何在垂直方向上布置自身的内容。默认是将内容顶端对其，对于文本字段，可能会改成UIControlContentVerticalAlignmentCenter。对于这个字段，可以使用下列诸值.</p>

<pre><code>UIControlContentVerticalAlignment contentVerticalAlignment;    

UIControlContentVerticalAlignmentCenter //居中
UIControlContentVerticalAlignmentTop    //居顶
UIControlContentVerticalAlignmentBottom // 居下
UIControlContentVerticalAlignmentFill   
</code></pre>

<p>// 控件如何在水平方向上布置自身的内容</p>

<pre><code>UIControlContentHorizontalAlignment contentHorizontalAlignment; 
</code></pre>

<p>// UIControl状态(只读)</p>

<pre><code>UIControlState state;
</code></pre>

<p>// 只读</p>

<pre><code>BOOL tracking;
</code></pre>

<p>// 是否touchInside（只读）</p>

<pre><code>BOOL touchInside; 
</code></pre>

<p>//</p>

<pre><code>- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;
- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;
- (void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;
- (void)cancelTrackingWithEvent:(UIEvent *)event;   // event may be nil if cancelled for non-event reasons, e.g. removed from window
</code></pre>

<p>// 事件通知。UIControl类提供了一个标准机制，来进行事件登记和接收。这令你可以指定你的控件在发生特定事件时，通知代理类的一个方法。如果要注册一个事件，可以使用addTarget方法：</p>

<pre><code>- (void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;
</code></pre>

<p>// 移除事件通知。要删除一个或多个事件的相应动作，可以使用UIControl类的removeTarget方法。使用nil值就可以将给定事件目标的所有动作删除</p>

<pre><code>- (void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;
</code></pre>

<p>// 取得关于一个控件所有指定动作的列表，可以使用allTargets方法。这个方法返回一个NSSet，其中包含事件的完整列表</p>

<pre><code>- (NSSet*)allTargets;
</code></pre>

<p>// 获取关于一个控件所有事件的列表</p>

<pre><code>- (UIControlEvents)allControlEvents;
</code></pre>

<p>// 获取针对某一特定事件目标的全部动作列表</p>

<pre><code>- (NSArray *)actionsForTarget:(id)target forControlEvent:(UIControlEvents)controlEvent;
</code></pre>

<p>//</p>

<pre><code>- (void)sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event;
</code></pre>

<p>// 如果设计了一个自定义控件类，可以使用sendActionsForControlEvent方法，为基本的UIControl事件或自己的自定义事件发送通知。例如，如果你的控件值正在发生变化，就可以发送相应通知，通过控件的代码可以指定时间目标，这个通知将被传播到这些指定的目标。</p>

<pre><code>- (void)sendActionsForControlEvents:(UIControlEvents)controlEvents;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIWebView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiwebview/"/>
    <updated>2014-01-05T12:32:39+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiwebview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIWebView是继承于UIView(有关UIView请参照<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>),在您的应用程序中，您可以使用UIWebView嵌入网页内容。要做到这一点，你只需创建一个UIWebView对象，将其附加到一个窗口，并发送一个请求来加载网页内容。您也可以使用此类前进和后退的网页的历史记录，甚至可以通过编程设置一些网页内容属性。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
4、iOS7新增
5、UIWebViewDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 设置代理</p>

<pre><code>id&lt;UIWebViewDelegate&gt; delegate;
</code></pre>

<p>//  加载一个url地址</p>

<pre><code>- (void)loadRequest:(NSURLRequest *)request;
</code></pre>

<p>// 加载一个html的string</p>

<pre><code>- (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL;
</code></pre>

<p>//</p>

<pre><code>- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>

<p>// 获取web的请求</p>

<pre><code>NSURLRequest *request;
</code></pre>

<p>// 重新加载</p>

<pre><code>- (void)reload; 
</code></pre>

<p>// 停止加载</p>

<pre><code>- (void)stopLoading;
</code></pre>

<p>// 返回</p>

<pre><code>- (void)goBack;
</code></pre>

<p>// 前进</p>

<pre><code>- (void)goForward;
</code></pre>

<p>// 是否能返回(只读)</p>

<pre><code>BOOL canGoBack;
</code></pre>

<p>// 是否能前进（只读)</p>

<pre><code>BOOL canGoForward;
</code></pre>

<p>// 是否正在加载（只读）</p>

<pre><code>BOOL loading;
</code></pre>

<p>// 添加javascript</p>

<pre><code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
</code></pre>

<p>// 默认值为NO，用户不可以放大或缩小页面；如果设置为YES，页面可以通过放大缩小去适应，用户也可以通过手势来放大和缩小</p>

<pre><code>BOOL scalesPageToFit;
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。</p>

<pre><code>BOOL detectsPhoneNumbers;
</code></pre>

<p>//  把网页上内容转换成可点击的链接类型</p>

<pre><code>UIDataDetectorTypes dataDetectorTypes;
</code></pre>

<p>// 这个值决定了用内嵌HTML5播放视频还是用本地的全屏控制。为了内嵌视频播放，不仅仅需要在这个页面上设置这个属性，还必须的是在HTML中的video元素必须包含webkit-playsinline属性。(iPhone默认为NO, iPad默认为YES)</p>

<pre><code>BOOL allowsInlineMediaPlayback;
</code></pre>

<p>// 在iPhone和iPad上默认使YES。这个值决定了HTML5视频可以自动播放还是需要用户去启动播放</p>

<pre><code>BOOL mediaPlaybackRequiresUserAction; 
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 获取webView中的scrollView(只读)</p>

<pre><code>UIScrollView *scrollView;
</code></pre>

<p>// 这个值决定了从这个页面是否可以Air Play(默认YES)</p>

<pre><code>BOOL mediaPlaybackAllowsAirPlay; 
</code></pre>

<p><strong>3、iOS6新增</strong></p>

<p>// 这个值决定了网页内容的渲染是否在把内容全部加载到内存中再去处理。如果设置为YES，只有网页内容加载到内存里了才会去渲染(默认值为NO)</p>

<pre><code>BOOL suppressesIncrementalRendering; 
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。(默认为YES)</p>

<pre><code>BOOL keyboardDisplayRequiresUserAction;
</code></pre>

<p><strong>4、iOS7新增</strong></p>

<p>// 随意翻阅模式</p>

<pre><code>UIWebPaginationMode paginationMode;
UIWebPaginationBreakingMode paginationBreakingMode;
CGFloat pageLength;
CGFloat gapBetweenPages;
</code></pre>

<p>当在原生应用中，使用 UIWebView 实现丰富内容时，或者对于原生 webapp，我们可以为了电子书阅读体验使用 Paginate （随意翻阅）特性，避免垂直滚动条（类似 Windows 8 应用体验）。如果应用显示动态内容，这一特性是完美的，我们不能预先优化分页。有不同的 Objective-C 属性配置分页过程。要启用它，需要这么做：</p>

<pre><code>myWebView.paginationMode = UIWebPaginationModeLeftToRight;
myWebView.paginationBreakingMode = UIWebPaginationBreakingModePage;
myWebView.gapBetweenPages = 50; 
</code></pre>

<p>// 获取页码总数(只读)</p>

<pre><code>NSUInteger pageCount;
</code></pre>

<p><strong>5、UIWebViewDelegate协议（可选）</strong></p>

<p>//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。</p>

<pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
</code></pre>

<p>// 开始加载的时候执行该方法。</p>

<pre><code>- (void)webViewDidStartLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载完成的时候执行该方法。</p>

<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载出错的时候执行该方法。</p>

<pre><code>- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISearchBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uisearchbar/"/>
    <updated>2014-01-05T12:32:30+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uisearchbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong>
UISearchBar类实现一个文本字段控制基于文本的搜索，它是继承于UIView(有关UIView的介绍请到<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>)。控制输入文字，一个搜索按钮，书签按钮和取消按钮提供了一个文本字段。该对象的UISearchBar实际上并不执行任何搜查。您可以使用委托符合UISearchBarDelegate协议对象，实现这些输入文字和点击按钮的事件。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性和方法
2、iOS5新增
3、iOS7新增
4、UISearchBarDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性和方法</strong></p>

<p>// 设置控件样式（默认UIBarStyleDefault）</p>

<pre><code>UIBarStyle              barStyle;              
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UISearchBarDelegate&gt; delegate;              
</code></pre>

<p>// 控件上面显示的文字</p>

<pre><code>NSString               *text;                  
</code></pre>

<p>// 显示在顶部的单行文字，通常作为一个提示行</p>

<pre><code>NSString               *prompt;                
</code></pre>

<p>// 半透明的提示文字，输入搜索内容会消失</p>

<pre><code>NSString               *placeholder;           
</code></pre>

<p>// 是否在控件的右端显示一个书的按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsBookmarkButton;   
</code></pre>

<p>// 是否显示cancel按钮</p>

<pre><code>BOOL                    showsCancelButton; 
- (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated;    
</code></pre>

<p>// 是否在控件的右端显示搜索结果按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsSearchResultsButton; 
</code></pre>

<p>// 搜索结果按钮是否被选中</p>

<pre><code>BOOL searchResultsButtonSelected; 
</code></pre>

<p>// bar的颜色(具有渐变效果)</p>

<pre><code>UIColor *tintColor;
UIColor *barTintColor(iOS7.0);

UISearchBarStyle searchBarStyle (iOS7.0);
</code></pre>

<p> // 指定控件是否会有透明效果</p>

<pre><code>BOOL translucent;
</code></pre>

<p>// 设置在什么情况下自动大写（默认UITextAutocapitalizationTypeNone）</p>

<pre><code>UITextAutocapitalizationType autocapitalizationType;  
</code></pre>

<p>// 对于文本对象自动校正风格 （默认UITextAutocorrectionTypeDefault）</p>

<pre><code>UITextAutocorrectionType     autocorrectionType;      
</code></pre>

<p>//  （默认UITextSpellCheckingTypeDefault）</p>

<pre><code>UITextSpellCheckingType      spellCheckingType;       
</code></pre>

<p>// 键盘样式 （默认UIKeyboardTypeDefault）</p>

<pre><code>UIKeyboardType               keyboardType;            
</code></pre>

<p>// 搜索栏下部的选择栏，数组里面的内容是按钮的标题</p>

<pre><code>NSArray   *scopeButtonTitles;
</code></pre>

<p>// 搜索栏下部的选择栏按钮的个数</p>

<pre><code>NSInteger  selectedScopeButtonIndex; 
</code></pre>

<p>// 控制搜索栏下部的选择栏是否显示出来</p>

<pre><code>BOOL       showsScopeBar; 
</code></pre>

<p>// 提供一个遮盖视图</p>

<pre><code>UIView *inputAccessoryView;
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 设置背景图片</p>

<pre><code>UIImage *backgroundImage;
</code></pre>

<p>// 设置scope的背景颜色</p>

<pre><code>UIImage *scopeBarBackgroundImage;


- (void)setSearchFieldBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state;
- (UIImage *)searchFieldBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下search的ico图片</p>

<pre><code>- (void)setImage:(UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 获取某个状态下的ico图片</p>

<pre><code>- (UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下scopeBarButton的背景图片</p>

<pre><code>- (void)setScopeBarButtonBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; 
</code></pre>

<p>// 获取某个状态下scopeBarButton的背景图片</p>

<pre><code>- (UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
- (UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
- (NSDictionary *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchFieldBackgroundPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchTextPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>- (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon;
- (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon;
</code></pre>

<p><strong>3、iOS7新增</strong></p>

<p>//</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;  
</code></pre>

<p>//</p>

<pre><code>- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p><strong>4、UISearchBarDelegate协议（可选）</strong></p>

<p>// 是否允许编辑，如果返回为NO则不能成为第一响应者</p>

<pre><code>- (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar;                      
</code></pre>

<p>// 开始编辑</p>

<pre><code>- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar;                     
</code></pre>

<p>// 是否允许结束编辑</p>

<pre><code>- (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar;                        
</code></pre>

<p>// 结束编辑</p>

<pre><code>- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar;                       
</code></pre>

<p>// 文本内容改变时调用</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText;   
</code></pre>

<p>// 如果允许继续输入，那么返回YES，否则返回NO。（可以对字数进行限制）</p>

<pre><code>- (BOOL)searchBar:(UISearchBar *)searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text; 
</code></pre>

<p>// 当搜索按钮被点击的时候</p>

<pre><code>- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar;                     
</code></pre>

<p>//</p>

<pre><code>- (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar;                   
</code></pre>

<p>// cancel按钮点击时调用</p>

<pre><code>- (void)searchBarCancelButtonClicked:(UISearchBar *) searchBar;                    
</code></pre>

<p>// ResultsList按钮被点击时调用</p>

<pre><code>- (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar; 
</code></pre>

<p>// 还有一个很重要的事情，设了按钮就要给他们安排功能。所以说，我们要实现这个代理UISearchBarDelegate里的这个方法searchBar:selectedScopeButtonIndexDidChange:告诉表格，你选择的范围是啥。</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIScrollView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiscrollview/"/>
    <updated>2014-01-05T12:32:18+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiscrollview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIScrollView控制继承于UIView(有关UIView的介绍请到<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>),该UIScrollView的类提供了用于显示的内容比应用程序的窗口的大小支持。它使用户能够通过使刷卡手势内容中滚动，并从内容部分通过使捏的手势和背部放大。</p>

<p>UIScrollView的是几个UIKit类包括的UITableView和UITextView中的超类。</p>

<p>一个UIScrollView对象（或者，简单地说，一个滚动视图）的核心概念是，它是一个视图，其起源是可调过的内容视图。它剪辑的内容，它的框架，这通常（但不一定）恰逢该应用程序的主窗口。滚动视图跟踪手指的变动，并相应调整原点。这正显示出它的内容“，通过”滚动视图的视图绘制的基础上，新的原点，它被固定在内容视图的偏移部分本身。滚动视图本身没有绘制，除了显示垂直和水平滚动的指标。滚动视图必须知道的内容视图的大小，所以它知道何时停止滚动，默认情况下，它“反弹”回来时，滚动超出了内容的范围。</p>

<!--more-->


<p>用于管理内容的绘制有关的对象显示在一个滚动视图应该瓦片的内容的子视图，以便没有视图超过屏幕的大小。当用户在滚动滚动视图，这个对象应该添加和删除子视图是必要的。</p>

<p>由于滚动视图没有滚动条，它必须知道是否触摸信号的意图与滚动意图在内容跟踪一个子视图。做出此决定，它暂时拦截触摸按下事件通过启动一个定时器，并在定时器触发之前，看是否触摸手指做任何运动。如果定时器触发无位置显著的变化，滚动视图将跟踪事件的内容视图的感动子视图。然后，如果用户在定时器期满前拉着自己的手指远远不够，滚动视图将取消任何跟踪的子视图，并进行滚动本身。子类可以重写touchesShouldBegin ： withEvent：方法inContentView ：,pagingEnabled和touchesShouldCancelInContentView ：方法（这是由滚动视图调用）来影响滚动视图如何处理滚动手势。</p>

<p>滚动视图还处理缩放和平移的内容。当用户使一个夹在或向外挤压手势，滚动视图调整偏移量和内容的标度。当手势结束，管理内容视图中的对象应该要更新的内容为必要的子视图。 （请注意，手势可以结束和手指仍可能下跌。 ）虽然手势正在进行中，滚动视图不发送任何跟踪调用子视图。</p>

<p>该UIScrollView的类可以有必须采取UIScrollViewDelegate协议的委托。对于缩放和平移工作，委托必须实现viewForZoomingInScrollView ：和scrollViewDidEndZooming ： withView ： atScale ： ，此外，最大（ maximumZoomScale ）和最小（ minimumZoomScale ）变焦倍数必须是不同的。</p>

<p><strong>目录</strong></p>

<p>// 监控目前滚动的位置(默认CGPointZero)</p>

<pre><code>CGPoint                      contentOffset; 
- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;
</code></pre>

<p>// 滚动范围的大小(默认CGSizeZero)</p>

<pre><code>CGSize                       contentSize; 
</code></pre>

<p>// 视图在scrollView中的位置(UIEdgeInsetsZero)</p>

<pre><code>UIEdgeInsets                 contentInset;                   
</code></pre>

<p>// 设置协议</p>

<pre><code>id&lt;UIScrollViewDelegate&gt;      delegate;                       
</code></pre>

<p>// 指定控件是否只能在一个方向上滚动(默认为NO)</p>

<pre><code>BOOL directionalLockEnabled;         
</code></pre>

<p>// 控制控件遇到边框是否反弹(默认为YES)</p>

<pre><code>BOOL                         bounces;                        
</code></pre>

<p>// 控制垂直方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceVertical;           
</code></pre>

<p>// 控制水平方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceHorizontal;         
</code></pre>

<p>// 控制控件是否整页翻动(默认为NO)</p>

<pre><code>BOOL          pagingEnabled;                  
</code></pre>

<p>// 控制控件是否能滚动</p>

<pre><code>BOOL          scrollEnabled;                  
</code></pre>

<p>// 控制是否显示水平方向的滚动条</p>

<pre><code>BOOL                         showsHorizontalScrollIndicator; 
</code></pre>

<p>// 控制是否显示垂直方向的滚动条</p>

<pre><code>BOOL                         showsVerticalScrollIndicator;   
</code></pre>

<p>// 指定滚动条在scrollerView中的位置</p>

<pre><code>UIEdgeInsets                 scrollIndicatorInsets;          
</code></pre>

<p>// 设定滚动条的样式</p>

<pre><code>UIScrollViewIndicatorStyle   indicatorStyle;                 
</code></pre>

<p>// 改变scrollerView的减速点位置</p>

<pre><code>CGFloat                      decelerationRate;
</code></pre>

<p>// UITableView 在EnablePage状态下滚动到指定的页面上</p>

<pre><code>- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>//  这个很有用，闪一下滚动条，暗示是否有可滚动的内容。可以在ViewDidAppear或[table reload]之后调用。</p>

<pre><code>- (void)flashScrollIndicators; 
</code></pre>

<p>// 监控当前目标是否正在被跟踪(只读)</p>

<pre><code>BOOL tracking;
</code></pre>

<p>//  监控当前目标是否正在被拖拽(只读)</p>

<pre><code>BOOL dragging;
</code></pre>

<p>// 监控当前目标是否正在减速(只读)</p>

<pre><code>BOOL decelerating;    
</code></pre>

<p>// 控制视图是否延时调用开始滚动的方法</p>

<pre><code>BOOL delaysContentTouches;       
</code></pre>

<p>// 控制控件是否接触取消touch的事件</p>

<pre><code>BOOL canCancelContentTouches;
</code></pre>

<p>//返回yes 是不滚动 scroll 返回no 是滚动scroll</p>

<pre><code>- (BOOL)touchesShouldBegin:(NSSet *)touches withEvent:(UIEvent *)event inContentView:(UIView *)view;
</code></pre>

<p>//NO scroll不可以滚动 YES scroll可以滚动</p>

<pre><code>- (BOOL)touchesShouldCancelInContentView:(UIView *)view;
</code></pre>

<p>// 缩小的最小比例</p>

<pre><code>CGFloat minimumZoomScale;     
</code></pre>

<p>// 放大的最大比例</p>

<pre><code>CGFloat maximumZoomScale;     
</code></pre>

<p>// 设置变化比例</p>

<pre><code>CGFloat zoomScale;  
- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated;
</code></pre>

<p>//  设置变化范围</p>

<pre><code>- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>// 控制缩放的时候是否会反弹</p>

<pre><code>BOOL  bouncesZoom;
</code></pre>

<p>// 判断控件的大小是否正在改变(只读)</p>

<pre><code>BOOL zooming;
</code></pre>

<p>// 判断是否正在进行缩放反弹(只读)</p>

<pre><code>BOOL zoomBouncing;
</code></pre>

<p>// 控制控件滚动到顶部</p>

<pre><code>BOOL  scrollsToTop;
</code></pre>

<p>// Use these accessors to configure the scroll view&rsquo;s built-in gesture recognizers.
// Do not change the gestures&#8217; delegates or override the getters for these properties.
// 只读</p>

<pre><code>UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);
</code></pre>

<p>// <code>pinchGestureRecognizer</code> will return nil when zooming is disabled.
// 只读</p>

<pre><code>UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);

UIScrollViewKeyboardDismissMode keyboardDismissMode NS_AVAILABLE_IOS(7_0); // default is UIScrollViewKeyboardDismissModeNone
</code></pre>

<p>@end</p>

<p>UIScrollViewDelegate协议（可选）</p>

<p>//只要滚动了就会触发</p>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView;
</code></pre>

<p>// 当scrollview发生缩放的时相应</p>

<pre><code>- (void)scrollViewDidZoom:(UIScrollView *)scrollView;
</code></pre>

<p>// 将要拖拽视图</p>

<pre><code>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;
</code></pre>

<p>// 开始拖拽视图</p>

<pre><code>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset;
</code></pre>

<p>// 完成拖拽</p>

<pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;
</code></pre>

<p>// 将开始降速时</p>

<pre><code>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;   
</code></pre>

<p>// 减速停止了时执行</p>

<pre><code>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;      
</code></pre>

<p>// 滚动动画停止时执行,代码改变时出发,也就是setContentOffset改变时</p>

<pre><code>- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; 
</code></pre>

<p>// 设置放大缩小的视图，要是uiscrollview的subview</p>

<pre><code>- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;     
</code></pre>

<p>// 当scrollview将要发生缩放的时相应</p>

<pre><code>- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view; 
</code></pre>

<p>// 完成放大缩小时调用</p>

<pre><code>- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale; 
</code></pre>

<p>// //如果你不是完全滚动到滚轴视图的顶部，你可以轻点状态栏，那个可视的滚轴视图会一直滚动到顶部，那是默认行为，你可以通过该方法返回NO来关闭它 。点击状态栏，scroll view回到顶部，如果想实现这个，实现代理方法scrollViewShouldScrollToTop返回YES，当完成时，给代理发送scrollViewDidScrollToTop: 消息</p>

<pre><code>- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;   
- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIAlertView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uialertview/"/>
    <updated>2014-01-05T12:32:06+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uialertview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>使用UIAlertView类显示一个警告信息给用户。警报视图的功能类似，但不同的外观在一个动作片（ UIActionSheet的一个实例）。UIAlertView继承于UIView(有关UIView的介绍请到<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>)。</p>

<p>使用定义的属性和方法在这个类来设置标题，消息和警报视图的委托和配置按钮。你必须设置一个委托，如果你添加自定义按钮。委托应符合UIAlertViewDelegate协议。使用show方法来显示一个警报视图，一旦它被配置。</p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 初始化UIAlertView</p>

<pre><code>- (id)initWithTitle:(NSString *)title message:(NSString *)message delegate:(id &lt;UIAlertViewDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UIAlertViewDelegate&gt; delegate;
</code></pre>

<p>// 设置title</p>

<pre><code>NSString *title;
</code></pre>

<p>// 显示的消息文本文字</p>

<pre><code>NSString *message;
</code></pre>

<p>// 添加一个Button到AlertView并且指定按钮显示的文字，并且返回它的索引(从0开始，cancelButton的索引是0)</p>

<pre><code>- (NSInteger)addButtonWithTitle:(NSString *)title; 
</code></pre>

<p>// 通过下标获取button的title</p>

<pre><code>- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// button的总数(只读)</p>

<pre><code>NSInteger numberOfButtons;
</code></pre>

<p>// 取消按钮的下标</p>

<pre><code>NSInteger cancelButtonIndex;
</code></pre>

<p>// 第一个其他button的下标(只读)</p>

<pre><code>NSInteger firstOtherButtonIndex;
</code></pre>

<p>// 是否显示了(只读)</p>

<pre><code>BOOL visible;
</code></pre>

<p>// 动画显示alert.</p>

<pre><code>- (void)show;
</code></pre>

<p>// 隐藏按下指定索引值的按钮之后，隐藏AlertView，并制定是否启动动画效果</p>

<pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre>

<p>// 设置alertView样式（iOS5.0）</p>

<pre><code>UIAlertViewStyle alertViewStyle;
</code></pre>

<p>// 返回指定索引值的TextField ，这个API仅存在于IOS5.0以上</p>

<pre><code>- (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex;
</code></pre>

<p>UIAlertViewDelegate协议（可选）</p>

<p>// 当一个指定索引的按钮被点击的时候，回调此方法，buttonIndex是按钮的索引值，从0开始</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 当用户按下HOME键的时候，回调此方法，用户点击Cancel按钮的时候不会回调此方法</p>

<pre><code>- (void)alertViewCancel:(UIAlertView *)alertView;
</code></pre>

<p>// 开始显示View的动画之前进行回调</p>

<pre><code>- (void)willPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 显示动画完成之后进行回调</p>

<pre><code>- (void)didPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 将要开始View隐藏动画的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 
</code></pre>

<p>// 当View的隐藏动画结束的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 编辑任何默认的字段添加的风格之后调用</p>

<pre><code>- (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIActionSheet详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiactionsheet/"/>
    <updated>2014-01-05T12:31:54+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiactionsheet</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIActionSheet继承于UIView（有关UIView的介绍请到<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>）。使用UIActionSheet类有一组关于如何进行给定任务的备选方案呈现给用户。也可以使用动作表，以提示用户进行确认，有潜在危险的动作。动作片包含一个可选的标题和一个或多个按钮，其中每一个对应于要采取的动作。</p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 初始化UIActionSheet上的button按钮</p>

<pre><code>- (id)initWithTitle:(NSString *)title delegate:(id&lt;UIActionSheetDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle destructiveButtonTitle:(NSString *)destructiveButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;
</code></pre>

<p>// 设置UIActionSheet代理</p>

<pre><code>id&lt;UIActionSheetDelegate&gt; delegate;    // weak reference
</code></pre>

<p>// 设置UIActionSheet的title</p>

<pre><code>NSString *title;
</code></pre>

<p>// 设置UIActionSheet的样式（默认为UIActionSheetStyleAutomatic）</p>

<pre><code>UIActionSheetStyle actionSheetStyle;
</code></pre>

<p>// 通过按钮的title获取这个按钮在UIActionSheet上的下标</p>

<pre><code>- (NSInteger)addButtonWithTitle:(NSString *)title;
</code></pre>

<p>// 通过下标获得按钮的title</p>

<pre><code>- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 获取按钮的总个数(只读)</p>

<pre><code>NSInteger numberOfButtons;
</code></pre>

<p>// 获取取消按钮的下标</p>

<pre><code>NSInteger cancelButtonIndex;
</code></pre>

<p>// 红色按钮的下标（翻译成破坏性的，其实就是那个红色的按钮）</p>

<pre><code>NSInteger destructiveButtonIndex;
</code></pre>

<p>// 获取第一个其他按钮的下标(只读)</p>

<pre><code>NSInteger firstOtherButtonIndex;
</code></pre>

<p>// UIActionSheet是否可见（只读）</p>

<pre><code>BOOL visible;
</code></pre>

<p>// show a sheet animated. you can specify either a toolbar, a tab bar, a bar butto item or a plain view. We do a special animation if the sheet rises from
// a toolbar, tab bar or bar button item and we will automatically select the correct style based on the bar style. if not from a bar, we use
// UIActionSheetStyleDefault if automatic style set
// 如果要将ActonSheet 与工具栏或者标签栏对齐，可以使用showFromToolBar(showFromTabBar)</p>

<pre><code>- (void)showFromToolbar:(UIToolbar *)view;
- (void)showFromTabBar:(UITabBar *)view;
</code></pre>

<p>// showFromBarButtonItem，就是popover会指向个BarButtonItem。在iPhone上只能使用showInView，如果是universal app，要用些if来判断。用delegate来知道用户选择了什么</p>

<pre><code>- (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>// showFromRect，在ipad上指定个矩形区域，它会在其上显示个popover</p>

<pre><code>- (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;
</code></pre>

<p>// 显示在iphone的中间位置，它会从下往上滑动；在ipad上它会放在中间，所以在ipad上从不用showInView</p>

<pre><code>- (void)showInView:(UIView *)view;
</code></pre>

<p>// hides alert sheet or popup. use this method when you need to explicitly dismiss the alert.
// it does not need to be called if the user presses on a button</p>

<pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre>

<p>UIActionSheetDelegate协议（可选）</p>

<p>// 点击UIActionSheet会调用的函数，buttonIndex为所点击button在UIActionSheet的下标</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 点击取消按钮会调用的函数</p>

<pre><code>- (void)actionSheetCancel:(UIActionSheet *)actionSheet;
</code></pre>

<p>// 将来显示ActionSheet</p>

<pre><code>- (void)willPresentActionSheet:(UIActionSheet *)actionSheet;
</code></pre>

<p>// 显示ActionSheet</p>

<pre><code>- (void)didPresentActionSheet:(UIActionSheet *)actionSheet;
</code></pre>

<p>// ActionSheet将要消失</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// ActionSheet消失</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITableViewCell详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uitableviewcell/"/>
    <updated>2014-01-04T12:31:43+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uitableviewcell</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UITableViewCell继承于UIView（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>）,UITableViewCell类定义出现在UITableView中对象的单元格的属性和行为。这个类包含的属性和设置和管理的单元格内容和背景（包括文字，图片，和自定义视图） ，管理小区选择并高亮显示状态，管理配套的看法，以及发起的单元格内容的编辑方法。</p>

<p>当创建单元格，你可以自己自定义它们，或者使用几个预定义样式之一。预定义的单元格样式是最简单的选择。与预定义样式，单元格提供标签和图像子视图的位置和造型是固定的。所有您需要做的是提供文本和图像内容进入那些固定的看法。要使用单元格与预定义的风格，采用了initWithStyle初始化： reuseIdentifier ：方法或将单元配置与风格在Xcode 。要设置单元格的文本和图像，使用为textLabel ， detailTextLabel和ImageView的属性。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化方法</p>

<pre><code>- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier;
</code></pre>

<p>// cell上默认图片显示view，（默认为nil,当需要的时候才会被创建）</p>

<pre><code>UIImageView *imageView;
</code></pre>

<p>// cell上默认的UILabel(默认为nil，当需要的时候才会被创建)</p>

<pre><code>UILabel     *textLabel;
</code></pre>

<p>//  cell简介（默认为nil，如果当前的style支持的话需要时将会被创建）</p>

<pre><code>UILabel     *detailTextLabel;
</code></pre>

<p>// 与cell自带的删除按钮平级的view</p>

<pre><code>UIView *contentView;
</code></pre>

<p>// 背景view</p>

<pre><code>UIView *backgroundView;
</code></pre>

<p>// 多选时的背景view</p>

<pre><code>UIView *multipleSelectionBackgroundView;
</code></pre>

<p>// cell的标识符</p>

<pre><code>NSString *reuseIdentifier;
</code></pre>

<p>//  重用cell时会调用这个函数</p>

<pre><code>- (void)prepareForReuse; 
</code></pre>

<p>// 选中时的cell样式（默认为UITableViewCellSelectionStyleBlue）</p>

<pre><code>UITableViewCellSelectionStyle   selectionStyle; 
</code></pre>

<p>// 是否选中</p>

<pre><code>BOOL         selected; 
</code></pre>

<p>// 是否高亮</p>

<pre><code>BOOL      highlighted;
</code></pre>

<p>// 设置cell为选中状态</p>

<pre><code>- (void)setSelected:(BOOL)selected animated:(BOOL)animated;                  
</code></pre>

<p>// 设置为高亮状态</p>

<pre><code>- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
</code></pre>

<p>// 设置cell的编辑样式</p>

<pre><code>UITableViewCellEditingStyle editingStyle;
</code></pre>

<p>// showsReorderControl = YES时Cell显示移动按钮（默认为NO）</p>

<pre><code>BOOL showsReorderControl;        // default is NO
</code></pre>

<p>// 没有出现delete控件和行头控件，可cell的宽度还是变了，有没有办法使cell在edit模式下，宽度不改变</p>

<pre><code>BOOL shouldIndentWhileEditing;
</code></pre>

<p>// 设置cell的样式</p>

<pre><code>UITableViewCellAccessoryType accessoryType;
</code></pre>

<p>UITableViewCellAccessoryNone;//cell没有任何的样式</p>

<p>UITableViewCellAccessoryDisclosureIndicator;//cell的右边有一个小箭头，距离右边有十几像素；</p>

<p>UITableViewCellAccessoryDetailDisclosureButton;//cell右边有一个蓝色的圆形button；</p>

<p>UITableViewCellAccessoryCheckmark;//cell右边的形状是对号；</p>

<p>// 除此上面之外，如果你想使用自定义附件按钮的其他样式，必需使用UITableView的accessoryView属性</p>

<pre><code>UIView *accessoryView;
</code></pre>

<p>// 设置当cell进入编辑模式时的辅助按钮样式</p>

<pre><code>UITableViewCellAccessoryType editingAccessoryType;
</code></pre>

<p>// 自定义cell进入编辑模式后辅助按钮</p>

<pre><code>UIView *editingAccessoryView;       
</code></pre>

<p>// 获取cell的缩进级别</p>

<pre><code>NSInteger indentationLevel;           
</code></pre>

<p>// 获取cell的缩进宽度</p>

<pre><code>CGFloat indentationWidth;
</code></pre>

<p>// 设置是否处于编辑模式</p>

<pre><code>BOOL           editing;
</code></pre>

<p>// 设置编辑模式</p>

<pre><code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<p>// 当前是否显示delete按钮</p>

<pre><code>BOOL showingDeleteConfirmation;  // currently showing "Delete" button
</code></pre>

<p>// 这两个方法应该在子类中覆写，当前Cell的状态发生改变的时刻就会触发这些方法，可以在这些方法中进行一些额外的操作。（例如：cell被点击以后就会进入UITableViewCellStateShowingDeleteConfirmationMask 状态）</p>

<pre><code>- (void)willTransitionToState:(UITableViewCellStateMask)state;
- (void)didTransitionToState:(UITableViewCellStateMask)state;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UINavigaionBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uinavigaionbar/"/>
    <updated>2014-01-04T12:31:24+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uinavigaionbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>在UINavigationBar的类提供了用于导航的分层内容的控制,UINavigaionBar继承于UIView(有关UIView请参照<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>。这是一间酒吧，通常显示在屏幕的顶部，包含按钮画面的层次结构中导航。主要属性是一个左（后）按钮，一个中心的标题，和一个可选的右按钮。可以使用一个导航栏作为一个独立的对象，或与导航控制器对象来使用。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UINavigaionBar
2、UINavigationItem
3、iOS5新增
</code></pre>

<p><strong>1、UINavigaionBar</strong></p>

<p>// 设置bar的样式</p>

<pre><code>UIBarStyle barStyle;
</code></pre>

<p>// 设置代理</p>

<pre><code>id delegate;
</code></pre>

<p>// 设置是否透明（在iOS6中默认为NO,如果barStyle为UIBarStyleBlackTranslucent为YES）</p>

<pre><code>BOOL translucent;
</code></pre>

<p>// Pushing a navigation item displays the item&rsquo;s title in the center of the navigation bar.
// 方法将新的UINavigationItem 压入栈</p>

<pre><code>- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;
</code></pre>

<p>//  方法将顶部的UINavigationItem 推出栈</p>

<pre><code>- (UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; // Returns the item that was popped.
</code></pre>

<p>// 获取顶部的item（只读）</p>

<pre><code>UINavigationItem *topItem;
</code></pre>

<p>// 获取返回的item</p>

<pre><code>UINavigationItem *backItem;
</code></pre>

<p>// 设置items组</p>

<pre><code>NSArray *items;
- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 设置背景颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 设置背影颜色（iOS7.0新增）</p>

<pre><code>UIColor *barTintColor;
</code></pre>

<p>iOS5新增</p>

<p>//  根据屏幕状态设置背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics;

如果支持竖屏，那么应该设置UIBarMetricsDefault
[navBar setBackgroundImage:[UIImage imageNamed:@"navBarBg.png"] forBarMetrics:UIBarMetricsDefault];

如果支持横屏，那么应该设置UIBarMetricsLandscapePhone
[navBar setBackgroundImage:[UIImage imageNamed:@"navBarBg.png"] forBarMetrics:UIBarMetricsLandscapePhone];
</code></pre>

<p>// 根据屏幕状态获取背景图片</p>

<pre><code>- (UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 对titleText设置字体属性</p>

<pre><code>NSDictionary *titleTextAttributes;
</code></pre>

<p>// 根据屏幕状态设置标题的垂直偏移量</p>

<pre><code>- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 根据屏幕状态获得标题的垂直偏移量</p>

<pre><code>- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>iOS6新增</p>

<p>// 设置阴影图片</p>

<pre><code> UIImage *shadowImage;
</code></pre>

<p>iOS7新增</p>

<p>// iOS7下设置背景图片(iOS上默认是64，可以通过这个方法设置成44)。</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 获取图片</p>

<pre><code>- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 如果想要用自己的图片替换V型，可以设置图片的backIndicatorImage backIndicatorTransitionMaskImage。</p>

<pre><code>UIImage *backIndicatorImage;
UIImage *backIndicatorTransitionMaskImage;

如下代码所示：
[[UINavigationBar appearance] setBackIndicatorImage:[UIImage imageNamed:@"backBtton.png"]]; 
[[UINavigationBar appearance] setBackIndicatorTransitionMaskImage:[UIImage imageNamed:@"backBtton.png"]]; 
</code></pre>

<p>UINavigationBarDelegate协议（可选）
// 是否支持pushItem，如果返回NO就不能。</p>

<pre><code>- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item;
</code></pre>

<p>// pushItem时会调用的函数</p>

<pre><code>- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item;
</code></pre>

<p>// 是否支持popItem，如果返回NO就不能。</p>

<pre><code>- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item;
</code></pre>

<p>// popItem时会调用的函数</p>

<pre><code>- (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item;
</code></pre>

<p><strong>2、UINavigationItem</strong></p>

<p>// 初始化item的title</p>

<pre><code>- (id)initWithTitle:(NSString *)title;
</code></pre>

<p>// 设置item的title</p>

<pre><code>NSString        *title; 
</code></pre>

<p>// 设置返回barButtonItem</p>

<pre><code>UIBarButtonItem *backBarButtonItem;
</code></pre>

<p>// 设置titleView</p>

<pre><code>UIView          *titleView;
</code></pre>

<p>// 一个显示在顶部导航栏的单行文本</p>

<pre><code>NSString *prompt;    
</code></pre>

<p>// 是否隐藏返回按钮</p>

<pre><code>BOOL hidesBackButton; 
</code></pre>

<p>// 隐藏返回按钮</p>

<pre><code>- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated;
</code></pre>

<p>// 设置左边按钮</p>

<pre><code>UIBarButtonItem *leftBarButtonItem;
- (void)setLeftBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>// 设置右边按钮</p>

<pre><code>UIBarButtonItem *rightBarButtonItem;
- (void)setRightBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p><strong>3、iOS5新增</strong></p>

<pre><code>NSArray *leftBarButtonItems;
NSArray *rightBarButtonItems;
- (void)setLeftBarButtonItems:(NSArray *)items animated:(BOOL)animated; 
- (void)setRightBarButtonItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 当某个UIViewController自定义了LeftBarButtonItem(如：返回首页的Home按钮)，同时这个UIViewController存在被其他UIViewController，pushViewController(即：从其他试图控制器，跳转到自定义LeftBarButtonItem的试图控制器),这时如果没有在自定义LeftBarButtonItem设置UINavigationItem的属性leftItemsSupplementBackButton，那么系统会默认为NO，那麽其他控制器跳转到此控制器时，导航栏就只会展示你自定的LeftBarButtonItem，而不会显示后退按钮。但这样很不友好。如果想显示后退按钮，这在自定义LeftBarButtonItem时，设置UINavigationItem的属性leftItemsSupplementBackButton为YES即可。</p>

<pre><code>BOOL leftItemsSupplementBackButton;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIToolBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uitoolbar/"/>
    <updated>2014-01-03T12:31:14+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uitoolbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIToolBar是显示一个或多个按钮，称为工具栏项的控件，继承于UIView(有关UIView请参照<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>。工具栏瞬间突出或挖掘时，不改变项目的外观。</p>

<p>要创建工具栏项，使用的UIBarButtonItem类。到工具栏项添加到工具栏，使用setItems ：动画：方法。</p>

<p>代表项目的正常和高亮状态工具栏图像从你设置使用继承的图像属性从UIBarItem类的形象派生。在iOS系统7.0 ，图像是彩色的工具栏的tintColor。</p>

<p>如果您需要单选按钮式控制，使用UITabBar类而不是UIToolbar。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UIToolBar的基本属性及方法
2、iOS5.0新增
3、iOS6.0新增
4、iOS7.0新增
5、UIToolbar协议
</code></pre>

<p><strong>1、UIToolBar的基本属性及方法</strong></p>

<p>// UIToolBar的样式 （默认为blue）</p>

<pre><code>UIBarStyle barStyle;
</code></pre>

<p>// 设置tooBar的选项</p>

<pre><code>NSArray   *items;
</code></pre>

<p>// 设置上面的一层view是否半透明</p>

<pre><code>BOOL translucent;
</code></pre>

<p>//</p>

<pre><code>- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 背景颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>2、iOS5.0新增</p>

<p>// 背景图片设置</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>//</p>

<pre><code>- (UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>3、iOS6.0新增</p>

<p>// 设置ToolBar上边沿的阴影</p>

<pre><code>- (void)setShadowImage:(UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom;
- (UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom;
</code></pre>

<p>4、iOS7.0新增</p>

<p>// 设置背景颜色</p>

<pre><code>UIColor *barTintColor;
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UIToolbarDelegate&gt; delegate;
</code></pre>

<p><strong>5、UIToolbar协议</strong></p>

<p>目前还没有协议</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITabBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uitabbar/"/>
    <updated>2014-01-03T12:31:06+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uitabbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UITabBar作为一个标签栏控制，它继承于UIView(有关UIView请参照<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>,也就是说UITabBar本身是一个视图控件。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UITabBar基本属性及方法
2、iOS5.0新增
3、iOS6.0新增
4、iOS7.0新增
5、UITabBarDelegate协议（可选）
</code></pre>

<p><strong>1、UITabBar基本属性及方法</strong></p>

<p>// 设置UITabBar的代理</p>

<pre><code>id&lt;UITabBarDelegate&gt; delegate;
</code></pre>

<p>//  设置UITabBar的选项值</p>

<pre><code>NSArray  *items;
</code></pre>

<p>//  设置UITabBar选中的item</p>

<pre><code>UITabBarItem *selectedItem; 
</code></pre>

<p>// 是否动画添加item（冒似没有效果）</p>

<pre><code>- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 定制化items</p>

<pre><code>- (void)beginCustomizingItems:(NSArray *)items;
</code></pre>

<p>// 结束定制化动画</p>

<pre><code>- (BOOL)endCustomizingAnimated:(BOOL)animated;
</code></pre>

<p>// 是否定制化</p>

<pre><code>- (BOOL)isCustomizing;
</code></pre>

<p><strong>2、iOS5.0新增</strong></p>

<p>// 改变UITabBar的着色(直接通过back背景颜色)</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 选中时背景颜色</p>

<pre><code>UIColor *selectedImageTintColor;
</code></pre>

<p>// 背景图片</p>

<pre><code>UIImage *backgroundImage;
</code></pre>

<p>// 选中的item的背景图片</p>

<pre><code>UIImage *selectionIndicatorImage; 
</code></pre>

<p><strong>3、iOS6.0新增</strong></p>

<pre><code>UIImage *shadowImage;
</code></pre>

<p><strong>4、iOS7.0新增 </strong></p>

<pre><code>UIColor *barTintColor;

UITabBarItemPositioning itemPositioning;

CGFloat itemWidth;


CGFloat itemSpacing;

UIBarStyle barStyle;

BOOL translucent;
</code></pre>

<p><strong>5、UITabBarDelegate协议（可选）</strong></p>

<pre><code>- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item;

- (void)tabBar:(UITabBar *)tabBar willBeginCustomizingItems:(NSArray *)items; 

- (void)tabBar:(UITabBar *)tabBar didBeginCustomizingItems:(NSArray *)items;
- (void)tabBar:(UITabBar *)tabBar willEndCustomizingItems:(NSArray *)items changed:(BOOL)changed;

- (void)tabBar:(UITabBar *)tabBar didEndCustomizingItems:(NSArray *)items changed:(BOOL)changed;  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIImageView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uiimageview/"/>
    <updated>2014-01-03T12:30:58+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uiimageview</id>
    <content type="html"><![CDATA[<p><strong>引导</strong></p>

<p>图像视图对象提供了用于显示一个单一的图像或动画的一系列图像的基于视图的容器。对于图像动画， UIImageView类提供控件设置动画的持续时间和频率。UIImageView继承于UIView（有关UIControl请参照<a href="http://beyondabel.github.io/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>）。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性
2、动画图片相关
3、iOS7新增
</code></pre>

<p><strong>1、基本属性</strong></p>

<p>// 初始化UIImageView展示的图片资源</p>

<pre><code>- (id)initWithImage:(UIImage *)image;
</code></pre>

<p>// 初始化UIImageView默认和选中时展示的图片资源</p>

<pre><code>- (id)initWithImage:(UIImage *)image highlightedImage:(UIImage *)highlightedImage;
</code></pre>

<p>// UIImageView的图片资源</p>

<pre><code>UIImage *image;
</code></pre>

<p>// UIImageView选中之后的图片资源</p>

<pre><code>UIImage *highlightedImage;
</code></pre>

<p>// 是否允许用户交互 （默认为NO）</p>

<pre><code>BOOL userInteractionEnabled;
</code></pre>

<p>// 是否选中 （默认为NO）</p>

<pre><code>BOOL highlighted;
</code></pre>

<p><strong>2、动画图片相关</strong></p>

<p>// UIImageView 动画播放的图片组资源（必须是UIImage,如果设置了单一的image，那么这个为nil）</p>

<pre><code>NSArray *animationImages;
</code></pre>

<p>// 选中时UIImageView 动画播放的图片组资源（同上）</p>

<pre><code>NSArray *highlightedAnimationImages;
</code></pre>

<p>// 图片播放的时间间隔</p>

<pre><code>NSTimeInterval animationDuration;
</code></pre>

<p>// 图片重复播放次数（默认为0，为表示一直重复播放）</p>

<pre><code>NSInteger      animationRepeatCount;
</code></pre>

<p>// 播放图片</p>

<pre><code>- (void)startAnimating;
</code></pre>

<p>// 停止播放</p>

<pre><code>- (void)stopAnimating;
</code></pre>

<p>// 是否正在播放</p>

<pre><code>- (BOOL)isAnimating;
</code></pre>

<p><strong>3、iOS7新增</strong></p>

<pre><code>UIColor *tintColor;
</code></pre>
]]></content>
  </entry>
  
</feed>
