<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel之家]]></title>
  <link href="http://beyondabel.github.io/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2013-12-30T14:26:45+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我的新起点之年——2013]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/29/2013summarize/"/>
    <updated>2013-12-29T15:25:42+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/29/2013summarize</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/29/summarize.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>最近逛一些论坛和博客看了很多人都在总结自己的2013年，我也想了想自己这一年来发生的事情，自己也真的是需要好好整理一下自己，调整一下的生活方向，避免自己在现有的环境中迷失方向。思绪万千，我该从哪儿开始呢？想了想，还是从我从一个学生正式步入社会开始说起吧～</p>

<!--more-->


<p>2013年对于我来说是事情多多的一年，也是收获的一年，同时也是失望的一年。还记得去年11月刚工作时满怀激情，一晃一年过去了。</p>

<p>2013年对于我来说最大的事莫过毕业。在毕业答道前的一周，我向公司请了一个礼拜的假，回到了学校，曾经无数次想像离开学校回去的样子，当真正再次回到学校时感觉是那么的陌生，曾经是多么盼望着早些离开的校园、离开宿舍、离开学生的称呼，但到了真正不得不离开的那一刹那，才明白，自己对这片土地是多么的留念。在那个校园里，有着我太多的回忆。</p>

<p>回到学校的第一件事就是去系里“拜访”各位领导（没办法，谁叫我很多的东西没办好呢？），找指导老师修改论文，修改论文，吃饭，基本上就是这几件事，这样的情况一直持续到毕业答辩结束。毕业答辩一结束，我就收拾东西带着对学校留恋和不舍与同学道别搭上北上的火车。</p>

<p>从学校回到帝都，宣示着自己的学生生涯的正式结束，从此正式开始要面对每天工作、生活、感情、家庭这些事了，回到帝都的第一件事就是把住的地方换了，之前那个房子住了太多人了，里面什么人都有，感觉非常的不安全，特别是我们中间大部分都是女生，所以哪怕房租贵一些，还是忍一忍换了一个二室二厅的房子，里面就住着我们几个熟悉的人，东西放在那再也不用担心吊胆的了，特别放心。</p>

<p>在工作方面我感觉2013年是特别糟糕的一年，我从去年11月份入职到现在，公司的产品的方向变了又变，做出来的产品也随着产品方向的改变而pass掉了，以致到现在为止，我还没有什么能够拿得出手的东西。但是在今年还是有很多的收获，自己利用空余的时间写了一个图片下载库，看了《Objective-C设计模式》、《重构》、《代码整洁之道》。</p>

<p>2013即将成为历史，2014将是我参加工作的第2个年头，希望在工作的第2个年头，自己能够学会如何利用现在公司给与我的平台，去施展自己的抱负，我不想像今年一样地平庸，因为平庸只会慢慢消磨自己的斗争。我不希望自己和别人一样，觉得现在的生活就这样了，完全没有了当初毕业的那份豪气。2014年不管会发生什么，自己绝不能丧失斗志，不能做一天和尚撞一天钟。2014改变自己，敞开双手迎接我的2014！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress在Github搭建一个博客]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/26/octopress/"/>
    <updated>2013-12-26T23:59:57+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/26/octopress</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/26/OctopressAndGithub.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p><a href="http://http://octopress.org/">Octopress</a>是利用<a href="http://http://github.com/mojombo/jekyll">Jekyll</a>博客引擎开发的一个博客系统，生成的静态页面能够很好的在<em>github page</em>上展现。号称是hacker专属的一个博客系统(A blogging framework for hackers.)<!--more--></p>

<p>从自己开始使用Octopress搭建博客到正在写博客，中间差不多花了我三个星期，在这三个星期中，我走了很多的弯路，使用Octopress搭建博客的错误我相信我已经遇到80～90%了，所以想写一篇使用Octopress在Github上怎么搭建博客，一来为了与其他人分享，令想利用Octopress搭建博客的人少走一些弯路，另一方面也是自己对这方面的知识一个积累，首先我说一下我的在mac系统环境下搭建的，本文需要读者熟悉一些shell命令，并掌握基本的git操作。</p>

<p><strong>目录</strong></p>

<pre><code>1、搭建环境
2、安装Octopress
3、配置Octopress
4、将博客部署到GitHub上
5、开始写博客
</code></pre>

<p><strong>1、搭建环境</strong></p>

<p>Octopress需要Ruby环境，RVM(Ruby Version Manager)负责安装和管理Ruby的环境。所以我们先在终端输入如下命令，来安装RVM：</p>

<pre><code>1、curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<p>接着是安装<code>Ruby 2.0.0</code>，在终端依次运行如下命令：</p>

<pre><code>1、rvm install 1.9.3
2、rvm use 1.9.3
3、rvm rubygems latest
</code></pre>

<p>完成上面的操作之后，运行ruby &mdash;v应该可以看到ruby 2.0.0环境已经安装好了。</p>

<p>参考：<code>Installing Ruby With RVM</code></p>

<p>在安装Octopress时还需要make命令，所以还会用到command_line_tools，所以还需要下载Xcode，打开Xcode,到Xcode->preferences->Downloads，里面有一个command_line_tools点击下载。</p>

<p>2、安装Octopress</p>

<p>在安装Octopress之前，请确保你的电脑上已经安装有git了，在终端输入git &mdash;version，如果安装了可以看到电脑中的git版本(一般情况下，mac系统现在都已经自带git了)，如果没有显示相关内容，请先安装git。</p>

<p>git安装之后，利用git命令将<code>octopress</code>从<code>github上clone</code>到本机，如下命令：</p>

<pre><code>1、git clone git://github.com/imathis/octopress.git octopress
2、cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
</code></pre>

<p>接着安装相关依赖项：</p>

<pre><code>1、gem install bundler
3、bundle install
</code></pre>

<p>最后安装默认的<code>Octopress</code>主题。</p>

<pre><code>1、rake install
</code></pre>

<p>如果执行<code>rake install</code>报如下错误：<code>You have already activated rake 0.9.6, but your Gemfile requires rake 0.9.2.2. Using bundle exec may solve this.</code></p>

<p>解决办法：打开<code>Gemfile</code>文件，把<code>gem 'rake', '~&gt; 0.9.0'</code>修改成<code>gem 'rake', '~&gt; 0.9.6'</code></p>

<p>参考： <code>Octopress Setup</code></p>

<p><strong>3、配置Octopress</strong></p>

<p><code>Octopress</code>的作者已经尽量让配置简化了。大多数情况下只需要配置<code>_config.yml</code>和<code>Rakefile</code>文件即可。其中Rakefile是跟博客部署相关，一般情况下并不需要修改这个文件，除非使用了<code>rsync</code>。</p>

<p><code>config.yml</code>是博客重要的一个配置文件，在<code>config.yml</code>文件中有三大配置项：<code>Main Configs</code>、<code>Jekyll &amp; Plugins</code>和<code>3rd Party Settings</code>。</p>

<p>一般，该文件中其中<code>url</code>是必须要填写的，这里的<code>url</code>是在<code>github</code>上创建的一个仓库地址，具体请看第四步中创建的地址。另外再修改一下<code>title</code>、<code>subtitle</code>和<code>author</code>，根据需求，在开启一些第三方组件服务。</p>

<pre><code>url: beyondabel.github.io     #网站地址 
title: abel之家               #网站标题 
subtitle: 天行健，君子以自强不息.地势坤，君子以厚德载物.     #网站副标题 
author: abel                      #网站作者，通常显示在页尾和每篇文章的尾部 
simple_search: http://google.com/search   # 搜索引擎 
description:             #网站的描述，出现在HTML页面中的 meta 中的 description
</code></pre>

<p>更多内容，请看这里的内容：<a href="http://octopress.org/docs/configuring/">Configuring Octopress</a></p>

<p><strong>4、将博客部署到GitHub上</strong></p>

<p><code>Github</code>的<code>Page service</code>可以免费托管博客，并且还可以自定义域名。</p>

<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照这样的方式进行命名：<code>username.github.com</code>或<code>organization.github.com</code>。等后面配置完毕之后，我们就可以在浏览器中使用页面地址<code>http://username.github.com</code>来访问我们的博客。一般来说，我们希望在将博客的源码放到source分支下，并把生成的内容提交到master分支。</p>

<p>创建好仓库之后，我们需要利用octopress的一个配置rake任务来自动配置上面创建的仓库：可以让我们方便的部署<code>GitHub page</code>。在终端输入如下命令：</p>

<pre><code>1、$ rake setup_github_pages
</code></pre>

<p>上面的命令会做一些事情(详细介绍看下面给出的参考链接)。其中最主要的就是创建一个_deploy目录，目录用来存放部署到master分支的内容。期间会要求你输入仓库的url，根据提示，进行输入即可。
完成上面的命令之后，我们就可以生成博客并真正的部署到仓库中了。执行如下命令：</p>

<pre><code>1、rake generate
2、rake deploy
</code></pre>

<p>上面的命令首先生成博客文件，并将生成的博客文件拷贝到<code>_deploy/</code>目录下，然后将这些内容添加到git中，并commit和push到仓库的master分支。</p>

<p>现在可以访问<code>http://username.github.io</code>了。注意：有时候可能会有延时，要等几分钟才能打开。
至此，我们的博客已经完成基本的部署。</p>

<p>如果在部署到仓库之前，需要先预览一下博客，可以在终端输入<code>rake preview</code>命令，然后就能在浏览器中进行本地预览访问了：<code>http://127.0.0.1:4000/</code>或<code>http://localhost:4000/</code>，效果跟仓库中的一样。
参考：<code>Deploying to Github Pages</code></p>

<p>如果本地访问时出现了404错误，请关注一下你生成的文件是否直接在public目录下，如果不在，请修改一下<code>config.rb</code>文件，使<code>http_path = "/"</code>。如果访问<code>http://username.github.com</code>上出现了404错误，看一下你的<code>repositories</code>是否有内容，如果有，请你再次确认你的<code>repositories</code>的名称是否是<code>username.github.io</code>,如果不是，那么请用<code>http://username.github.io/[your repositories name]</code>，如果还是不行，请关注一下，你的账号是否使用邮箱激活了，如果没有，请先激活，然后删除这个<code>repositories</code>重新再来。</p>

<p><strong>5、开始写博客</strong></p>

<p><code>Octopress</code>为我们提供了一些task来创建博文和页面。博文必须存储在<code>source/_posts</code>目录下，并且需要按照Jekyll的命名规范对文章进行命名：<code>YYYY-MM-DD-post-title.markdown</code>。文章的名字会被当做url的一部分，而其中的日期用于对博文的区分和排序。</p>

<p>通过<code>Octopress</code>提供的<code>task</code>可以正确的按照命名规范创建一个博文，并且在博文中会附带常用的一些yaml元数据。只需要在终端输入如下命令：</p>

<pre><code>1、rake new_post["title"]
</code></pre>

<p>其中<code>title</code>为博文的文件名，创建出来的文件默认是<code>markdown</code>格式。上面的命令会创建出这样一个文件：<code>source/_posts/2013-08-03-title.markdown</code>。打开这个文件，可以看到里面有如下一些内容了(告诉Jekyll博客引擎如何处理博文和页面)：</p>

<pre><code>---
layout: post
title: "title"
date: 2013-12-26 16:36
comments: true
categories: 
---
</code></pre>

<p>接着我们就可以在这个文件中写我们的博文啦。完成之后，我们可以预览和部署博文。下面是创建并部署博文的一个完整过程：</p>

<pre><code>1、$ rake new_post["New Post"]
2、$ rake generate
3、$ rake deploy
</code></pre>

<p>参考：<a href="http://octopress.org/docs/blogging/">Blogging Basics</a></p>

<p>到此，我们使用Octopress在Github上博客就搭建好了，这中间如果遇到什么问题，可以给我留言。接下来，我将带给大家如何更换博客样式，如何添加评论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的博客搬家啦～]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/01/my-new-blog/"/>
    <updated>2013-12-01T23:37:45+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/01/my-new-blog</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/01/my-new-blog.png" alt="image" /></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;我是一个非常喜欢折腾的程序猿，之前我一直在CSDN上写博文，但由于一些种种的原因，后来放弃了CSDN,之后一直都有搭建个人站点的想法,在网上搜索了如何搭建个人站点,网上有很多的人建议用Octopress+Github,转而开始用Octopress搭建博客<!--more-->，从开始弄Octopress到成功在Github上发布博文已经差不多一个月了，虽然网上有太多关于得用Octopress搭建Github博客的博文，但对于一个小白的我使用Octopress搭建Github博客过程的坚苦也只有自己知道，所以在下一篇博文中我将会记录我使用Octopress搭建Github博客的点点滴滴。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;搭建博客的主要原因一是可以与大家分享交流，二是可以总结一下自己。
使用Octopress+Github与CSDN、百度、新郎、博客园相比，它更自由，可以自定义自己的时尚元素，有一些我非常喜欢的style.如果想使用Octopress+Github搭建博客，将会经历如下步骤：</p>

<p>1.首先，注册一个github账号。</p>

<p>2.配置环境</p>

<p>3.下载Octopress包</p>

<p>4.配置Octopress</p>

<p>5.绑定Github账号</p>

<p>6.把Octopress提交到Github</p>

<p>如果想用域名可以访问的话，还需要经历如下的步骤：</p>

<p>7.域名注册</p>

<p>8.购买虚拟主机</p>

<p>9.域名与虚拟主机中的IP进行绑定。</p>

<p>到此，博客就基本搭建好了～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS设计模式之单例模式]]></title>
    <link href="http://beyondabel.github.io/blog/2013/10/30/singleton/"/>
    <updated>2013-10-30T12:55:59+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/10/30/singleton</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/10/30/singleton.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>单例模式是iOS常用设计模式中的一种。单例设计模式的作用是使得这个类的一个对象成为系统中的唯一实例，因此需要用一种唯一的方法去创建这个对象并返回这个对象的地址。那么，我们何时使用单例模式呢？</p>

<!--more-->


<p>1、类只能有一个实例，而且必须从一个为人熟知的访问点对其访问。</p>

<p>2、这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。</p>

<p>那么用Objective-C如何实现单例模式呢？下面我们来新建一个Singleton类，在Singleton.h中实现如下</p>

<pre><code>@interface Singleton : NSObject 
+ (Singleton *) sharedInstance;
@end 
</code></pre>

<p>在Singleton.m</p>

<pre><code>@implementation Singleton 
static Singleton * sharedSingleton = nil;

+ (Singleton *) sharedInstance  { 
    if (sharedSingleton == nil) {    
        sharedSingleton = [[Singleton alloc] init]; 
    } 
    return sharedSingleton;
}  

@end 
</code></pre>

<p>这样就创建一个简单的单例模式，实际上有一部分程序员也是这样实现的，但实际上这是一个不“严格”版本，在实际中使用，可能会遇到发起调用的对象不能以其他分配方式实例化单例对象，否则，就会创建多个实例。（之前有人和我讨论过这个问题，说使用者应该严格按照接口来使用，当实际上Singleton是一个对象，我们不能保证使用者不会使用其他的方法去创建（比如alloc）,这个时候他就会创建多个实例，这样就会出现这些无法感知的bug）</p>

<p>下面我对<code>Singleton.m</code>的进行改进</p>

<pre><code>@implementation Singleton  
 static Singleton * sharedSingleton = nil;  
+ (Singleton *) sharedInstance  {  
    if (sharedSingleton == nil) {  
        sharedSingleton = [[super allocWithZone:NULL] init];  
    }  
    return sharedSingleton;  
}  

+ (id) allocWithZone:(struct _NSZone *)zone  {  
    return [[self sharedInstance] retain];  
}  

- (id) copyWithZone:(NSZone *) zone  {  
    return self;  
}  

- (id) retain  {  
    return self;  
}  

- (NSUInteger) retainCount  {  
    return NSUIntegerMax;  
}  


- (void) release  {  
//  
}  

- (id) autorelease  {  
    return self;  
}  
@end 
</code></pre>

<p>也许你注意到了，我重载了<code>allocWithZone:</code>，保持了从<code>sharedInstance</code>方法返回的单例对象，使用者哪怕使用<code>alloc</code>时也会返回唯一的实例（<code>alloc</code>方法中会先调用<code>allocWithZone:</code>创建对象）。而<code>retain</code>等内存管理的函数也被重载了，这样做让我们有了把<code>Singleton</code>类变得“严格”了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS成长之路：iOS多线程之GCD]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/26/ios-gcd-one/"/>
    <updated>2013-09-26T15:39:29+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/26/ios-gcd-one</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/26/gcd.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>GCD（Grand Central Dispatch）是一套低层API，提供了一种新的方法来进行并发程序编写。允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>

<!--more-->


<p>GCD的API很大程度上基于block，当然，GCD也可以脱离block来使用，比如使用传统c机制提供函数指针和上下文指针。实践证明，当配合block使用时，GCD非常简单易用且能发挥其最大能力。</p>

<p>GCD相比传统多线程编程的优势：</p>

<p>从使用来看: GCD比之thread跟简单易用。由于GCD基于work unit而非像thread那样基于运算，所以GCD可以控制诸如等待任务结束、监视文件描述符、周期执行代码以及工作挂起等任务。基于block的血统导致它能极为简单得在不同代码作用域之间传递上下文。</p>

<p>从效率看: GCD被实现得如此轻量和优雅，使得它在很多地方比之专门创建消耗资源的线程更实用且快速。这关系到易用性：导致GCD易用的原因有一部分在于你可以不用担心太多的效率问题而仅仅使用它就行了。</p>

<p>从性能上来看: GCD自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。</p>

<p>注：尽管GCD是纯C语言，但它被组建成面向对象的风格，被称为dispatch object。它像cocoa对象一样是引用计数的。使用dispatch_release和dispatch_retain函数来操作dispatch object的引用计数来进行内存管理。如果你使用了ARC，但由于它不是OC对象，所以并不参与垃圾回收，所以即使你使用了ARC，也记得一定要对内存进行手动管理。</p>

<p>GCD的基本概念就是dispatch queue。dispatch queue是一个对象，它可以接受任务，并将任务以先到先执行的顺序来执行。dispatch queue可以是并发的或串行的。并发任务会像NSOperationQueue那样基于系统负载来合适地并发进行，串行队列同一时间只执行单一任务。</p>

<p>GCD中有三种队列类型：</p>

<p>main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。</p>

<p>Global queues: 全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。</p>

<p>用户创建队列: 用函数 dispatch_queue_create 创建的队列. 这些队列是串行的，正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试中常遇到的几个问题]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/10/interview/"/>
    <updated>2013-09-10T11:28:02+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/10/interview</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/10/interview.png" alt="image" /></p>

<p>引言</p>

<p>对了以技术出身的程序员来说，面试题的积累是非常有必要的。Abel在这整理几个iOS面试中常常会问到的几个问题。</p>

<!--more-->


<p><strong>1、#import与#include的区别，以及@class</strong></p>

<pre><code>1.import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。
2.在头文件中， 一般只需要知道被引用的类的名称就可以了。 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。
3.在编译效率方面考虑，如果你有100个头文件都#import了同一个头文件，或者这些文件是依次引用的，如A–&gt;B, B–&gt;C, C–&gt;D这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用 @class则不会。
4.如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现。
所以，一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.
</code></pre>

<p>综上所述#include，#import与@class的区别可以做一下理解：</p>

<pre><code>  #include与#import在引用一个类的时候会包含这个类的所有信息包括变量方法等，但是这样做会对编译效率造成影响.比如有100个类 都#import了ClassA，那么在编译的时候这100个类都会去对ClassA处理.又比如A被B引用，B被C引用，C被D引用.....此时如果 A被修改，那么后面的B，C，D.....都需要重新进行编译.
  #import处理了重复引用的问题，还有一个用法会引起编译错误的就是在ClassA中#import ClassB 在ClassB中#import ClassA（交叉编译）那么在编译的时候也会出现未知错误。
</code></pre>

<p><strong>2、堆和栈的区别?定义一个变量时，这个变量是在堆上还是在栈上？什么时候这个变量的内存会被释放？</strong></p>

<pre><code>一、预备知识—程序的内存分配 
一个由C/C++编译的程序占用的内存分为以下几个部分 
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 操作方式类似于数据结构中的栈。 
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 - 程序结束后由系统释放。 
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 
5、程序代码区—存放函数体的二进制代码。 


二、例子程序 
这是一个前辈写的，非常详细 
//main.cpp 
int a = 0; 全局初始化区 
char *p1; 全局未初始化区 
main() 
{ 
    int b; 栈 
    char s[] = "abc"; 栈 
    char *p2; 栈 
    char *p3 = "123456"; 123456\0在常量区，p3在栈上。 
    static int c =0； 全局（静态）初始化区 
    p1 = (char *)malloc(10); 
    p2 = (char *)malloc(20); 
    分配得来得10和20字节的区域就在堆区。 
    strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456" 优化成一个地方。 
} 


二、堆和栈的理论知识 
2.1申请方式 
stack: 
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 
heap: 
需要程序员自己申请，并指明大小，在c中malloc函数 
如p1 = (char *)malloc(10); 
在C++中用new运算符 
如p2 = new char[10]; 
但是注意p1、p2本身是在栈中的。 
2.2 申请后系统的响应 
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的 首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部 分重新放入空闲链表中。 

2.3申请大小的限制 
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

2.4申请效率的比较： 
栈由系统自动分配，速度较快。但程序员是无法控制的。 
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 

2.5堆和栈中的存储内容 
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 

2.6存取效率的比较 
char s1[] = "aaaaaaaaaaaaaaa"; 
char *s2 = "bbbbbbbbbbbbbbbbb"; 
aaaaaaaaaaa是在运行时刻赋值的； 
而bbbbbbbbbbb是在编译时就确定的； 
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 
比如： 
#include 
void main() 
{ 
    char a = 1; 
    char c[] = "1234567890"; 
    char *p ="1234567890"; 
    a = c[1]; 
    a = p[1]; 
return; 
} 
对应的汇编代码 
10: a = c[1]; 
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] 
0040106A 88 4D FC mov byte ptr [ebp-4],cl 
11: a = p[1]; 
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] 
00401070 8A 42 01 mov al,byte ptr [edx+1] 
00401073 88 45 FC mov byte ptr [ebp-4],al 
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 

2.7小结： 
堆和栈的区别可以用如下的比喻来看出： 
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。
</code></pre>

<p><strong>3、进程和线程的区别</strong></p>

<pre><code>通俗的解释
一个系统运行着很多进程，可以比喻为一条马路上有很多马车,不同的进程可以理解为不同的马车,而同一辆马车可以有很多匹马来拉----这些马就是线程,假设道路的宽度恰好可以通过一辆马车,道路可以认为是临界资源,那么马车成为分配资源的最小单位（进程）,而同一个马车被很多匹马驱动（线程）----即最小的运行单位,每辆马车马匹数&gt;=1，所以马匹数=1的时候进程和线程没有严格界限，只存在一个概念上的区分度，马匹数&gt;1的时候才可以严格区分进程和线程

专业的解释：
简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。
+++++++++++++++++++++++++++++++++++++++++++++++

进程概念
进程是表示资源分配的基本单位，又是调度运行的基本单位。例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I／O设备等。然后，把该进程放人进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以，进程是系统中的并发执行的单位。
在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。

线程概念
线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。例如，假设用户启动了一个窗口中的数据库应用程序，操作系统就将对数据库的调用表示为一个进程。假设用户要从数据库中产生一份工资单报表，并传到一个文件中，这是一个子任务；在产生工资单报表的过程中，用户又可以输人数据库查询请求，这又是一个子任务。这样，操作系统则把每一个请求――工资单报表和新输人的数据查询表示为数据库进程中的独立的线程。线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就是为了方便而有效地实现这种并发性

引入线程的好处
（1）易于调度。
（2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。
（3）开销少。创建线程比创建进程要快，所需开销很少。。
（4）利于充分发挥多处理器的功能。通过创建多线程进程（即一个进程可具有两个或更多个线程），每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。
++++++++++++++++++++++++++++++++++++++++++++++++
进程和线程的关系：
（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。

（3）处理机分给线程，即真正在处理机上运行的是线程。

（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

线程是指进程内的一个执行单元,也是进程内的可调度实体.

与进程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

进程间的通信方式：
1.管道（pipe）及有名管道（named pipe）：

管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
2.信号（signal）：
信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
3.消息队列（message queue）：
消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
4.共享内存（shared memory）：
可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
5.信号量（semaphore）：
主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
6.套接字（socket）；
这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
线程之间的同步通信：
1.信号量 二进制信号量 互斥信号量 整数型信号量 记录型信号量
2.消息     消息队列 消息邮箱
3.事件event

互斥型信号量：必须是同一个任务申请，同一个任务释放，其他任务释放无效。同一个任务可以递归申请。（互斥信号量是二进制信号量的一个子集）

二进制信号量：一个任务申请成功后，可以由另一个任务释放。（与互斥信号量的区别）

整数型信号量：取值不局限于0和1,可以一个任务申请，另一个任务释放。（包含二进制信号量，二进制信号量是整数型信号量的子集）

二进制信号量实现任务互斥：
   打印机资源只有一个，a b c三个任务共享，当a取得使用权后，为了防止其他任务错误地释放了信号量（二进制信号量允许其他任务释放），必须将打印机房的门关起来(进入临界段)，用完后，释放信号量，再把门打开(出临界段)，其他任务再进去打印。(而互斥型信号量由于必须由取得信号量的那个任务释放，故不会出现其他任务错误地释放了信号量的情况出现，故不需要有临界段。互斥型信号量是二进制信号量的子集。)

二进制信号量实现任务同步：
 a任务一直等待信号量，b任务定时释放信号量，完成同步功能

记录型信号量（record semaphore)：
   每个信号量s除一个整数值value（计数）外，还有一个等待队列List，其中是阻塞在该信号量的各个线程的标识。当信号量被释放一个，值被加一后，系统自动从等待队列中唤醒一个等待中的线程，让其获得信号量，同时信号量再减一。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

同步和互斥的区别：
 当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。

 所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的

 所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
</code></pre>
]]></content>
  </entry>
  
</feed>
