<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel之家]]></title>
  <link href="http://beyondabel.github.io/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2014-01-06T17:28:02+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISwitch详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/06/uiswitch/"/>
    <updated>2014-01-06T12:34:31+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/06/uiswitch</id>
    <content type="html"><![CDATA[<p>// 开关是否打开</p>

<pre><code>BOOL on;
</code></pre>

<p>// 这个frame会被忽略，他会强制设置大小</p>

<!--more-->


<pre><code>- (id)initWithFrame:(CGRect)frame;
</code></pre>

<p>// 打开/关闭调用函数(animated：是否使用动画)</p>

<pre><code>- (void)setOn:(BOOL)on animated:(BOOL)animated;
</code></pre>

<p><strong>iOS5新增    </strong></p>

<p>// 开关打开时颜色</p>

<pre><code>UIColor *onTintColor;
</code></pre>

<p><strong>iOS6新增</strong>
// 背影颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 开关的圆形滑钮的颜色</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 开关打开时自定义图片</p>

<pre><code>UIImage *onImage;
</code></pre>

<p>// 开关关闭时自定义图片</p>

<pre><code>UIImage *offImage;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIPageControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/06/uipagecontrol/"/>
    <updated>2014-01-06T12:33:46+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/06/uipagecontrol</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS6.0新增
</code></pre>

<!--more-->


<p><strong>1、基本属性及方法</strong></p>

<p>// 指定页面个数（默认为0）</p>

<pre><code>NSInteger numberOfPages;
</code></pre>

<p>// 当前选中的页面（默认为0，范围为0 ～ numberOfPages-1）</p>

<pre><code>NSInteger currentPage;
</code></pre>

<p>// 如果在numberOfPages为1的情况下隐藏指示器，可以将hideForSinglePage的值设为YES。默认情况下，即使只有一个页面，指示器也会显示进来。</p>

<pre><code>BOOL hidesForSinglePage;
</code></pre>

<p>// 如果你希望直到有时间执行完你的操作之后，才更新当前指示器当前指示页，可以将 defersCurrentPageDisPlay 设为YES。这样的话你必须调用控件的 updateCurentPageDisPlay 来更新当前页</p>

<pre><code>BOOL defersCurrentPageDisplay;
</code></pre>

<p>// 更新当前页</p>

<pre><code>- (void)updateCurrentPageDisplay;
</code></pre>

<p>// 返回接受者的边界大小，与容纳被给的页面数有关</p>

<pre><code>- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;
</code></pre>

<p><strong>2、iOS6.0新增</strong>
// 未选中的点的颜色</p>

<pre><code>UIColor *pageIndicatorTintColor;
</code></pre>

<p>// 当前点颜色</p>

<pre><code>UIColor *currentPageIndicatorTintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIActivityIndicatorView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/06/uiactivityindicatorview/"/>
    <updated>2014-01-06T12:30:48+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/06/uiactivityindicatorview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、UIActivityIndicatorView基本属性及方法
2、iOS5.0新增
</code></pre>

<!--more-->


<p><strong>1、UIActivityIndicatorView基本属性及方法</strong></p>

<p>// 初始化样式</p>

<pre><code>- (id)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style;     // sizes the view according to the style
</code></pre>

<p>// 设置样式（默认为UIActivityIndicatorViewStyleWhite）</p>

<pre><code>UIActivityIndicatorViewStyle activityIndicatorViewStyle;
</code></pre>

<p>// 停止时是否隐藏</p>

<pre><code>BOOL hidesWhenStopped;
</code></pre>

<p>// 开始播放动画</p>

<pre><code>- (void)startAnimating;
</code></pre>

<p>// 停止播放动画</p>

<pre><code>- (void)stopAnimating;
</code></pre>

<p>// 是否正在播放动画</p>

<pre><code>- (BOOL)isAnimating;
</code></pre>

<p><strong>2、iOS5.0新增</strong></p>

<p>// 设置圈圈的颜色</p>

<pre><code>UIColor *color;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIProgressView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/06/uiprogressview/"/>
    <updated>2014-01-06T12:28:03+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/06/uiprogressview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增内容
</code></pre>

<!--more-->


<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化progressView的样式</p>

<pre><code>- (id)initWithProgressViewStyle:(UIProgressViewStyle)style; 
</code></pre>

<p>// progressView的样式（默认为UIProgressViewStyleDefault）</p>

<pre><code>UIProgressViewStyle progressViewStyle;
</code></pre>

<p>// 进度（范围为0-1）</p>

<pre><code>float progress; 
</code></pre>

<p><strong>2、iOS5新增内容</strong></p>

<p>// 进度填充部分的颜色(譬如进度到40%,那么40%部分的颜色就是这个属性)</p>

<pre><code>UIColor* progressTintColor;
</code></pre>

<p>// 未填充部分的颜色</p>

<pre><code>UIColor* trackTintColor ;
</code></pre>

<p>// 进度填充部分的图片，如progressTintColor</p>

<pre><code>UIImage* progressImage;
</code></pre>

<p>// 未填充部分的图片，如trackTintColor</p>

<pre><code>UIImage* trackImage;
</code></pre>

<p>// 设置progress的进度</p>

<pre><code>- (void)setProgress:(float)progress animated:(BOOL)animated;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UILabel详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uilabel/"/>
    <updated>2014-01-05T09:57:41+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uilabel</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2014/01/06/uilabel.png" alt="image" /></p>

<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、属性
2、方法
</code></pre>

<p><strong>1、属性</strong></p>

<p>// UILabel显示内容</p>

<pre><code>NSString           *text;
</code></pre>

<p>// 文字字体(默认为系统字体，大小17)</p>

<pre><code>UIFont             *font;
</code></pre>

<p>// 字体颜色</p>

<pre><code>UIColor            *textColor;
</code></pre>

<p>// 阴影颜色（默认没有阴影）</p>

<pre><code>UIColor            *shadowColor;
</code></pre>

<p>// 阴影大小（默认为（0，-1））</p>

<pre><code>CGSize             shadowOffset; 
</code></pre>

<p>// 文字对齐模式（默认是居左）</p>

<pre><code>NSTextAlignment    textAlignment;
</code></pre>

<p>//  设置单词折行方式（默认NSLineBreakByTruncatingTail）</p>

<pre><code> NSLineBreakMode    lineBreakMode; 
</code></pre>

<p>// 文字显示属性(iOS6.0)</p>

<pre><code>NSAttributedString *attributedText;
</code></pre>

<p>// 文字高亮时的颜色</p>

<pre><code>UIColor *highlightedTextColor; 
</code></pre>

<p>// 是否支持高亮（默认为NO）</p>

<pre><code>BOOL     highlighted;          // default is NO
</code></pre>

<p>// 是否允许接收触摸事件(默认为NO)</p>

<pre><code>BOOL userInteractionEnabled;  // default is NO
</code></pre>

<p>// 文本是否可变(默认YES)</p>

<pre><code>BOOL enabled;                 // default is YES. changes how the label is drawn
</code></pre>

<p>// 设置label可以显示多少行(0表示多行，默认为1)</p>

<pre><code>NSInteger numberOfLines;
</code></pre>

<p>// 文本文字是否自适应大小(默认为NO)</p>

<pre><code>BOOL adjustsFontSizeToFitWidth;         // default is NO
</code></pre>

<p>//</p>

<pre><code>BOOL adjustsLetterSpacingToFitWidth NS_DEPRECATED_IOS(6_0,7_0); // deprecated - hand tune by using NSKernAttributeName to affect tracking
</code></pre>

<p>// 最小字体，行数为1时有效（默认为0.0 iOS2.0 &ndash; iOS6.0）</p>

<pre><code>CGFloat minimumFontSize;
</code></pre>

<p>// 控制文本的基线位置，只有文本行数为1是有效（默认为UIBaselineAdjustmentAlignBaselines）</p>

<pre><code>UIBaselineAdjustment baselineAdjustment;
//有三种方式
typedef enum {
    UIBaselineAdjustmentAlignBaselines = 0, 默认值文本最上端于label中线对齐
    UIBaselineAdjustmentAlignCenters,//文本中线于label中线对齐
    UIBaselineAdjustmentNone,//文本最低端与label中线对齐
} UIBaselineAdjustment;
</code></pre>

<p>// 设置最小字体,与minimumFontSize相同（iOS6.0）</p>

<pre><code>CGFloat minimumScaleFactor; 
</code></pre>

<p>// 优先选择标签布局的最大宽度(iOS 6.0)</p>

<pre><code>CGFloat preferredMaxLayoutWidth;    
</code></pre>

<p><strong>2、方法</strong></p>

<p>// 不可直接调用,需要子类重载,第二参数为0时没有行数限制</p>

<pre><code>- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines;
</code></pre>

<p>// 不可直接调用,需要子类重载</p>

<pre><code>- (void)drawTextInRect:(CGRect)rect;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[视图鼻祖之UIView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uiview/"/>
    <updated>2014-01-04T21:04:48+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uiview</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2014/01/04/uiview.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>UIView表示屏幕上的一块矩形区域，它在App中占有绝对重要的地位，因为iOS中几乎所有可视化控件都是UIView的子类。负责渲染区域的内容，并且响应该区域内发生的触摸事件</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UIView家族
2、UIView的基本属性
3、几何方法类
4、控制级别类
5、渲染类
6、动画类
7、手势类
8、移动效果类
9、基于布局约束类(iOS6.0)
10、基于布局的约束core方法(iOS 6.0)
11、基于约束的兼容性（iOS 6.0）
12、层次布局的约束（iOS 6.0）
13、设备大小布局约束(iOS 6.0)
14、布局调度(iOS 6.0)
15、状态恢复(iOS 6.0)
16、快照 （iOS7.0）
</code></pre>

<p><strong>1、UIView家族</strong></p>

<p>下图就是视图的内层次</p>

<p><img src="http://beyondabel.github.io/images/2014/01/04/uiviewStructure.png" alt="image" /></p>

<p><strong>2、UIView的基本属性</strong></p>

<pre><code>BOOL userInteractionEnabled;  // UIView是否接受events事件，默认为YES
NSInteger tag;                // 用于做标识所用，默认为0
CALayer  *layer;              // Core Animation layer有关，在常用方法中再详细讲解

CGRect            frame;    // UIView在父视图中的位置

CGRect            bounds;  // UIView相对自己的位置
CGPoint           center;      // UIView的中心点. animatable
CGAffineTransform transform;   // 线性代数里面讲的矩阵变换，这个是恒等变换,一般用来旋转，缩放
CGFloat contentScaleFactor;修改contentScaleFactor可以让UIView的渲染精度提高，这样即使在CGAffineTransform放大之后仍然能保持锐利。

BOOL multipleTouchEnabled;   // 是否允许多点触摸
BOOL       exclusiveTouch;         // default is NO
UIColor   backgroundColor;  // UIView的背影颜色
BOOL hidden;  // UIView是否隐藏
CGFloat  alpha; // 为0时完全透明，为1时完全不透明。

BOOL clipsToBounds; //在类的层次结构中，如果clipsTobounds设为YES,超出superView的部分subview就不会显示，否则会做显示， 默认情况下是NO。

BOOL opaque;   //这是一个优化属性，如果该值为YES, 那么绘图在绘制该视图的时候把整个视图当作不透明对待。这样，绘图系统在执行绘图过程中会优化一些操作并提升系统性能；如果是设置为NO, 绘图系统将其和其他内容平等对待，不去做优化操作。为了性能方面的考量，默认被置为YES(意味着‘优化’)。

UIView  *superview;// 父视图
NSArray *subviews;// 子视图
</code></pre>

<p>注：*frame和center都是相对于父视图的，bounds是相对于自身的。当view完全透明和隐藏时不能响应事件。</p>

<p>*opaque和alpha 是有关系的。 一个不透明视图需要整个边界里面的内容都是不透明的。基于这个原因，opaque设置为YES，要求对应的alpha必须为1.0。如果一个UIView实例opaque被设置为YES, 而同时它又没有完全填充它的边界(bounds),或者它包含了整个或部分的透明的内容视图，那么将会导致未知的结果。
因此，如果视图部分或全部支持透明，那么你必须把opaque这个值设置为NO.</p>

<p><strong>3、几何方法类</strong></p>

<pre><code>// hitTest主要用途是用来寻找那个视图是被触摸了
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;   
// 如果我们不想让某个视图响应事件，让此方法返回NO就行了。默认为YES
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;
</code></pre>

<p>举个例子，建立一个TestView里面重载hitTest和pointInside方法：</p>

<pre><code>- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    [super hitTest:point withEvent:event];
    return self;
}  

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    NSLog(@"view pointInside");
    return YES;
}  
</code></pre>

<p>然后在TestView中增加一个子视图TestSecondView也重载这两个方法</p>

<pre><code>- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    [super hitTest:point withEvent:event]; 
    return self;  
}  

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    NSLog(@"second view pointInside");
    return YES; 
}  
</code></pre>

<p>这里注意[super hitTest:point withEvent:event];必须要包括，否则hitTest无法调用父类的方法，这样就没法 使用PointInside:withEvent:进行判断，那么就没法进行子视图的遍历。当去掉这个语句的时候，触摸事件就不可能进到子视图中了，除非你在方法中直接返回子视图的对象。这样你在调试的过程中就会发现，每次你点击一个view都会先进入到这个view的父视图中的hitTest方法，然后 调用super的hitTest方法之后就会查找pointInside是否返回YES如果是，则就把消息传递个子视图处理，子视图用同样的方法递归查找 自己的子视图。所以从这里调试分析看，hitTest方法这种递归调用的方式就一目了然了。</p>

<pre><code>// 将像素point由point所在视图转换到目标视图view中，返回在目标视图view中的像素值
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView *)view;
// 将像素point从view中转换到当前视图中，返回在当前视图中的像素值
- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;

// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect
- (CGRect)convertRect:(CGRect)rect toView:(UIView *)view;
// 将rect从view中转换到当前视图中，返回在当前视图中的rect
- (CGRect)convertRect:(CGRect)rect fromView:(UIView *)view;
</code></pre>

<p><strong>4、控制级别类</strong></p>

<pre><code>// 把视图从父类移除
- (void)removeFromSuperview;
// 添加子视图到某个位置
- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;
// 更改子视图的位置
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;

// 添加子视图
- (void)addSubview:(UIView *)view;
// 把view放在siblingSubview下面
- (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview;
// 把view放在siblingSubview上面
- (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview;
</code></pre>

<p>注：1、addSubview:和insertSubview: atIndex:的区别：</p>

<pre><code>  [view addSubView:oneView] == [view insertSubview:oneView atIndex:view.subviews.cout];

// 将view显示在最前面（要将一个view显示在最前面，只要调用其父视图的bringSubviewToFront：方法）
- (void)bringSubviewToFront:(UIView *)view;
// 将view推送到背后
- (void)sendSubviewToBack:(UIView *)view;
// 当加入视图完成后调用  
- (void)didAddSubview:(UIView *)subview;
// 将移除子视图会调用
- (void)willRemoveSubview:(UIView *)subview;

// 通知即将移动到新的父视图中
- (void)willMoveToSuperview:(UIView *)newSuperview;
// 通知已经到新父视图
- (void)didMoveToSuperview;
// 通知即将已移动到新的窗口
- (void)willMoveToWindow:(UIWindow *)newWindow;
// 通知已经移动新的窗口
- (void)didMoveToWindow;

// 判断一个视图是否在父视图层中
- (BOOL)isDescendantOfView:(UIView *)view;  // returns YES for self.
// 获取标记的子视图
- (UIView *)viewWithTag:(NSInteger)tag;     // recursive search. includes self

// Allows you to perform layout before the drawing cycle happens. -layoutIfNeeded forces layout early
// 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，
// 但layoutSubviews一定会被调用
- (void)setNeedsLayout;
// 如果有需要刷新的标记，立即调用layoutSubviews进行布局
//（如果没有标记，不会调用layoutSubviews）
- (void)layoutIfNeeded;

// 重新布局
- (void)layoutSubviews; 
</code></pre>

<p><strong>5、渲染类</strong></p>

<pre><code>// 重写此方法，执行重绘
- (void)drawRect:(CGRect)rect;

// 标记为需要重绘，异步调用drawRect
- (void)setNeedsDisplay;
// 标记为需要局部重绘
- (void)setNeedsDisplayInRect:(CGRect)rect;
</code></pre>

<p>注：drawRect是对receiver的重绘。setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘</p>

<p><strong>6、动画类</strong></p>

<pre><code>// 开始一个动画
+ (void)beginAnimations:(NSString *)animationID context:(void *)context; 
// 执行动画,类似数据库的事务处理
+ (void)commitAnimations; 
// 设置动画代理，默认为nil
+ (void)setAnimationDelegate:(id)delegate; 

// 当动画执行开始时，执行selector方法，默认为NULL
+ (void)setAnimationWillStartSelector:(SEL)selector;
// 当动画执行结束时，执行selector方法
+ (void)setAnimationDidStopSelector:(SEL)selector; 

// 设置动画时间，时间参数为double类型，默认0.2
+ (void)setAnimationDuration:(NSTimeInterval)duration;
// 设置动画延迟时间
+ (void)setAnimationDelay:(NSTimeInterval)delay;  
// 设置在动画块内部动画内部动画属性改变的开始时间
+ (void)setAnimationStartDate:(NSDate *)startDate;
// 设置动画的旋转曲度变化，默认为UIViewAnimationCurveEaseInOut
//值定义在UIViewAnimationCurve结构体中。
//typedef NS_ENUM(NSInteger, UIViewAnimationCurve) { //动画曲线
    // slow at beginning and end 缓慢开始，中间加速，然后减速到结束
//  UIViewAnimationCurveEaseInOut,   
    // slow at beginning  缓慢开始，加速到结束     
//  UIViewAnimationCurveEaseIn,    
    // slow at end  加速开始，加速到结束        
//  UIViewAnimationCurveEaseOut, 
    //正常速度          
//  UIViewAnimationCurveLinear  
//};
+ (void)setAnimationCurve:(UIViewAnimationCurve)curve; 

// 设置动画在动画模块中的重复次数
+ (void)setAnimationRepeatCount:(float)repeatCount;                 
// 设置动画块中的动画效果是否自动重复播放
+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses;    
// 设置动画是否从当前状态开始播放，默认为NO. 
+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState;  

// 在动画设置过渡效果
+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache;

transition
把一个过渡效果应用到视图中。值定义在UIViewAnimationTransition结构体中。
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone, 没有过渡
    UIViewAnimationTransitionFlipFromLeft,  翻转视图从左到右
    UIViewAnimationTransitionFlipFromRight, 翻转视图从右到左
    UIViewAnimationTransitionCurlUp, 从上卷动
    UIViewAnimationTransitionCurlDown, 从下卷动
};
view
    需要过渡的视图对象。

cache
如果是YES，那么在开始和结束图片视图渲染一次并在动画中创建帧；否则，视图将会在每一帧都渲染。例如缓存，你不需要在视图转变中不停的更新，你只需要等到转换完成再去更新视图。
1、开始一个动画块。
2、在容器视图中设置转换。
3、在容器视图中移除子视图。
4、在容器视图中添加子视图。
5、结束动画块。

// 设置是否开启动画，默认YES,开启
+ (void)setAnimationsEnabled:(BOOL)enabled;
// 验证动画是否开启，YES开启，NO关闭
+ (BOOL)areAnimationsEnabled;               
// iOS7之后替代 setAnimationsEnabled
+ (void)performWithoutAnimation:(void (^)(void))actionsWithoutAnimation;

// iOS4.0之后
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;

动画效果处理块，多参数
</code></pre>

<p>(NSTimeInterval)duration :动画时间</p>

<p>(NSTimeInterval)delay:延迟时间
(UIViewAnimationOptions)options 动画参数</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, UIViewAnimationOptions) {
    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt;  0,
    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt;  1, // turn on user interaction while animating
    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt;  2, // start all views from current value, not initial value
    UIViewAnimationOptionRepeat                    = 1 &lt;&lt;  3, // repeat animation indefinitely
    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt;  4, // if repeat, run animation back and forth
    UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt;  5, // ignore nested duration
    UIViewAnimationOptionOverrideInheritedCurve    = 1 &lt;&lt;  6, // ignore nested curve
    UIViewAnimationOptionAllowAnimatedContent      = 1 &lt;&lt;  7, // animate contents (applies to transitions only)
    UIViewAnimationOptionShowHideTransitionViews   = 1 &lt;&lt;  8, // flip to/from hidden state instead of adding/removing

    UIViewAnimationOptionCurveEaseInOut            = 0 &lt;&lt; 16, // default
    UIViewAnimationOptionCurveEaseIn               = 1 &lt;&lt; 16,
    UIViewAnimationOptionCurveEaseOut              = 2 &lt;&lt; 16,
    UIViewAnimationOptionCurveLinear               = 3 &lt;&lt; 16,

    UIViewAnimationOptionTransitionNone            = 0 &lt;&lt; 20, // default
    UIViewAnimationOptionTransitionFlipFromLeft    = 1 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromRight   = 2 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCurlUp          = 3 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCurlDown        = 4 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCrossDissolve   = 5 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromTop     = 6 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromBottom  = 7 &lt;&lt; 20,
} NS_ENUM_AVAILABLE_IOS(4_0);
</code></pre>

<p>(void))animations :动画效果块</p>

<p>可以设置属性如下：frame\bounds\center\transform\alpha\backgroundColor\contentStretch</p>

<p>completion:(void (^)(BOOL finished))completion
动画结束块</p>

<p>例：</p>

<pre><code>[UIView animateWithDuration: 2.00 delay:3.00 options:UIViewAnimationOptionAllowAnimatedContent
                 animations:^{
                         insertDemoTwo.alpha = 0.1;
                         insertDemoOne.alpha = 1.0;
                                        }
                 completion:^(BOOL finished) {
                     [UIView animateWithDuration:3.00
                                      animations:^{
                                          insertDemoTwo.center = CGPointMake(500.0, 470.0);
                                          insertDemoOne.center = CGPointMake(140.0, 100.0);
                                      }
                      ];


                 }

 ];


// 动画效果处理（无延迟，无参数）iOS4.0之后，默认delay = 0.0,options = 0;
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;
</code></pre>

<p>例：</p>

<pre><code>[UIView animateWithDuration:3.00
                 animations:^{
                     insertDemoOne.alpha = 1.0;
                     insertDemoTwo.alpha = 0.1;
                 }
                 completion:^(BOOL finished) {
                     insertDemoTwo.center = CGPointMake(500.0, 470.0);
                     insertDemoOne.center = CGPointMake(140.0, 100.0);                    
                     }
 ];

//动画效果处理简单版 iOS4.0之后（delay = 0.0,options = 0,completion = NULL）
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations;

+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

// 过渡动画效果块，iOS4.0
+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;
</code></pre>

<p>例：</p>

<pre><code>[UIView transitionWithView:insertDemoOne duration: 1.0 options:UIViewAnimationOptionTransitionFlipFromLeft
                                     animations:^{
                                         [insertDemoTwo removeFromSuperview];
                                         [insertDemoOne addSubview:insertDemoTwo];
                                     }
                                     completion:^(BOOL finished) {
                                         insertDemoOne.backgroundColor = [UIColor brownColor];
                                     }];

// 视图之间切换的过渡动画效果块，iOS4
+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion;


+ (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray *)views options:(UIViewAnimationOptions)options animations:(void (^)(void))parallelAnimations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);
</code></pre>

<p><strong>7、手势类</strong></p>

<p>// 手势识别器（iOS3.2）
@property(nonatomic,copy) NSArray *gestureRecognizers;</p>

<pre><code>UIKit 中UIGestureRecognizer类的子类系列如下：
UITapGestureRecognizer – “轻击”手势。可以配置为“单击”和“连击”的识别。
UIPinchGestureRecognizer –“捏合”手势。该手势通常用于缩放视图或改变可视组件的大小。
UIPanGestureRecognizer – “平移”手势。识别拖拽或移动动作。
UISwipeGestureRecognizer – “轻扫”手势。当用户从屏幕上划过时识别为该手势。可以指定该动作的方向（上、下、左、右）。
UIRotationGestureRecognizer – “转动”手势。用户两指在屏幕上做相对环形运动。
UILongPressGestureRecognizer – “长按”手势。使用1指或多指触摸屏幕并保持一定时间。
</code></pre>

<p>// 绑定手势到视图（iOS3.2）</p>

<pre><code>- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer; 
</code></pre>

<p>//从视图中移除手势 (iOS3.2)</p>

<pre><code>- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer;
</code></pre>

<p>//手势识别处理方式在gesture recognizer视图转出《UIGestureRecognizerStatePossible》状态时调用，如果返回NO,则转换到《UIGestureRecognizerStateFailed》;如果返回YES,则继续识别触摸序列.(默认情况下为YES)。(iOS6.0)</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
</code></pre>

<p><strong>8、移动效果类</strong></p>

<ul>
<li>(void)addMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);</li>
</ul>


<p>/*! Stops applying <code>effect</code> to the receiver. Any affected presentation values will animate to</p>

<pre><code>their post-removal values using the present UIView animation context. */
</code></pre>

<ul>
<li>(void)removeMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);</li>
</ul>


<p><strong>9、基于布局约束类(iOS6.0)</strong></p>

<p>// 视图布局约束</p>

<pre><code>- (NSArray *)constraints;
</code></pre>

<p>// 视图布局上添加一个约束</p>

<pre><code>- (void)addConstraint:(NSLayoutConstraint *)constraint;
</code></pre>

<p>// 视图布局上添加多个约束</p>

<pre><code>- (void)addConstraints:(NSArray *)constraints;
</code></pre>

<p>// 移除视力布局上的一个约束</p>

<pre><code>- (void)removeConstraint:(NSLayoutConstraint *)constraint;
</code></pre>

<p>// 移除视图布局上的多个约束</p>

<pre><code>- (void)removeConstraints:(NSArray *)constraints;
</code></pre>

<p><strong>10、基于布局的约束core方法(iOS 6.0)</strong></p>

<p>// 调用新的视图布局自动触发，更新视图布局上的约束</p>

<pre><code>- (void)updateConstraintsIfNeeded;
</code></pre>

<p>// 更新自定义视图布局约束</p>

<pre><code>- (void)updateConstraints; 
</code></pre>

<p>// 判断视图布局是否需要更新约束</p>

<pre><code>- (BOOL)needsUpdateConstraints;
</code></pre>

<p>// 设置视图布局是否需要更新约束</p>

<pre><code>- (void)setNeedsUpdateConstraints;
</code></pre>

<p><strong>11、基于约束的兼容性（iOS 6.0）</strong></p>

<p>// 标示是否自动遵循视图布局约束，默认为YES</p>

<pre><code>- (BOOL)translatesAutoresizingMaskIntoConstraints; 
</code></pre>

<p>// 设置是否自动遵循视图布局约束</p>

<pre><code>- (void)setTranslatesAutoresizingMaskIntoConstraints:(BOOL)flag;
</code></pre>

<p>// 返回是遵循自定义视图布局约束</p>

<pre><code>+ (BOOL)requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);
</code></pre>

<p><strong>12、层次布局的约束（iOS 6.0）</strong></p>

<p>// 返回矩形对于指定视图框架</p>

<pre><code>- (CGRect)alignmentRectForFrame:(CGRect)frame;
</code></pre>

<p>// 返回框架对于指定视图矩形</p>

<pre><code>- (CGRect)frameForAlignmentRect:(CGRect)alignmentRect;
</code></pre>

<p>// 返回自定义视图大小</p>

<pre><code>- (UIEdgeInsets)alignmentRectInsets;
</code></pre>

<p>// 如果超出约束范围，自动生成基线限制，以满足视图需求</p>

<pre><code>- (UIView *)viewForBaselineLayout;
</code></pre>

<p>// 返回放大的视图布局轴线</p>

<pre><code>- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 设置放大的视图布局的轴线</p>

<pre><code>- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 返回缩小的视图布局的轴线</p>

<pre><code>- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 设置缩小的视图布局轴线</p>

<pre><code>- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p><strong>13、设备大小布局约束(iOS 6.0)</strong></p>

<p>// 满足约束视图布局的大小</p>

<pre><code>- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize;
</code></pre>

<p><strong>14、布局调度(iOS 6.0)</strong></p>

<p>// 返回影响视图布局限制的轴线</p>

<pre><code>- (NSArray *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 返回视图布局约束是否影响指定视图，主要用于调试约束布局，结合exerciseAmbiguityInLayout。</p>

<pre><code>- (BOOL)hasAmbiguousLayout;
</code></pre>

<p>// 随机改变不同效值布局视图，主要用于调试基于约束布局的视图</p>

<pre><code>- (void)exerciseAmbiguityInLayout; 
</code></pre>

<p><strong>15、状态恢复(iOS 6.0)</strong></p>

<p>// 标志是否支持保存，恢复视图状态信息</p>

<pre><code>@property (nonatomic, copy) NSString *restorationIdentifier;
</code></pre>

<p>// 保存视图状态相关信息</p>

<pre><code>- (void) encodeRestorableStateWithCoder:(NSCoder *)coder;
</code></pre>

<p>// 恢复和保存视图相关信息</p>

<pre><code>- (void) decodeRestorableStateWithCoder:(NSCoder *)coder; 
</code></pre>

<p><strong>16、快照 （iOS7.0）</strong></p>

<p>我们有时候可能需要取UIView对象的快照，有几个原因，您可能希望从动画性能改进上去分享您的应用程序的屏幕截图。现有的方法面临几个问题：</p>

<pre><code>1代码不简单
2复杂的渲染选项，比如层面罩的难再生
3OpenGL层需要特殊的事例代码
4快照处理十分慢
</code></pre>

<p>事实上,真的没有任何通用的“快照”代码可以应付所有可能的场景。
但是IOS7将会改变，UIView和UIScreen会有一些新的方法，为各种用例提供简单的快照功能。</p>

<p>动画快照
我们可能经常想对一个视图进行动画处理，但是视图的动画太复杂，要么是动画太密集，要么就是需要额外的代码来控制正确的行为。
例如附带的项目，我们创建一个UIView的子类，它只是简单的添加一些子视图，并旋转来生成一个有趣的几何排列。</p>

<p>// 调用snapshotViewAfterScreenUpdates：方法去创建复杂视图的快照。方法返回一个UIView，来呈现被调用的视图的界面。用这个方法去获取视图快照非常有效，比制作位图要快的多。
当获得视图快照后，我们把它添加到容器视图上，并移除实际的复杂视图。然后可以动画处理快照视图了：</p>

<pre><code>- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;

- (UIView *)resizableSnapshotViewFromRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates withCapInsets:(UIEdgeInsets)capInsets;
- (BOOL)drawViewHierarchyInRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS常用设计模式之委托模式]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/ios-proxymode/"/>
    <updated>2014-01-03T19:20:57+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/ios-proxymode</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>在代理模式中，有两个对象参与处理同一个请求，接受请求的对象将请求委托给另一个对象来处理。</p>

<p>目录</p>

<pre><code>1、什么是代理模式
2、使用代理模式的优点
3、什么时候使用代理模式
4、代理模式一般涉及到的角色
5、Objective-C的代理模式实现
</code></pre>

<!--more-->


<p><strong>1、什么是代理模式</strong>
对其他对象提供一种代理以控制对这个对象的访问。</p>

<p><strong>2、使用代理模式的优点</strong></p>

<pre><code>(1)职责清晰：真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，
            通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。
(2)代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的作用。
(3)高扩展性
</code></pre>

<p><strong>3、什么时候使用代理模式</strong></p>

<p>在对已有的方法进行使用的时候出现需要对原有方法进行改进或者修改，这时候有两种改进选择：修改原有方法来适应现在的使用方式，或者使用一个“第三者”方法来调用原有的方法并且对方法产生的结果进行一定的控制。第一种方法是明显违背了“对扩展开放、对修改关闭”（开闭原则），而且在原来方法中作修改可能使得原来类的功能变得模糊和多元化（就像现在企业多元化一样），而使用第二种方式可以将功能划分的更加清晰，有助于后面的维护。所以在一定程度上第二种方式是一个比较好的选择！</p>

<p><strong>4、代理模式一般涉及到的角色</strong></p>

<p>抽象角色：声明真实对象和代理对象的共同接口；</p>

<p>代理角色：代理对象角色内部含有对真实对象的引用，从而可以操作真实对象，同时代理对象提供与真实对象相同的接口以便在任何时刻都能代替真实对象。同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装。</p>

<p>真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。</p>

<p><strong>5、Objective-C的代理模式实现</strong></p>

<p>现在借助主人和仆人的角色来讲解代理模式。我们想象一下，主人想喝水，需要去买水，但主人不知道怎么去买水，那他叫仆人去帮他买水，仆人听到命令就去买水，仆人买完水再交给主人，这个时候主人就有水喝了。</p>

<p>现在我们用Objective-C来实现这个过程</p>

<p>新建一个Servant协议类</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
@protocol ServantProtocol &lt;NSObject&gt;
- (void) finishedBuyWater;
- (void) finishedBuyWaterError;
@end


新建一个仆人Servant类，.h文件如下：

#import &lt;Foundation/Foundation.h&gt;
#import "ServantProtocol.h"

@interface Servant : NSObject
@property (nonatomic,assign) id&lt;ServantProtocol&gt; delegate;
- (void) buyWater;
@end
</code></pre>

<p>.m文件如下：</p>

<pre><code>#import "Servant.h"

@implementation Servant
- (void) buyWater:(NSInteger)money
{
    if (money &gt; 2) {
        [self.delegate finishedBuyWater];
    }else{
        [self.delegate finishedBuyWaterError];
    }
}
@end
</code></pre>

<p>新建一个Master类，.h文件如下：</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;
#import "ServantProtocol.h"

@interface Master : NSObject&lt;ServantProtocol&gt;
- (void) drinkWater;
@end
</code></pre>

<p>.m文件如下：</p>

<pre><code>#import "Master.h"
#import "Servant.h"

@implementation Master

- (void) drinkWater
{
    Servant * servant = [[Servant alloc] init];
    servant.delegate = self;
    // 命令仆人去买水
    [servant buyWater];
}

#pragma mark - ServantProtocol
- (void) finishedBuyWater
{
    NSLog(@"完成买水");
}

- (void) finishedBuyWaterError
{
    NSLog(@"买水出错");
}
@end
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress在Github搭建一个博客]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/26/octopress/"/>
    <updated>2013-12-26T23:59:57+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/26/octopress</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/26/OctopressAndGithub.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p><a href="http://http://octopress.org/">Octopress</a>是利用<a href="http://http://github.com/mojombo/jekyll">Jekyll</a>博客引擎开发的一个博客系统，生成的静态页面能够很好的在<em>github page</em>上展现。号称是hacker专属的一个博客系统(A blogging framework for hackers.)<!--more--></p>

<p>从自己开始使用Octopress搭建博客到正在写博客，中间差不多花了我三个星期，在这三个星期中，我走了很多的弯路，使用Octopress搭建博客的错误我相信我已经遇到80～90%了，所以想写一篇使用Octopress在Github上怎么搭建博客，一来为了与其他人分享，令想利用Octopress搭建博客的人少走一些弯路，另一方面也是自己对这方面的知识一个积累，首先我说一下我的在mac系统环境下搭建的，本文需要读者熟悉一些shell命令，并掌握基本的git操作。</p>

<p><strong>目录</strong></p>

<pre><code>1、搭建环境
2、安装Octopress
3、配置Octopress
4、将博客部署到GitHub上
5、开始写博客
</code></pre>

<p><strong>1、搭建环境</strong></p>

<p>Octopress需要Ruby环境，RVM(Ruby Version Manager)负责安装和管理Ruby的环境。所以我们先在终端输入如下命令，来安装RVM：</p>

<pre><code>1、curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<p>先查看Ruby的版本号，在终端依次运行如下命令：</p>

<pre><code>ruby -v
</code></pre>

<p>如果ruby的版本号大于1.9.3，那么就不用安装了，如果小于1.9.3那就需要安装Ruby</p>

<p>接着是安装<code>Ruby 2.0.0</code>,在终端依次运行如下命令：</p>

<pre><code>1、rvm install 1.9.3
2、rvm use 1.9.3
3、rvm rubygems latest
</code></pre>

<p>完成上面的操作之后，运行ruby &mdash;v应该可以看到ruby 2.0.0环境已经安装好了。</p>

<p>参考：<code>Installing Ruby With RVM</code></p>

<p>在安装Octopress时还需要make命令，所以还会用到command_line_tools，所以还需要下载Xcode，打开Xcode,到Xcode->preferences->Downloads，里面有一个command_line_tools点击下载。</p>

<p>2、安装Octopress</p>

<p>在安装Octopress之前，请确保你的电脑上已经安装有git了，在终端输入git &mdash;version，如果安装了可以看到电脑中的git版本(一般情况下，mac系统现在都已经自带git了)，如果没有显示相关内容，请先安装git。</p>

<p>git安装之后，利用git命令将<code>octopress</code>从<code>github上clone</code>到本机，如下命令：</p>

<pre><code>1、git clone git://github.com/imathis/octopress.git octopress
2、cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
</code></pre>

<p>接着安装相关依赖项：</p>

<pre><code>1、gem install bundler
3、bundle install
</code></pre>

<p>最后安装默认的<code>Octopress</code>主题。</p>

<pre><code>1、rake install
</code></pre>

<p>如果执行<code>rake install</code>报如下错误：<code>You have already activated rake 0.9.6, but your Gemfile requires rake 0.9.2.2. Using bundle exec may solve this.</code></p>

<p>解决办法：打开<code>Gemfile</code>文件，把<code>gem 'rake', '~&gt; 0.9.0'</code>修改成<code>gem 'rake', '~&gt; 0.9.6'</code></p>

<p>参考： <code>Octopress Setup</code></p>

<p><strong>3、配置Octopress</strong></p>

<p><code>Octopress</code>的作者已经尽量让配置简化了。大多数情况下只需要配置<code>_config.yml</code>和<code>Rakefile</code>文件即可。其中Rakefile是跟博客部署相关，一般情况下并不需要修改这个文件，除非使用了<code>rsync</code>。</p>

<p><code>config.yml</code>是博客重要的一个配置文件，在<code>config.yml</code>文件中有三大配置项：<code>Main Configs</code>、<code>Jekyll &amp; Plugins</code>和<code>3rd Party Settings</code>。</p>

<p>一般，该文件中其中<code>url</code>是必须要填写的，这里的<code>url</code>是在<code>github</code>上创建的一个仓库地址，具体请看第四步中创建的地址。另外再修改一下<code>title</code>、<code>subtitle</code>和<code>author</code>，根据需求，在开启一些第三方组件服务。</p>

<pre><code>url: beyondabel.github.io     #网站地址 
title: abel之家               #网站标题 
subtitle: 天行健，君子以自强不息.地势坤，君子以厚德载物.     #网站副标题 
author: abel                      #网站作者，通常显示在页尾和每篇文章的尾部 
simple_search: http://google.com/search   # 搜索引擎 
description:             #网站的描述，出现在HTML页面中的 meta 中的 description
</code></pre>

<p>更多内容，请看这里的内容：<a href="http://octopress.org/docs/configuring/">Configuring Octopress</a></p>

<p><strong>4、将博客部署到GitHub上</strong></p>

<p><code>Github</code>的<code>Page service</code>可以免费托管博客，并且还可以自定义域名。</p>

<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照这样的方式进行命名：<code>username.github.com</code>或<code>organization.github.com</code>。等后面配置完毕之后，我们就可以在浏览器中使用页面地址<code>http://username.github.com</code>来访问我们的博客。一般来说，我们希望在将博客的源码放到source分支下，并把生成的内容提交到master分支。</p>

<p>创建好仓库之后，我们需要利用octopress的一个配置rake任务来自动配置上面创建的仓库：可以让我们方便的部署<code>GitHub page</code>。在终端输入如下命令：</p>

<pre><code>1、$ rake setup_github_pages
</code></pre>

<p>上面的命令会做一些事情(详细介绍看下面给出的参考链接)。其中最主要的就是创建一个_deploy目录，目录用来存放部署到master分支的内容。期间会要求你输入仓库的url，根据提示，进行输入即可。
完成上面的命令之后，我们就可以生成博客并真正的部署到仓库中了。执行如下命令：</p>

<pre><code>1、rake generate
2、rake deploy
</code></pre>

<p>上面的命令首先生成博客文件，并将生成的博客文件拷贝到<code>_deploy/</code>目录下，然后将这些内容添加到git中，并commit和push到仓库的master分支。</p>

<p>现在可以访问<code>http://username.github.io</code>了。注意：有时候可能会有延时，要等几分钟才能打开。
至此，我们的博客已经完成基本的部署。</p>

<p>如果在部署到仓库之前，需要先预览一下博客，可以在终端输入<code>rake preview</code>命令，然后就能在浏览器中进行本地预览访问了：<code>http://127.0.0.1:4000/</code>或<code>http://localhost:4000/</code>，效果跟仓库中的一样。
参考：<code>Deploying to Github Pages</code></p>

<p>如果本地访问时出现了404错误，请关注一下你生成的文件是否直接在public目录下，如果不在，请修改一下<code>config.rb</code>文件，使<code>http_path = "/"</code>。如果访问<code>http://username.github.com</code>上出现了404错误，看一下你的<code>repositories</code>是否有内容，如果有，请你再次确认你的<code>repositories</code>的名称是否是<code>username.github.io</code>,如果不是，那么请用<code>http://username.github.io/[your repositories name]</code>，如果还是不行，请关注一下，你的账号是否使用邮箱激活了，如果没有，请先激活，然后删除这个<code>repositories</code>重新再来。</p>

<p><strong>5、开始写博客</strong></p>

<p><code>Octopress</code>为我们提供了一些task来创建博文和页面。博文必须存储在<code>source/_posts</code>目录下，并且需要按照Jekyll的命名规范对文章进行命名：<code>YYYY-MM-DD-post-title.markdown</code>。文章的名字会被当做url的一部分，而其中的日期用于对博文的区分和排序。</p>

<p>通过<code>Octopress</code>提供的<code>task</code>可以正确的按照命名规范创建一个博文，并且在博文中会附带常用的一些yaml元数据。只需要在终端输入如下命令：</p>

<pre><code>1、rake new_post["title"]
</code></pre>

<p>其中<code>title</code>为博文的文件名，创建出来的文件默认是<code>markdown</code>格式。上面的命令会创建出这样一个文件：<code>source/_posts/2013-08-03-title.markdown</code>。打开这个文件，可以看到里面有如下一些内容了(告诉Jekyll博客引擎如何处理博文和页面)：</p>

<pre><code>---
layout: post
title: "title"
date: 2013-12-26 16:36
comments: true
categories: 
---
</code></pre>

<p>接着我们就可以在这个文件中写我们的博文啦。完成之后，我们可以预览和部署博文。下面是创建并部署博文的一个完整过程：</p>

<pre><code>1、$ rake new_post["New Post"]
2、$ rake generate
3、$ rake deploy
</code></pre>

<p>参考：<a href="http://octopress.org/docs/blogging/">Blogging Basics</a></p>

<p>到此，我们使用Octopress在Github上博客就搭建好了，这中间如果遇到什么问题，可以给我留言。接下来，我将带给大家如何更换博客样式，如何添加评论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS时间相关各种技巧]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/24/ios-time/"/>
    <updated>2013-12-24T22:33:47+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/24/ios-time</id>
    <content type="html"><![CDATA[<p><strong>一、通过自带的日历得到年月日、时间、以及星期</strong></p>

<!--more-->


<pre><code>NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
NSDate *now;
NSDateComponents *comps = [[NSDateComponents alloc] init];
NSInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSWeekdayCalendarUnit | 
                                     NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;
now=[NSDate date];
comps = [calendar components:unitFlags fromDate:now];
week = [comps weekday];    
month = [comps month];
day = [comps day];
hour = [comps hour];
min = [comps minute];
sec = [comps second];
</code></pre>

<p><strong>二、世界标准时间UTC /GMT 转为当前系统时区对应的时间</strong></p>

<pre><code>- (NSDate *)getNowDateFromatAnDate:(NSDate *)anyDate
{
    //设置源日期时区
    NSTimeZone* sourceTimeZone = [NSTimeZone timeZoneWithAbbreviation:@"UTC"];//或GMT
    //设置转换后的目标日期时区
    NSTimeZone* destinationTimeZone = [NSTimeZone localTimeZone];
    //得到源日期与世界标准时间的偏移量
    NSInteger sourceGMTOffset = [sourceTimeZone secondsFromGMTForDate:anyDate];
    //目标日期与本地时区的偏移量
    NSInteger destinationGMTOffset = [destinationTimeZone secondsFromGMTForDate:anyDate];
    //得到时间偏移量的差值
    NSTimeInterval interval = destinationGMTOffset - sourceGMTOffset;
    //转为现在时间
    NSDate* destinationDateNow = [[[NSDate alloc] initWithTimeInterval:interval sinceDate:anyDate] autorelease];
    return destinationDateNow;
}
</code></pre>

<p><strong>三、NSString格式转化为NSDate</strong></p>

<pre><code>- (NSDate *)stringToDate:(NSString *)strdate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatteralloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];// NSString的时间格式
    NSDate *retdate = [dateFormatter dateFromString:strdate];
    [dateFormatter release];
    return retdate;
}
</code></pre>

<p><strong>四、NSDate转化为NSString</strong></p>

<pre><code>- (NSString *)dateToString:(NSDate *)date
{
    NSDateFormatter *dateFormatter = [[NSDateFormatteralloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSString *strDate = [dateFormatter stringFromDate:date];
    [dateFormatter release];
    return strDate;
}
</code></pre>

<p><strong>五、将本地日期字符串转为UTC日期字符串</strong></p>

<pre><code>//本地日期格式:2013-08-03 12:53:51
//可自行指定输入输出格式
-(NSString *)getUTCFormateLocalDate:(NSString *)localDate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //输入格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];

    NSDate *dateFormatted = [dateFormatter dateFromString:localDate];
    NSTimeZone *timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
    [dateFormatter setTimeZone:timeZone];
    //输出格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    NSString *dateString = [dateFormatter stringFromDate:dateFormatted];
    [dateFormatter release];
    return dateString;
}
</code></pre>

<p><strong>六、将UTC日期字符串转为本地时间字符串</strong></p>

<pre><code>//输入的UTC日期格式2013-08-03T04:53:51+0000
-(NSString *)getLocalDateFormateUTCDate:(NSString *)utcDate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //输入格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    NSTimeZone *localTimeZone = [NSTimeZone localTimeZone];
    [dateFormatter setTimeZone:localTimeZone];

    NSDate *dateFormatted = [dateFormatter dateFromString:utcDate];
    //输出格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSString *dateString = [dateFormatter stringFromDate:dateFormatted];
    [dateFormatter release];
    return dateString;
}
</code></pre>

<p><strong>七、iOS开发之格式化日期时间</strong></p>

<p>字符说明</p>

<p>(:)时间分隔符。在某些区域设置中，可以使用其他字符表示时间分隔符。时间分隔符在格式化时间值时分隔小时、分钟和秒。格式化输出中用作时间分隔符的实际字符由您的应用程序的当前区域性值确定。</p>

<p>(/)日期分隔符。在某些区域设置中，可以使用其他字符表示日期分隔符。日期分隔符在格式化日期值时分隔日、月和年。格式化输出中用作日期分隔符的实际字符由您的应用程序的当前区域性确定。</p>

<p>(%)用于表明不论尾随什么字母，随后字符都应该以单字母格式读取。也用于表明单字母格式应以用户定义格式读取。有关更多详细信息，请参见下面的内容。</p>

<p>D将日显示为不带前导零的数字（如 1）。如果这是用户定义的数字格式中的唯一字符，请使用 %D。</p>

<p>DD将日显示为带前导零的数字（如 01）。</p>

<p>EEE将日显示为缩写形式（例如 SUN）。</p>

<p>EEEE将日显示为全名（例如 SUNDAY）。</p>

<p>M将月份显示为不带前导零的数字（如一月表示为 1）。如果这是用户定义的数字格式中的唯一字符，请使用 %M。</p>

<p>MM将月份显示为带前导零的数字（例如 01/12/01）。</p>

<p>MMM将月份显示为缩写形式（例如 JAN）。</p>

<p>MMMM将月份显示为完整月份名（例如 JANUARY）。</p>

<p>GG显示时代/纪元字符串（例如 A.D.）</p>

<p>H使用 12 小时制将小时显示为不带前导零的数字（例如 1:15:15 PM）。如果这是用户定义的数字格式中的唯一字符，请使用 %H。</p>

<p>HH使用 12 小时制将小时显示为带前导零的数字（例如 01:15:15 PM）。</p>

<p>H使用 24 小时制将小时显示为不带前导零的数字（例如 1:15:15）。如果这是用户定义的数字格式中的唯一字符，请使用 %H。</p>

<p>HH使用 24 小时制将小时显示为带前导零的数字（例如 01:15:15）。</p>

<p>M将分钟显示为不带前导零的数字（例如 12:1:15）。如果这是用户定义的数字格式中的唯一字符，请使用 %M。</p>

<p>MM将分钟显示为带前导零的数字（例如 12:01:15）。</p>

<p>S将秒显示为不带前导零的数字（例如 12:15:5）。如果这是用户定义的数字格式中的唯一字符，请使用 %S。</p>

<p>SS将秒显示为带前导零的数字（例如 12:15:05）。</p>

<p>F显示秒的小数部分。例如，FF 将精确显示到百分之一秒，而 FFFF 将精确显示到万分之一秒。用户定义格式中最多可使用七个 F 符号。如果这是用户定义的数字格式中的唯一字符，请使用 %F。</p>

<p>T使用 12 小时制，并对中午之前的任一小时显示大写的 A，对中午到 11:59 P.M 之间的任一小时显示大写的 P。如果这是用户定义的数字格式中的唯一字符，请使用 %T。</p>

<p>TT对于使用 12 小时制的区域设置，对中午之前任一小时显示大写的 AM，对中午到 11:59 P.M 之间的任一小时显示大写的 PM。对于使用 24 小时制的区域设置，不显示任何字符。</p>

<p>Y将年份 (0-9) 显示为不带前导零的数字。如果这是用户定义的数字格式中的唯一字符，请使用 %Y。</p>

<p>YY以带前导零的两位数字格式显示年份（如果适用）。</p>

<p>YYY以四位数字格式显示年份。</p>

<p>YYYY以四位数字格式显示年份。</p>

<p>Z显示不带前导零的时区偏移量（如 -8）。如果这是用户定义的数字格式中的唯一字符，请使用 %Z。</p>

<p>ZZ显示带前导零的时区偏移量（例如 -08）</p>

<p>ZZZ显示完整的时区偏移量（例如 -08:00）</p>

<p>格式显示</p>

<pre><code>M/D/YY    12/7/58
D-MMM    7-DEC
D-MMMM-YY     7-DECEMBER-58
D MMMM      7 DECEMBER
MMMM YY    DECEMBER 58
HH:MM TT     08:50 PM
H:MM:SS T     8:50:35 P
H:MM    20:50
H:MM:SS    20:50:35
M/D/YYYY H:MM     12/7/1958 20:50   
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的博客搬家啦～]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/01/my-new-blog/"/>
    <updated>2013-12-01T23:37:45+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/01/my-new-blog</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/01/my-new-blog.png" alt="image" /></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;我是一个非常喜欢折腾的程序猿，之前我一直在CSDN上写博文，但由于一些种种的原因，后来放弃了CSDN,之后一直都有搭建个人站点的想法,在网上搜索了如何搭建个人站点,网上有很多的人建议用Octopress+Github,转而开始用Octopress搭建博客<!--more-->，从开始弄Octopress到成功在Github上发布博文已经差不多一个月了，虽然网上有太多关于得用Octopress搭建Github博客的博文，但对于一个小白的我使用Octopress搭建Github博客过程的坚苦也只有自己知道，所以在下一篇博文中我将会记录我使用Octopress搭建Github博客的点点滴滴。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;搭建博客的主要原因一是可以与大家分享交流，二是可以总结一下自己。
使用Octopress+Github与CSDN、百度、新郎、博客园相比，它更自由，可以自定义自己的时尚元素，有一些我非常喜欢的style.如果想使用Octopress+Github搭建博客，将会经历如下步骤：</p>

<p>1.首先，注册一个github账号。</p>

<p>2.配置环境</p>

<p>3.下载Octopress包</p>

<p>4.配置Octopress</p>

<p>5.绑定Github账号</p>

<p>6.把Octopress提交到Github</p>

<p>如果想用域名可以访问的话，还需要经历如下的步骤：</p>

<p>7.域名注册</p>

<p>8.购买虚拟主机</p>

<p>9.域名与虚拟主机中的IP进行绑定。</p>

<p>到此，博客就基本搭建好了～</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac下CocoaPods安装步骤]]></title>
    <link href="http://beyondabel.github.io/blog/2013/11/13/mac-install-cocoapods/"/>
    <updated>2013-11-13T19:16:34+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/11/13/mac-install-cocoapods</id>
    <content type="html"><![CDATA[<p>介绍：
开发应用的时候第三方的库是不可缺少的，它能提高开发的效率。一些经常用到的库，在新的项目里用是，你又得手工的Add到项目里，用的到库多起来了，就不方便管理了。CocoaPods这个软件，可以方便的帮你管理Xcode里的第三方的库。</p>

<!--more-->


<p>安装步骤：
1、打开终端在终端输入</p>

<pre><code> sudo gem install -V cocoapods 
</code></pre>

<p>2、等待下载完成后，会出现</p>

<pre><code>/usr/bin/xcodeproj
Building native extensions.  This could take a while...
ERROR:  Error installing cocoapods:

ERROR: Failed to build gem native extension.

/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby extconf.rb
checking for -std=c99 option to compiler... yes
checking for CoreFoundation... yes
checking for CoreFoundation/CoreFoundation.h... yes
checking for CoreFoundation/CFStream.h... yes
checking for CoreFoundation/CFPropertyList.h... yes
checking for ruby/st.h... yes
creating extconf.h
creating Makefile

make
xcrun cc -I. -I. -I/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib/ruby/1.8/universal-darwin12.0 -I. -
DRUBY_EXTCONF_H=\"extconf.h\"  -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE   -fno-common -arch i386 -arch x86_64 -g -Os -pipe -fno-common -DENABLE_DTRACE  -fno-common  -pipe -fno-common  -std=c99  -c xcodeproj_ext.c
xcrun: Error: could not stat active Xcode path '/Applications/Xcode5-DP3.app/Contents/Developer'. (No such file or directory)
cc -arch i386 -arch x86_64 -pipe -bundle -undefined dynamic_lookup -o xcodeproj_ext.bundle xcodeproj_ext.o -L. -L/System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/lib -L. -arch i386 -arch x86_64  -ObjC -framework CoreFoundation    -lruby  -lpthread -ldl -lobjc 
clang: error: no such file or directory: 'xcodeproj_ext.o'
make: *** [xcodeproj_ext.bundle] Error 1


Gem files will remain installed in /Library/Ruby/Gems/1.8/gems/xcodeproj-0.5.2 for inspection.
Results logged to /Library/Ruby/Gems/1.8/gems/xcodeproj-0.5.2/ext/xcodeproj/gem_make.out
</code></pre>

<p>说明：出现上面错误原因是因为找不到xcode
解决办法：在终端输入sudo xcode-select &mdash;switch /Applications/Xcode5-DP5.app/Contents/Developer（Xcode5-DP5是Xcode版本号）</p>

<p>3、更新cocoapods 在终端上输入sudo gem update -V
如果更新出错或者发现cocoapods不是最新版本的话，最好就是去下载一个最新版本，然后在本地安装</p>

<p>4、搜索  先试试搜索功能，你需要什么库，可以用pod来搜索，比如要用AFNetworking这个库：pod search是搜索命名，后面写上库名称就行了。搜索pod search AFNetworking</p>

<p>能够搜索出来说明cocoapods安装成功，下面我就来说说怎么使用cocoapods.</p>

<p>1、创建一个xcode项目，并通过终端进入一个xcode项目目录。在终端输入</p>

<pre><code>vi Podfile
在Podfile里写入
platform :ios, '5.0'
pod 'AFNetworking', '~&gt;1.1.0'
</code></pre>

<p>2、在终端进入项目目录，在终端上输入 pod install</p>

<pre><code> 你会发现这个目录多了*.xcworkspace pod等文件。这是pod生成的项目管理文件，打开*.xcworkspace 项目文件，在Xcode里看到是这样的目录结构：

 ![image](http://)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS常用设计模式之单例模式]]></title>
    <link href="http://beyondabel.github.io/blog/2013/10/30/singleton/"/>
    <updated>2013-10-30T12:55:59+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/10/30/singleton</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/10/30/singleton.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>在很多时间，singleton定义为“有且仅有一个元素的集合”，所以不管那个对象到底有多大，每次我们拿这个对象时都是同一个。在什么情况下会需要单例以及单例在Objective-C中如何实现呢？本节Abel将与您一起探讨一些有关singleton的知识。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、什么是单例模式
2、什么时候用单例模式
3、Objective-C中单例模式的实现
4、线程安全
5、总结
</code></pre>

<p><strong>1、什么是单例模式</strong></p>

<p>单例模式几乎是设计模式中最简单的了。这一模式的意图是使得类的一个对象成为系统中唯一的实例。要实例这一点，可以从客户端对其进行实例化开始。因此需要用一种只允许生成对象类的唯一实例的机制，“阻止”所有想要生成对象的访问。我们可以用工厂方法来限制实例化过程。这个方法应该是一个静态的方法（类方法），因为让类的实例去生成另一个唯一实例毫无意义。</p>

<p><strong>2、什么时候使用单例模式</strong></p>

<pre><code>1、类只能有一个实例，而且必须从一个为人熟知的访问点对其访问。
2、这个唯一的实例只能通过子类化进行扩展，而且扩展的对象不会破坏客户端代码。
</code></pre>

<p><strong>3、Objective-C中单例模式的实现</strong></p>

<p>在《设计模式》一书中的原始示例中，单例模式的C++例子如下所求：</p>

<pre><code>class Singleton
{
    public:
        static Singleton *Instance();
    protected:
        Singleton();
    private:
        static Singletion * _instance;
}

Singleton *Singleton::Instance()
{
    if(_instance == 0)
    {
        instance = new Singleton;
    }
    return _instance;
}
</code></pre>

<p>知道C++语言的人都能看出来，在上面的C++代码Instance()方法中，检查静态的_instance实例变量，看它是否为0，如果是，会生成一个新的Singleton对象，然后将实例返回，现在我们把它改造成Objective-C版。</p>

<p>那么用Objective-C如何实现单例模式呢？下面我们来新建一个Singleton类，在Singleton.h中实现如下</p>

<pre><code>@interface Singleton : NSObject 
+ (Singleton *) sharedInstance;
@end 
</code></pre>

<p>在Singleton.m</p>

<pre><code>@implementation Singleton 
static Singleton * sharedSingleton = nil;

+ (Singleton *) sharedInstance  { 
    if (sharedSingleton == nil) {    
        sharedSingleton = [[Singleton alloc] init]; 
    } 
    return sharedSingleton;
}  
@end 
</code></pre>

<p>按照C++改造成Objective-C就完成了。如果真是这样的话，那么单例模式真的是太简单了，但实际上，需要克服一些障碍，才能让单例模式更可靠，可以真正放心地应用于程序中。如果需要实现一个“严格”的单例模式，还需要面对两个主要的障碍。</p>

<pre><code>发起调用的对象不能以其他分配方式实例化对象。否则，就有可能创建多个单例实例。
对单例对象实例化的限制应该与引用计数内存模型共存。
</code></pre>

<p>下面我对<code>Singleton.m</code>的进行改进</p>

<pre><code>@implementation Singleton  
 static Singleton * sharedSingleton = nil;  
+ (Singleton *) sharedInstance  {  
    if (sharedSingleton == nil) {  
        sharedSingleton = [[super allocWithZone:NULL] init];  
    }  
    return sharedSingleton;  
}  

+ (id) allocWithZone:(struct _NSZone *)zone  {  
    return [[self sharedInstance] retain];  
}  

- (id) copyWithZone:(NSZone *) zone  {  
    return self;  
}  

- (id) retain  {  
    return self;  
}  

- (NSUInteger) retainCount  {  
    return NSUIntegerMax;  
}  


- (void) release  {  
//  
}  

- (id) autorelease  {  
    return self;  
}  
@end 
</code></pre>

<p>也许你注意到了，我重载了<code>allocWithZone:</code>，保持了从<code>sharedInstance</code>方法返回的单例对象，使用者哪怕使用<code>alloc</code>时也会返回唯一的实例（<code>alloc</code>方法中会先调用<code>allocWithZone:</code>创建对象）。而<code>retain</code>等内存管理的函数也被重载了，这样实现了合适的内存管理原则。</p>

<p><strong>4、线程安全</strong></p>

<p>如果单例对象要由多个线程访问，那么使它的线程安全至关重要。例子中的Singleton类只能胜任一般用途。要让它线程安全，需要在sharedSingleton静态实例的nil检查周围加入一些@synchronized()程序块或者NSLock实例。如果有其他的属性需要保护，也可以把它们声明为atomic型。</p>

<p><strong>5、总结</strong></p>

<p>到此，单例模式的讲解就到些结束了。不管在哪个平台开发，单例模式都极为常用。如果单例模式还有不懂的地方，可以给我留言。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[禁止键盘弹出时UIWebView自动滑动]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/28/ios-webview-keybord/"/>
    <updated>2013-09-28T23:01:15+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/28/ios-webview-keybord</id>
    <content type="html"><![CDATA[<p>之前在做公司项目的时候，需要做一个页面编辑功能，当我们点击编辑器的时候，网页会自动的滑动，结果导致编辑器的fram发生变化。为了解决这个问题，我们需要去禁止webView的自动滑动，我们只需要重写viewForZoomingInScrollView方法就可以了</p>

<!--more-->


<pre><code>webview.scrollView.delegate=self;

-(UIView*)viewForZoomingInScrollView:(UIScrollView*)scrollView 
{
    return nil;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[网页颜色值转化成UIColor]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/27/webcolor-uicolor/"/>
    <updated>2013-09-27T19:14:03+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/27/webcolor-uicolor</id>
    <content type="html"><![CDATA[<p>在做项目过程中，有时设计人员给我们往往是一个设计图，而我们用PS取值的时候可以得到一个红绿蓝和一个网页的颜色值，用红绿蓝往往不是很方便，后来我们在项目工具中写一个方法，专门把网页的颜色值转化成UIColor，这样一来，方便了许多。</p>

<!--more-->


<pre><code>+ (UIColor *)colorFromHexString:(NSString *)hexString {
    unsigned rgbValue = 0;
    NSScanner *scanner = [NSScannerscannerWithString:hexString];
    [scanner setScanLocation:1];// bypass '#' character
    [scannerscanHexInt:&amp;rgbValue];
    return [UIColorcolorWithRed:((rgbValue &amp; 0xFF0000) &gt;&gt; 16)/255.0green:((rgbValue &amp; 0xFF00) &gt;&gt; 8)/255.0 blue:(rgbValue &amp; 0xFF)/255.0 alpha:1.0];
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS多线程之GCD]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/26/ios-gcd-one/"/>
    <updated>2013-09-26T15:39:29+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/26/ios-gcd-one</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/26/gcd.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>GCD（Grand Central Dispatch）是一套低层API，提供了一种新的方法来进行并发程序编写。允许程序将任务切分为多个单一任务然后提交至工作队列来并发地或者串行地执行。GCD比之NSOpertionQueue更底层更高效，并且它不是Cocoa框架的一部分。</p>

<!--more-->


<p>GCD的API很大程度上基于block，当然，GCD也可以脱离block来使用，比如使用传统c机制提供函数指针和上下文指针。实践证明，当配合block使用时，GCD非常简单易用且能发挥其最大能力。</p>

<p>GCD相比传统多线程编程的优势：</p>

<p>从使用来看: GCD比之thread跟简单易用。由于GCD基于work unit而非像thread那样基于运算，所以GCD可以控制诸如等待任务结束、监视文件描述符、周期执行代码以及工作挂起等任务。基于block的血统导致它能极为简单得在不同代码作用域之间传递上下文。</p>

<p>从效率看: GCD被实现得如此轻量和优雅，使得它在很多地方比之专门创建消耗资源的线程更实用且快速。这关系到易用性：导致GCD易用的原因有一部分在于你可以不用担心太多的效率问题而仅仅使用它就行了。</p>

<p>从性能上来看: GCD自动根据系统负载来增减线程数量，这就减少了上下文切换以及增加了计算效率。</p>

<p>注：尽管GCD是纯C语言，但它被组建成面向对象的风格，被称为dispatch object。它像cocoa对象一样是引用计数的。使用dispatch_release和dispatch_retain函数来操作dispatch object的引用计数来进行内存管理。如果你使用了ARC，但由于它不是OC对象，所以并不参与垃圾回收，所以即使你使用了ARC，也记得一定要对内存进行手动管理。</p>

<p>GCD的基本概念就是dispatch queue。dispatch queue是一个对象，它可以接受任务，并将任务以先到先执行的顺序来执行。dispatch queue可以是并发的或串行的。并发任务会像NSOperationQueue那样基于系统负载来合适地并发进行，串行队列同一时间只执行单一任务。</p>

<p>GCD中有三种队列类型：</p>

<p>main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。</p>

<p>Global queues: 全局队列是并发队列，并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。可以调用dispatch_get_global_queue函数传入优先级来访问队列。</p>

<p>用户创建队列: 用函数 dispatch_queue_create 创建的队列. 这些队列是串行的，正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS开发过程中出现错误整理]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/25/ios-developerment-error/"/>
    <updated>2013-09-25T19:10:57+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/25/ios-developerment-error</id>
    <content type="html"><![CDATA[<p>1、No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6).</p>

<!--more-->


<p>今天上午开完会，一回来真机调试就报 No architectures to compile for (ONLY_ACTIVE_ARCH=YES, active arch=armv7s, VALID_ARCHS=armv7 armv6)错误。虚拟机没事，一旦用真机就报这个错误，开始以为是我安装几个软件之后，安装不成功，系统问题。然后就是重装系统，都不成功。最终解决办法：</p>

<p>1.把Build Active Architecture Only 下面的Debug 设为NO release 设置为YES
2.Valid Architectures 设置为 armv7 armv6 就OK 了。</p>

<p>1.Xcode编译出现错误如下：CodeSign error: code signing is required for product type &lsquo;Application&rsquo; in SDK &lsquo;iOS 5.0&rsquo;
解决方法如下：
选择工程－>Build Settings &ndash;> Code Signing &ndash;> Code Signing Identity &ndash;> Debug &ndash;> Any ios SDK 将选项改为：iPhone Developer</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程总述]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/24/thread-overview/"/>
    <updated>2013-09-24T10:34:29+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/24/thread-overview</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/26/multithreading.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>多线程是一个比较轻量级的方法来实现单个应用程序内多个代码执行路径。在系统级别内，程序并排执行，系统分配到每个程序的执行时间是基于该程序的所需时间和其他程序的所需时间来决定的。然而在每个应程序的内部，存在一个或多个执行线程，它同时或在一个几乎同时发生的方式里执行不同的任务。系统本身管理这些执行的线程，调度它们在可用的内核上运行，并在需要让其他线程执行的时候抢先打断它们。</p>

<!--more-->


<p>从技术角度来看，一个线程就是一个需要管理执行代码的内核级和应用级数据结构组合。内核级结构协助调度线程事件，并抢占式调度一个线程到可用的内核之上。应用级结构包括用于存储函数调用的调用堆栈和应用程序需要管理和操作线程属性和状态的结构。</p>

<p>在非并发的应用程序，只有一个执行线程。该线程开始和结束于你应用程序的main循环，一个个方法和函数的分支构成了你整个应用程序的所有行为。与此相反，支持并发的应用程序开始可以在需要额外的执行路径时候创建一个或多个线程。每个新的执行路径有它自己独立于应用程序main循环的定制开始循环。在应用程序中存在多个线程提供了两个非常重要的的潜在优势：</p>

<p>多个线程可以提高应用程序的感知响应。</p>

<p>多个线程可以提高应用程序在多核系统上的实时性能。</p>

<p>如果你的应用程序只有单独的线程，那么该独立程序需要完成所有的事情。它必须对事件作出响应，更新您的应用程序的窗口，并执行所有实现你应用程序行为需要的计算。拥有单独线程的主要问题是在同一时间里面它只能执行一个任务。那么当你的应用程序需要很长时间才能完成的时候会发生什么呢？当你的代码忙于计算你所需要的值的时候，你的程序就会停止响应用户事件和更新它的窗口。如果这样的情况持续足够长的时间，用户就会误认为你的程序被挂起了，并试图强制退出。如果你把你的计算任务转移到一个独立的线程里面，那么你的应用程序主线程就可以自由并及时响应用户的交互。</p>

<p>当然多线程并不是解决程序性能问题的灵丹妙药。多线程带来好处同时也伴随着潜在问题。应用程序内拥有多个可执行路径，会给你的代码增加更多的复杂性。每个线程需要和其他线程协调其行为，以防止它破坏应用程序的状态信息。因为应用程序内的多个线程共享内存空间，它们访问相同的数据结构。如果两个线程试图同时处理相同的数据结构，一个线程有可能覆盖另外线程的改动导致破坏该数据结构。即使有适当的保护，你仍然要注意由于编译器的优化导致给你代码产生很微妙的（和不那么微妙）的Bug。</p>

<p><strong>线程术语</strong></p>

<p>在讨论多线程和它支持的相关技术之前，我们有必要先了解一些基本的术语。如果你熟悉Carbon的多处理器服务API或者UNIX系统的话，你会发现本文档里面“任务(task)”被用于不同的定义。在Mac OS的早期版本，术语“任务(task)”是用来区分使用多处理器服务创建的线程和使用Carbon线程管理API创建的线程。在UNIX系统里面，术语“任务（task）”也在一段时间内被用于指代运行的进程。在实际应用中，多处理器服务任务是相当于抢占式的线程。</p>

<p>由于Carbon线程管理器和多处理器服务API是Mac OS X的传统技术，本文件采用下列术语：
线程(线程)用于指代独立执行的代码段。</p>

<p>进程(process)用于指代一个正在运行的可执行程序，它可以包含多个线程。</p>

<p>任务(task)用于指代抽象的概念，表示需要执行工作。</p>

<p><strong>多线程的替代方法</strong></p>

<p>你自己创建多线程代码的一个问题就是它会给你的代码带来不确定性。多线程是一个相对较低的水平和复杂的方式来支持你的应用程序并发。如果你不完全理解你的设计选择的影响，你可能很容易遇到同步或定时问题，其范围可以从细微的行为变化到严重到让你的应用程序崩溃并破坏用户数据。</p>

<p>你需要考虑的另一个因素是你是否真的需要多线程或并发。多线程解决了如何在同一个进程内并发的执行多路代码路径的问题。然而在很多情况下你是无法保证你所在做的工作是并发的。多线程引入带来大量的开销，包括内存消耗和CPU占用。你会发现这些开销对于你的工作而言实在太大，或者有其他方法会更容易实现。</p>

<p>注意:当使用fork函数加载独立进程的时候，你必须总是在fork后面调用exec或者类似的函数。基于Core Foundation、Cocao或者Core Data框架（无论显式还是隐式关联）的应用程序随后调用exec函数或者类似的函数都会导出不确定的结果。</p>

<p><strong>线程支持</strong></p>

<p>如果你已经有代码使用了多线程，Mac OS X和iOS提供几种技术来在你的应用程序里面创建多线程。此外，两个系统都提供了管理和同步你需要在这些线程里面处理的工作。以下几个部分描述了一些你在Mac OS X和iOS上面使用多线程的时候需要注意的关键技术。</p>

<p><strong>线程包</strong></p>

<p>虽然多线程的底层实现机制是Mach的线程，你很少（即使有）使用Mach级的线程。相反，你会经常使用到更多易用的POSIX 的API或者它的衍生工具。Mach的实现没有提供多线程的基本特征，但是包括抢占式的执行模型和调度线程的能力，所以它们是相互独立的。</p>

<p>   在应用层上，其他平台一样所有线程的行为本质上是相同的。线程启动之后，线程就进入三个状态中的任何一个:运行(running)、就绪(ready)、阻塞(blocked)。如果一个线程当前没有运行，那么它不是处于阻塞，就是等待外部输入，或者已经准备就绪等待分配CPU。线程持续在这三个状态之间切换，直到它最终退出或者进入中断状态。</p>

<p>当你创建一个新的线程，你必须指定该线程的入口点函数（或Cocoa线程时候为入口点方法）。该入口点函数由你想要在该线程上面执行的代码组成。但函数返回的时候，或你显式的中断线程的时候，线程永久停止，且被系统回收。因为线程创建需要的内存和时间消耗都比较大，因此建议你的入口点函数做相当数量的工作，或建立一个运行循环允许进行经常性的工作。</p>

<p>为了获取更多关于线程支持的可用技术并且如何使用它们，请阅读“线程管理部分”。</p>

<p><strong>Run Loops</strong></p>

<pre><code>注:为了便于记忆，文本后面部分翻译Run Loops的时候基本采用原义，而非翻译为“运行循环”。
</code></pre>

<p>  一个run loop是用来在线程上管理事件异步到达的基础设施。一个run loop为线程监测一个或多个事件源。当事件到达的时候，系统唤醒线程并调度事件到run loop,然后分配给指定程序。如果没有事件出现和准备处理，run loop把线程置于休眠状态。</p>

<p>你创建线程的时候不需要使用一个run loop，但是如果你这么做的话可以给用户带来更好的体验。Run Loops可以让你使用最小的资源来创建长时间运行线程。因为run loop在没有任何事件处理的时候会把它的线程置于休眠状态，它消除了消耗CPU周期轮询，并防止处理器本身进入休眠状态并节省电源。</p>

<p>为了配置run loop,你所需要做的是启动你的线程，获取run loop的对象引用，设置你的事件处理程序，并告诉run loop运行。Cocoa和Carbon提供的基础设施会自动为你的主线程配置相应的run loop。如果你打算创建长时间运行的辅助线程，那么你必须为你的线程配置相应的run loop。</p>

<p>关于run loops的详细信息和如何使用它们的例子会在“Run Loops”部分介绍。</p>

<p><strong>同步工具</strong></p>

<p>线程编程的危害之一是在多个线程之间的资源争夺。如果多个线程在同一个时间试图使用或者修改同一个资源，就会出现问题。缓解该问题的方法之一是消除共享资源，并确保每个线程都有在它操作的资源上面的独特设置。因为保持完全独立的资源是不可行的，所以你可能必须使用锁，条件，原子操作和其他技术来同步资源的访问。</p>

<p>锁提供了一次只有一个线程可以执行代码的有效保护形式。最普遍的一种锁是互斥排他锁，也就是我们通常所说的“mutex”。当一个线程试图获取一个当前已经被其他线程占据的互斥锁的时候，它就会被阻塞直到其他线程释放该互斥锁。系统的几个框架提供了对互斥锁的支持，虽然它们都是基于相同的底层技术。此外Cocoa提供了几个互斥锁的变种来支持不同的行为类型，比如递归。获取更多关于锁的种类的信息，请阅读“锁”部分内容。</p>

<p>除了锁，系统还提供了条件，确保在你的应用程序任务执行的适当顺序。一个条件作为一个看门人，阻塞给定的线程，直到它代表的条件变为真。当发生这种情况的时候，条件释放该线程并允许它继续执行。POSIX级别和基础框架都直接提供了条件的支持。（如果你使用操作对象，你可以配置你的操作对象之间的依赖关系的顺序确定任务的执行顺序，这和条件提供的行为非常相似）。</p>

<p>尽管锁和条件在并发设计中使用非常普遍，原子操作也是另外一种保护和同步访问数据的方法。原子操作在以下情况的时候提供了替代锁的轻量级的方法，其中你可以执行标量数据类型的数学或逻辑运算。原子操作使用特殊的硬件设施来保证变量的改变在其他线程可以访问之前完成。</p>

<p>获取更多关于可用同步工具信息，请阅读“同步工具”部分。</p>

<p><strong>线程间通信</strong></p>

<p>虽然一个良好的设计最大限度地减少所需的通信量，但在某些时候，线程之间的通信显得十分必要。（线程的任务是为你的应用程序工作，但如果从来没有使用过这些工作的结果，那有什么好处呢？）线程可能需要处理新的工作要求，或向你应用程序的主线程报告其进度情况。在这些情况下，你需要一个方式来从其他线程获取信息。幸运的是，线程共享相同的进程空间，意味着你可以有大量的可选项来进行通信。
线程间通信有很多种方法，每种都有它的优点和缺点。“配置线程局部存储”列出了很多你可以在Mac OS X上面使用的通信机制。（异常的消息队列和Cocoa分布式对象，这些技术也可在iOS用来通信）。本表中的技术是按照复杂性的顺序列出。</p>

<p><strong>设计技巧</strong></p>

<p>以下各节帮助你实现自己的线程提供了指导，以确保你代码的正确性。部分指南同时提供如何利用你的线程代码获得更好的性能。任何性能的技巧，你应该在你更改你代码之前、期间、之后总是收集相关的性能统计数据。</p>

<p><strong>避免显式创建线程</strong></p>

<p>手动编写线程创建代码是乏味的，而且容易出现错误，你应该尽可能避免这样做。Mac OS X和iOS通过其他API接口提供了隐式的并发支持。你可以考虑使用异步API，GCD方式，或操作对象来实现并发，而不是自己创建一个线程。这些技术背后为你做了线程相关的工作，并保证是无误的。此外，比如GCD和操作对象技术被设计用来管理线程，比通过自己的代码根据当前的负载调整活动线程的数量更高效。 关于更多GCD和操作对象的信息，你可以查阅“并发编程指南(Concurrency Programming Guid)”。</p>

<p><strong>保持你的线程合理的忙</strong></p>

<p>如果你准备人工创建和管理线程，记得多线程消耗系统宝贵的资源。你应该尽最大努力确保任何你分配到线程的任务是运行相当长时间和富有成效的。同时你不应该害怕中断那些消耗最大空闲时间的线程。线程使用一个平凡的内存量，它的一些有线，所以释放一个空闲线程，不仅有助于降低您的应用程序的内存占用，它也释放出更多的物理内存使用的其他系统进程。线程占用一定量的内存，其中一些是有线的，所以释放空闲线程不但帮助你减少了你应用程序的内存印记，而且还能释放出更多的物理内存给其他系统进程使用。</p>

<p>重要:在你中断你的空闲线程开始之前，你必须总是记录你应用程序当前的性能基线测量。当你尝试修改后，采取额外的测量来确保你的修改实际上提高了性能，而不是对它操作损害。</p>

<p><strong>避免共享数据结构</strong></p>

<p>避免造成线程相关资源冲突的最简单最容易的办法是给你应用程序的每个线程一份它需求的数据的副本。当最小化线程之间的通信和资源争夺时并行代码的效果最好。</p>

<p>创建多线程的应用是很困难的。即使你非常小心，并且在你的代码里面所有正确的地方锁住共享资源，你的代码依然可能语义不安全的。比如，当在一个特定的顺序里面修改共享数据结构的时候，你的代码有可能遇到问题。以原子方式修改你的代码，来弥补可能随后对多线程性能产生损耗的情况。把避免资源争夺放在首位通常可以得到简单的设计同样具有高性能的效果。</p>

<p><strong>多线程和你的用户界面</strong></p>

<p>如果你的应用程序具有一个图形用户界面，建议你在主线程里面接收和界面相关的事件和初始化更新你的界面。这种方法有助于避免与处理用户事件和窗口绘图相关的同步问题。一些框架，比如Cocoa,通常需要这样操作，但是它的事件处理可以不这样做，在主线程上保持这种行为的优势在于简化了管理你应用程序用户界面的逻辑。</p>

<p>有几个显著的例外，它有利于在其他线程执行图形操作。比如，QuickTime API包含了一系列可以在辅助线程执行的操作，包括打开视频文件，渲染视频文件，压缩视频文件，和导入导出图像。类似的，在Carbon和Cocoa里面，你可以使用辅助线程来创建和处理图片和其他图片相关的计算。使用辅助线程来执行这些操作可以极大提高性能。如果你不确定一个操作是否和图像处理相关，那么你应该在主线程执行这些操作。</p>

<p>关于QuickTime线程安全的信息，查阅Technical Note TN2125:“QuickTime的线程安全编程”。关于Cocoa线程安全的更多信息，查阅“线程安全总结”。关于Cocoa绘画信息，查阅Cocoa绘画指南（Cocoa Drawing Guide）。</p>

<p><strong>了解线程退出时的行为</strong></p>

<p>进程一直运行直到所有非独立线程都已经退出为止。默认情况下，只有应用程序的主线程是以非独立的方式创建的，但是你也可以使用同样的方法来创建其他线程。当用户退出程序的时候，通常考虑适当的立即中断所有独立线程，因为通常独立线程所做的工作都是是可选的。如果你的应用程序使用后台线程来保存数据到硬盘或者做其他周期行的工作，那么你可能想把这些线程创建为非独立的来保证程序退出的时候不丢失数据。</p>

<p>以非独立的方式创建线程（又称作为可连接的）你需要做一些额外的工作。因为大部分上层线程封装技术默认情况下并没有提供创建可连接的线程，你必须使用POSIX API来创建你想要的线程。此外，你必须在你的主线程添加代码，来当它们最终退出的时候连接非独立的线程。更多有关创建可连接的线程信息，请查阅“设置线程的脱离状态”部分。</p>

<p>如果你正在编程Cocoa的程序，你也可以通过使用applicationShouldTerminate:的委托方法来延迟程序的中断直到一段时间后或者完成取消。当延迟中断的时候，你的程序需要等待直到任何周期线程已经完成它们的任务且调用了replyToApplicationShouldTerminate:方法。关于更多这些方法的信息，请查阅NSApplication Class Reference。</p>

<p><strong>处理异常</strong></p>

<p>当抛出一个异常时，异常的处理机制依赖于当前调用堆栈执行任何必要的清理。因为每个线程都有它自己的调用堆栈，所以每个线程都负责捕获它自己的异常。如果在辅助线程里面捕获一个抛出的异常失败，那么你的主线程也同样捕获该异常失败：它所属的进程就会中断。你无法捕获同一个进程里面其他线程抛出的异常。</p>

<p>如果你需要通知另一个线程（比如主线程）当前线程中的一个特殊情况，你应该捕捉异常，并简单地将消息发送到其他线程告知发生了什么事。根据你的模型和你正在尝试做的事情，引发异常的线程可以继续执行（如果可能的话），等待指示，或者干脆退出。</p>

<pre><code>注意:在Cocoa里面，一个NSException对象是一个自包含对象，一旦它被引发了，那么它可以从一个
    线程传递到另外一个线程。
</code></pre>

<p>在一些情况下，异常处理可能是自动创建的。比如，Objective-C中的@synchronized包含了一个隐式的异常处理。</p>

<p><strong>干净地中断你的线程</strong></p>

<p>线程自然退出的最好方式是让它达到其主入口结束点。虽然有不少函数可以用来立即中断线程，但是这些函数应仅用于作为最后的手段。在线程达到它自然结束点之前中断一个线程阻碍该线程清理完成它自己。</p>

<p>1、iOS有三种多线程编程的技术，分别是：</p>

<p>1.NSThread</p>

<p>2.Cocoa NSOperation （IOS多线程编程之NSOperation和NSOperationQueue的使用）</p>

<p>3.GCD 全称：Grand Central Dispatch（ IOS多线程编程之Grand Central Dispatch(GCD)介绍和使用）</p>

<p>这三种编程方式从上到下，抽象度层次是从低到高的，抽象度越高的使用越简单，也是Apple最推荐使用的。</p>

<p>2、三种方式的优缺点介绍：</p>

<p>NSThread:</p>

<p>优点：NSThread 比其他两个轻量级</p>

<p>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</p>

<p>Cocoa operation</p>

<p>优点：不需要关心线程管理，数据同步的事情，可以把精力放在自己需要执行的操作上。</p>

<p>Cocoa operation相关的类是 NSOperation,NSOperationQueue。NSOperation是个抽象类，使用它必须用它的子类，可以实现它或者使用它定义好的两个子类：NSInvocationOperation和NSBlockOperation。创建NSOperation子类的对象，把对象添加到NSOperationQueue队列里执行。</p>

<p>GCD:Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。在iOS4.0开始之后才能使用。GCD是一个替代诸如NSThread, NSOperationQueue, NSInvocationOperation等技术的很高效和强大的技术。现在的iOS系统都升级到6了，所以不用担心该技术不能使用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试中常遇到的几个问题]]></title>
    <link href="http://beyondabel.github.io/blog/2013/09/10/interview/"/>
    <updated>2013-09-10T11:28:02+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/09/10/interview</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/09/10/interview.png" alt="image" /></p>

<p>引言</p>

<p>对了以技术出身的程序员来说，面试题的积累是非常有必要的。Abel在这整理几个iOS面试中常常会问到的几个问题。</p>

<!--more-->


<p><strong>1、#import与#include的区别，以及@class</strong></p>

<pre><code>1.import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。
2.在头文件中， 一般只需要知道被引用的类的名称就可以了。 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。
3.在编译效率方面考虑，如果你有100个头文件都#import了同一个头文件，或者这些文件是依次引用的，如A–&gt;B, B–&gt;C, C–&gt;D这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用 @class则不会。
4.如果有循环依赖关系，如:A–&gt;B, B–&gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现。
所以，一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.
</code></pre>

<p>综上所述#include，#import与@class的区别可以做一下理解：</p>

<pre><code>  #include与#import在引用一个类的时候会包含这个类的所有信息包括变量方法等，但是这样做会对编译效率造成影响.比如有100个类 都#import了ClassA，那么在编译的时候这100个类都会去对ClassA处理.又比如A被B引用，B被C引用，C被D引用.....此时如果 A被修改，那么后面的B，C，D.....都需要重新进行编译.
  #import处理了重复引用的问题，还有一个用法会引起编译错误的就是在ClassA中#import ClassB 在ClassB中#import ClassA（交叉编译）那么在编译的时候也会出现未知错误。
</code></pre>

<p><strong>2、堆和栈的区别?定义一个变量时，这个变量是在堆上还是在栈上？什么时候这个变量的内存会被释放？</strong></p>

<pre><code>一、预备知识—程序的内存分配 
一个由C/C++编译的程序占用的内存分为以下几个部分 
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其 操作方式类似于数据结构中的栈。 
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。 
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的 全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另 一块区域。 - 程序结束后由系统释放。 
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 
5、程序代码区—存放函数体的二进制代码。 


二、例子程序 
这是一个前辈写的，非常详细 
//main.cpp 
int a = 0; 全局初始化区 
char *p1; 全局未初始化区 
main() 
{ 
    int b; 栈 
    char s[] = "abc"; 栈 
    char *p2; 栈 
    char *p3 = "123456"; 123456\0在常量区，p3在栈上。 
    static int c =0； 全局（静态）初始化区 
    p1 = (char *)malloc(10); 
    p2 = (char *)malloc(20); 
    分配得来得10和20字节的区域就在堆区。 
    strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"123456" 优化成一个地方。 
} 


二、堆和栈的理论知识 
2.1申请方式 
stack: 
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间 
heap: 
需要程序员自己申请，并指明大小，在c中malloc函数 
如p1 = (char *)malloc(10); 
在C++中用new运算符 
如p2 = new char[10]; 
但是注意p1、p2本身是在栈中的。 
2.2 申请后系统的响应 
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时， 会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表 中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的 首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。 另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部 分重新放入空闲链表中。 

2.3申请大小的限制 
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 

2.4申请效率的比较： 
栈由系统自动分配，速度较快。但程序员是无法控制的。 
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。 

2.5堆和栈中的存储内容 
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。 

2.6存取效率的比较 
char s1[] = "aaaaaaaaaaaaaaa"; 
char *s2 = "bbbbbbbbbbbbbbbbb"; 
aaaaaaaaaaa是在运行时刻赋值的； 
而bbbbbbbbbbb是在编译时就确定的； 
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。 
比如： 
#include 
void main() 
{ 
    char a = 1; 
    char c[] = "1234567890"; 
    char *p ="1234567890"; 
    a = c[1]; 
    a = p[1]; 
return; 
} 
对应的汇编代码 
10: a = c[1]; 
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] 
0040106A 88 4D FC mov byte ptr [ebp-4],cl 
11: a = p[1]; 
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] 
00401070 8A 42 01 mov al,byte ptr [edx+1] 
00401073 88 45 FC mov byte ptr [ebp-4],al 
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，再根据edx读取字符，显然慢了。 

2.7小结： 
堆和栈的区别可以用如下的比喻来看出： 
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。 
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。
</code></pre>

<p><strong>3、进程和线程的区别</strong></p>

<pre><code>通俗的解释
一个系统运行着很多进程，可以比喻为一条马路上有很多马车,不同的进程可以理解为不同的马车,而同一辆马车可以有很多匹马来拉----这些马就是线程,假设道路的宽度恰好可以通过一辆马车,道路可以认为是临界资源,那么马车成为分配资源的最小单位（进程）,而同一个马车被很多匹马驱动（线程）----即最小的运行单位,每辆马车马匹数&gt;=1，所以马匹数=1的时候进程和线程没有严格界限，只存在一个概念上的区分度，马匹数&gt;1的时候才可以严格区分进程和线程

专业的解释：
简而言之,一个程序至少有一个进程,一个进程至少有一个线程.
线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行
进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。
+++++++++++++++++++++++++++++++++++++++++++++++

进程概念
进程是表示资源分配的基本单位，又是调度运行的基本单位。例如，用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I／O设备等。然后，把该进程放人进程的就绪队列。进程调度程序选中它，为它分配CPU以及其它有关资源，该进程才真正运行。所以，进程是系统中的并发执行的单位。
在Mac、Windows NT等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。

线程概念
线程是进程中执行运算的最小单位，亦即执行处理机调度的基本单位。如果把进程理解为在逻辑上操作系统所完成的任务，那么线程表示完成该任务的许多可能的子任务之一。例如，假设用户启动了一个窗口中的数据库应用程序，操作系统就将对数据库的调用表示为一个进程。假设用户要从数据库中产生一份工资单报表，并传到一个文件中，这是一个子任务；在产生工资单报表的过程中，用户又可以输人数据库查询请求，这又是一个子任务。这样，操作系统则把每一个请求――工资单报表和新输人的数据查询表示为数据库进程中的独立的线程。线程可以在处理器上独立调度执行，这样，在多处理器环境下就允许几个线程各自在单独处理器上进行。操作系统提供线程就是为了方便而有效地实现这种并发性

引入线程的好处
（1）易于调度。
（2）提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。
（3）开销少。创建线程比创建进程要快，所需开销很少。。
（4）利于充分发挥多处理器的功能。通过创建多线程进程（即一个进程可具有两个或更多个线程），每个线程在一个处理器上运行，从而实现应用程序的并发性，使每个处理器都得到充分运行。
++++++++++++++++++++++++++++++++++++++++++++++++
进程和线程的关系：
（1）一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

（2）资源分配给进程，同一进程的所有线程共享该进程的所有资源。

（3）处理机分给线程，即真正在处理机上运行的是线程。

（4）线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

线程是指进程内的一个执行单元,也是进程内的可调度实体.

与进程的区别:
(1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
(2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行
(3)拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.
(4)系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

进程间的通信方式：
1.管道（pipe）及有名管道（named pipe）：

管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。
2.信号（signal）：
信号是在软件层次上对中断机制的一种模拟，它是比较复杂的通信方式，用于通知进程有某事件发生，一个进程收到一个信号与处理器收到一个中断请求效果上可以说是一致的。
3.消息队列（message queue）：
消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息。
4.共享内存（shared memory）：
可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。
5.信号量（semaphore）：
主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段。
6.套接字（socket）；
这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
线程之间的同步通信：
1.信号量 二进制信号量 互斥信号量 整数型信号量 记录型信号量
2.消息     消息队列 消息邮箱
3.事件event

互斥型信号量：必须是同一个任务申请，同一个任务释放，其他任务释放无效。同一个任务可以递归申请。（互斥信号量是二进制信号量的一个子集）

二进制信号量：一个任务申请成功后，可以由另一个任务释放。（与互斥信号量的区别）

整数型信号量：取值不局限于0和1,可以一个任务申请，另一个任务释放。（包含二进制信号量，二进制信号量是整数型信号量的子集）

二进制信号量实现任务互斥：
   打印机资源只有一个，a b c三个任务共享，当a取得使用权后，为了防止其他任务错误地释放了信号量（二进制信号量允许其他任务释放），必须将打印机房的门关起来(进入临界段)，用完后，释放信号量，再把门打开(出临界段)，其他任务再进去打印。(而互斥型信号量由于必须由取得信号量的那个任务释放，故不会出现其他任务错误地释放了信号量的情况出现，故不需要有临界段。互斥型信号量是二进制信号量的子集。)

二进制信号量实现任务同步：
 a任务一直等待信号量，b任务定时释放信号量，完成同步功能

记录型信号量（record semaphore)：
   每个信号量s除一个整数值value（计数）外，还有一个等待队列List，其中是阻塞在该信号量的各个线程的标识。当信号量被释放一个，值被加一后，系统自动从等待队列中唤醒一个等待中的线程，让其获得信号量，同时信号量再减一。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

同步和互斥的区别：
 当有多个线程的时候，经常需要去同步这些线程以访问同一个数据或资源。例如，假设有一个程序，其中一个线程用于把文件读到内存，而另一个线程用于统计文件中的字符数。当然，在把整个文件调入内存之前，统计它的计数是没有意义的。但是，由于每个操作都有自己的线程，操作系统会把两个线程当作是互不相干的任务分别执行，这样就可能在没有把整个文件装入内存时统计字数。为解决此问题，你必须使两个线程同步工作。

 所谓互斥，是指散布在不同进程之间的若干程序片断，当某个进程运行其中一个程序片段时，其它进程就不能运行它们之中的任一程序片段，只能等到该进程运行完这个程序片段后才可以运行。如果用对资源的访问来定义的话，互斥某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的

 所谓同步，是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。如果用对资源的访问来定义的话，同步是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源
</code></pre>
]]></content>
  </entry>
  
</feed>
