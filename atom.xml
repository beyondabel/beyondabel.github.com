<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel's Den]]></title>
  <link href="http://www.beyondabel.com/atom.xml" rel="self"/>
  <link href="http://www.beyondabel.com/"/>
  <updated>2015-07-16T11:36:08+08:00</updated>
  <id>http://www.beyondabel.com/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我们能为世界做什么]]></title>
    <link href="http://www.beyondabel.com/blog/2014/06/25/young-people/"/>
    <updated>2014-06-25T09:52:23+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/06/25/young-people</id>
    <content type="html"><![CDATA[<ol>
<li><p>密码</p></li>
<li><p>用户名</p></li>
<li>性别</li>
<li>手机号码</li>
<li>邮箱</li>
<li>地址</li>
<li>生日</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac Unity3D安装及破解教程]]></title>
    <link href="http://www.beyondabel.com/blog/2014/04/07/unity3dinstall/"/>
    <updated>2014-04-07T17:41:20+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/04/07/unity3dinstall</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2014/04/07/unity3dInstall.png" alt="image" /></p>

<h3>引言</h3>

<p>Unity是由Unity Technologies开发的一个让玩家轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容的多平台的综合型游戏开发工具，是一个全面整合的专业游戏引擎。Unity类似于Director,Blender game engine, Virtools 或 Torque Game Builder等利用交互的图型化开发环境为首要方式的软件其编辑器运行在Windows 和Mac OS X下，可发布游戏至Windows、Mac、Wii、iPhone、Windows phone 8和Android平台。也可以利用Unity web player插件发布网页游戏，支持Mac 和Windows的网页浏览。它的网页播放器也被Mac widgets所支持。</p>

<!--more-->


<p>最近由于工作需要，涉及了Unity3D开发，作为一个Unity3D开发小白，把自己开发过程记录下来是非常有必要的，一个是以后再次涉及有笔记可看，同时也是方便其他朋友学习。</p>

<h3>目录</h3>

<ul>
<li>1、Unity3D下载及安装</li>
<li>2、Unity3D破解</li>
</ul>


<h3>1、Unity3D下载及安装</h3>

<p>Unity3D安装包可以到官网下载也可以点击 <a href="http://pan.baidu.com/s/1pJ4Tdmr">http://pan.baidu.com/s/1pJ4Tdmr</a> 下载。下载完之后按正常软件安装即可，这里就不做过多讲解。</p>

<h3>2、Unity3D破解</h3>

<p>如果你资金充足的话，建议还是去购买正版。如果是练手开发当然就没必须去购买了。</p>

<ul>
<li>1、下载Unity3D破解文件（这里给一个下载地址：<a href="http://pan.baidu.com/s/1gdoUvbt%EF%BC%89">http://pan.baidu.com/s/1gdoUvbt%EF%BC%89</a></li>
<li>2、在finder里找到unity，右键显示包内容，进入Contents/MacOS,找到Unity文件，一会我们要替换它（如果不放心可以县备份一下里面的Unity 文件）</li>
</ul>


<p><img src="http://www.beyondabel.com/images/2014/04/07/1.png" alt="image" /></p>

<ul>
<li>3、打开破解文件，用破解文件里的Unity 文件替换MacOS里的Unity文件</li>
<li>4、运行unity，点最右边的Manuak Activation按钮，然后选择load License找到破解文件里的Unity_v4.x.ulf，选择，成功后会提示载入成功</li>
</ul>


<p><img src="http://www.beyondabel.com/images/2014/04/07/2.png" alt="image" /></p>

<p><img src="http://www.beyondabel.com/images/2014/04/07/3.png" alt="image" /></p>

<p><img src="http://www.beyondabel.com/images/2014/04/07/4.png" alt="image" /></p>

<p>破解成功的标志：</p>

<ul>
<li>1、运行Unity后没有其他乱七八糟的提示。</li>
<li>2、点击状态栏的Unity，破解不成功的话有些选项是灰色不可点击的，例如About Unity&hellip;等</li>
</ul>


<p><img src="http://www.beyondabel.com/images/2014/04/07/5.png" alt="image" /></p>

<h2>&ndash; 3、点击About Unity&hellip;后会出现各种pro</h2>

<p><img src="http://www.beyondabel.com/images/2014/04/07/6.png" alt="image" /></p>

<p>这就说明你已经破解成功了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ARC VS MRC，这不是一个编程习惯问题]]></title>
    <link href="http://www.beyondabel.com/blog/2014/03/05/mrc-arc/"/>
    <updated>2014-03-05T10:21:40+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/03/05/mrc-arc</id>
    <content type="html"><![CDATA[<p><img src="http://www.beyondabel.com/images/2014/03/05/arcvsmrc.png" alt="image" /></p>

<h3>引言</h3>

<p>虽然距离WWDC2011和iOS5已经过去3年多时间了，但之前我一直没有去研究过ARC，一个是因为觉得ARC非常简单，到时什么时候想使用ARC时再转向ARC，第二个是担心内存管理不受自己控制（好吧，从现在来看是我对ARC机制了解不足而已），第三，我觉得使用MRC更能体现一个码农对内存管理的理解，第四，我是一个追求技术不“追赶时髦”的码农。说了这么多的原因，其实是想说作为一个最需要“追求时髦”的职业，我这样的心态是错误的。写这篇文章的目的是希望和我一同处于对 MAC &amp;　ARC迷茫的人的一个参考吧！</p>

<!--more-->


<h3>目录</h3>

<ul>
<li>1、 什么是ARC</li>
<li>2、 ARC工作原理</li>
<li>3、 MRC的代价</li>
<li>4、 ARC &amp; MAC 在大量数据下的测试</li>
<li>5、 CF与Objective-C在ARC下的内存管理</li>
<li>6、 使用ARC注意事项</li>
<li>7、 总结</li>
</ul>


<h4>1、什么是ARC</h4>

<p>什么是ARC，google一下，你会发现有太多太多对ARC非常非常详细的讲解。对于有C++背景的人来说，ARC的本质从某种角度上来说类似 C++ 的智能指针，区别就是ARC更智能简单，而且会加速程序，而不是像智能指针那样会一定程度上减慢程序运行。对于纯ObjC背景的人来说，ARC相当于编译器自动帮你填写了 retain, release。但是，远远不是这么简单。</p>

<p>首先ARC不会真的填写<code>retain/release</code>，<code>retain/release</code> 是 ObjC的消息，ARC会直接调用runtime的C函数，这会快很多。另外对于MRC中恶心的 <code>return [[[XXX alloc] init] autorelease]</code> ，ARC不但可以简化其写法，还可以让它更快，原因就在于它可以消除不必要的“入池”操作（<code>autorelease</code>是放到了自动释放池），详见objc_retainAutoreleasedReturnValue.</p>

<p>基于上面两点，ARC会让所有涉及到内存的操作变快。</p>

<p>ARC虽然会让单位内存操作变快，甚至会智能的取消某些<code>retain/release</code>，但是毕竟ARC不是人脑，如果一个人完全清晰的掌握某个对象的生命周期，那么他完全可以只retain一次，然后在最后不需要的时候release掉，所以MRC可以在这种情况下比ARC快。至于具体应用到项目中的数据，可以参考 <a href="http://www.learn-cocos2d.com/2013/12/performance-comparison-cocos2diphone-v2-v3-sparrow-arc-mrc/">http://www.learn-cocos2d.com/2013/12/performance-comparison-cocos2diphone-v2-v3-sparrow-arc-mrc/</a>  。其中有快有慢。</p>

<h4>2、 ARC工作原理</h4>

<p>手动内存管理的机理大家应该已经非常清楚了，简单来说，只要遵循以下三点就可以在手动内存管理中避免绝大部分的麻烦：</p>

<p>如果需要持有一个对象，那么对其发送retain 如果之后不再使用该对象，那么需要对其发送release（或者autorealse） 每一次对retain,alloc或者new的调用，需要对应一次release或autorealse调用</p>

<p>初学者可能仅仅只是知道这些规则，但是在实际使用时难免犯错。但是当开发者经常使用手动引用计数 MRC 的话，这些规则将逐渐变为本能。你会发现少一个release的代码怎么看怎么别扭，从而减少或者杜绝内存管理的错误。可以说MRC的规则非常简单，但是同时也非常容易出错。往往很小的错误就将引起crash或者内存溢出之类的严重问题。</p>

<p>在MRC的年代里，为了避免不小心忘写release，Xcode提供了一个很实用的小工具来帮助可能存在的代码问题(Xcode里默认快捷键command+B)，可以指出潜在的内存泄露或者过多释放。而ARC在此基础上更进一步：ARC是Objective-C编译器的特性，而不是运行时特性或者垃圾回收机制，ARC所做的只不过是在代码编译时为你自动在合适的位置插入release或autorelease，就如同之前MRC时你所做的那样。</p>

<h4>3、MRC的代价</h4>

<p>代码有好多代价，最简单直白的代价是编写时的代价，然后更重大的代价则是维护的代价。</p>

<p>编写的代价：
每个人的脑力都是有限的，而在编程的时候往往需要全心专注，这说明编程本身就耗费了100%的脑力。基于这个出发点，那么如果一个人在每写100行代码里面10行都是内存维护相关的代码时，他分配给其他的东西（程序结构，API设计，业务逻辑）肯定会减少，除非他愿意花更多的时间来写这个东西（加班）。注意，内存维护的10行代码并非简单地事情，要把他们搞正确，一个合格的MRC程序员肯定会前后审阅自己的代码好几遍。</p>

<p>维护的代价：
代码的本质是动态的，它会随着时间不停的改变自己，所以代码不但需要运行时健壮，同时还需要重构健壮，即你能安全的重构一段代码，而不是重构之后错误百出。这个举个常见例子：</p>

<p>在MRC下，有一个函数，在运行中间会 return 掉，那么所有合格的MRC程序员必然会记得在return之前把 alloc 的对象逐个 release 掉，咱不讨论在MRC下如果多几个中途return会让代码多么难写（这是编写代价），假设写好了，程序OK，没bug。然后某天重构了，把 return 提前了，然后由于位置提前，需要release的对象变成了另外一些，这会造成相当多的重构bug。另外一个例子，假设这个MRC程序员采用了极端的 retain/release 优化，那么在重构时必然要全面审视新的代码下面原来的优化是否安全，代价很高。那如果这些代码要交给别人重构呢？</p>

<p>维护代价的另一面是阅读时的代价。代码的价值是给人（别人或者自己）读，一行代码敲下去，可能要被读10遍，20遍。设想一下阅读到处穿插 <code>retain/ release</code> 的代码 vs 阅读清晰的业务逻辑的代码的容易程度对比。</p>

<h4>4、 ARC &amp; MAC 在大量数据下的测试</h4>

<p>下面举一个例子，同样的代码，只是在「ARC」与「MRC」的情況下编译执行， 但是二者所需要的时间是相差数倍的！</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">600000</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">10000000</span><span class="p">;</span>
</span><span class='line'><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">arr</span> <span class="nl">addObject</span><span class="p">:[</span><span class="bp">NSNumber</span> <span class="nl">numberWithInt</span><span class="p">:</span><span class="mi">1</span><span class="p">]];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFAbsoluteTime</span> <span class="n">start</span> <span class="o">=</span> <span class="n">CFAbsoluteTimeGetCurrent</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span> <span class="nl">objectAtIndex</span><span class="p">:</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">CFAbsoluteTime</span> <span class="n">end</span> <span class="o">=</span> <span class="n">CFAbsoluteTimeGetCurrent</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;end:%lf, start:%lf, diff:%lf&quot;</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">arr</span> <span class="k">release</span><span class="p">];</span> <span class="c1">// -&gt; 这一行是「MRC」需要加上的，但「ARC」沒有这行</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行结果：</p>

<pre><code>MRC:  end:358178433.846184, start:358178433.753032, diff:0.093152
ARC:    end:358178929.480108, start:358178928.841418, diff:0.638690
</code></pre>

<p>可以看出「MRC」的版本比「ARC」的版本快了近7倍！</p>

<p>但实际上程序是慢在哪呢？ &ndash;> 慢在 obj = [arr objectAtIndex:n &ndash; 1]; 这个地方， XCode 在 Compile 的时候，帮我們加上了类似下面的代码，</p>

<pre><code>obj = [[arr objectAtIndex:n - 1] retain];
[obj autorelease];
</code></pre>

<p>如果把「MRC」的版本修改为上述的代码，
则执行結果：</p>

<pre><code>MRC:  end:358179022.496308, start:358179021.894909, diff:0.601399
</code></pre>

<p>是不是就变慢了！
因此，XCode 在 Compile 的时候，我想它对代码的记忆管理是采取较保守的态度， 如此看來，iOS 5 预设 property 为 strong 也就不意外了！</p>

<p>那么上面所举的例子要怎么解決呢？ &ndash;> 我们可以透过 Toll-Free Bridged Types 来解決！ 来看一下，我们将 ARC 的版本的代码改成下面这个样子： 將NSArray改成使用CFArrayRef， 这是 Foundation class &ndash;> Core Foundation type 的转换， 这样的转换是 Toll-Free 的！</p>

<pre><code>__unsafe_unretained id obj;
for (int j = 0; j &lt; m; j++){
  obj = (__bridge __unsafe_unretained id)CFArrayGetValueAtIndex((__bridge CFArrayRef)arr, n - 1);
}
</code></pre>

<p>如果把「ARC」的版本修改为上述的代码，
则执行结果：</p>

<pre><code>MRC:  end:358179460.237259, start:358179460.004701, diff:0.232558
</code></pre>

<p>是不是就变快了！(但还沒有办法跟原本的「MRC」版本一样快！)
所以其实写程序的時候要多想一下有沒有其它作法， 因为不同的写法虽然可能是相同結果， 但所需要的时间是不同的， 在使用 ARC 時， 如果能清楚的知道自己所创建的物件是被 retain 的状态， 那么在传递的过程中就可以视需求决定接收此物件是要 retain 或只是 assign， 这样可以让 XCode 在 Compile 的时候， 依照我们給它的指示去产生记忆体管理的代码， 避免不必要或多余的效能损失！</p>

<h4>5、 CF与Objective-C在ARC下的内存管理</h4>

<p>在cocoa application的应用中，我们有时会使用Core Foundation(CF),我们经常会在Objective-C和CF之间进行转化。系统使用arc的状态下，编译器不能自动管理CF的内存，这时候你必须使用CFRetain和CFRelease来进行CF的内存的管理。</p>

<p>具体的CF内存管理规则见： Memory Management Programming Guide for Core Foundation</p>

<p>在OC和FC之间进行转化的时候，主要是对象的归属问题。共有两种方式：</p>

<p>1、使用宏，可以标识归属者从OC到CF，还是从CF到OC。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NS_INLINE</span> <span class="n">CFTypeRef</span> <span class="nf">CFBridgingRetain</span><span class="p">(</span><span class="kt">id</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="n">__bridge_retain</span> <span class="n">CFTypeRef</span><span class="p">)</span><span class="n">X</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NS_INLINE</span> <span class="kt">id</span> <span class="nf">CFBridgingRelease</span><span class="p">(</span><span class="n">CFTypeRef</span> <span class="n">X</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="kt">id</span><span class="p">)</span><span class="n">X</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
2、使用转化符,如：<code>__bridge</code>，<code>__bridge_transfer</code>，<code>__bridge_retained</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">my_id</span><span class="p">;</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">my_cfref</span><span class="p">;</span>
</span><span class='line'><span class="err">…</span>
</span><span class='line'><span class="bp">NSString</span>   <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">my_cfref</span><span class="p">;</span>     <span class="c1">// Noop cast. </span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">my_id</span><span class="p">;</span>      <span class="c1">// Noop cast. </span>
</span><span class='line'><span class="err">…</span>
</span><span class='line'><span class="bp">NSString</span>   <span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="n">my_cfref</span><span class="p">;</span> <span class="c1">// -1 on the CFRef </span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">my_id</span><span class="p">;</span>  <span class="c1">// returned CFRef is +1</span>
</span></code></pre></td></tr></table></div></figure>


<p>
下面以详细的例子来介绍一下OC和CF在arc下内存管理的详细写法.下面以CFURLCreateStringByAddingPercentEscapes()函数为例说一下在ARC下的写法和非ARC下的写法。</p>

<p>非ARC模式下的写法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark – View lifecycle </span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">escape</span><span class="p">:</span><span class="s">@&quot;wangjun&quot;</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">));;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
使用instruments检测，没有内存泄漏。</p>

<p>下面把上面工程改为arc模式。</p>

<p>可以看到xcode自动把上面函数转化为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark – View lifecycle </span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">super</span> <span class="n">viewDidLoad</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;=%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">escape</span><span class="p">:</span><span class="s">@&quot;wangjun&quot;</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">__bridge_transfer</span> <span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在arc中，CF和OC之间的转化桥梁是 __bridge，有两种方式：</p>

<ul>
<li>__bridge_transfer  ARC接管管理内存</li>
<li>__bridge_retained  ARC释放内存管理</li>
</ul>


<p>上面的方法是从CF转化为OC NSString对象，使用的__bridge_transfer ，对象所有者发生转变，由CF到OC，最后由ARC接管内存管理。运行上面的代码，用instruments检测，是没有内存泄漏的。</p>

<p>上面代码等同于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">CFBridgingRelease</span><span class="p">(</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">)));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果将上述代码改为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nf">escape:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">text</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">(</span><span class="k">__bridge</span> <span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="n">CFURLCreateStringByAddingPercentEscapes</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,(</span><span class="k">__bridge</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">text</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CFSTR</span><span class="p">(</span><span class="s">&quot;!*’();:@&amp;=+$,/?%#[]&quot;</span><span class="p">),</span> <span class="n">CFStringConvertNSStringEncodingToEncoding</span><span class="p">(</span><span class="n">NSUTF8StringEncoding</span><span class="p">));;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
编译也会成功，但是这时候用instruments检测，可以发现内存泄漏：</p>

<p>由于CF转化完OC，没有自己释放内存，同时也没有把内存管理交给ARC，所以出现内存泄漏。由于__bridge只是同一个对象的引用，内存的所有权没有发生变化。</p>

<p>下面在说一下oc到CF的转化，需要把OC的内存管理权释放掉。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">s1</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSString</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFormat</span><span class="p">:</span><span class="s">@&quot;Hello, %@!&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">];</span>
</span><span class='line'><span class="n">CFStringRef</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">(</span><span class="n">__bridge_retained</span> <span class="n">CFStringRef</span><span class="p">)</span><span class="n">s1</span><span class="p">;</span>
</span><span class='line'><span class="c1">// do something with s2 // . . . </span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>
最后由CF进行内存释放。</p>

<p>上面代码等同于：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CFStringRef</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">CFBridgingRetain</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
</span><span class='line'><span class="c1">// . . . </span>
</span><span class='line'><span class="n">CFRelease</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>
下面总结一下我们使用ARC情况下。oc和CF互相转化的原则：</p>

<ul>
<li>CF转化为OC时，并且对象的所有者发生改变，则使用<code>CFBridgingRelease()</code>或<code>__bridge_transfer</code> 。</li>
<li>OC转化为CF时，并且对象的所有者发生改变，则使用<code>CFBridgingRetain()</code>或<code>__bridge_retained</code></li>
</ul>


<p>当一个类型转化到另一种类型时，但是对象所有者没有发生改变，则使用__bridge.</p>

<h4>6、 使用ARC注意事项</h4>

<ul>
<li>属性命名不能用new开头</li>
<li>不再使用<code>retain</code>， <code>relase</code>， <code>autorelease</code>。</li>
<li><p>对<code>strong</code>,<code>weak</code>,<code>assign</code>,<code>copy</code>,<code>__weak</code>，<code>__strong</code>，<code>__autorelease</code>，<code>@autorelease{}</code>等的使用需要学习一下（特别注意一下<code>__weak</code>, <code>__strong</code>, <code>__autorelease</code>应该写在指针后边，变量名前面，否则不是正确写法，只是编译器会做一些处理）。</p></li>
<li><p>重写dealloc方法不调用[super dealloc]方法。</p></li>
<li><p>第三方库不支持arc，要將每个相关文件设置-fno-objc-arc。</p></li>
<li><p>arc对core foundation无效，需要自己控制内存，包括释放，并且需要cast的时候要用 <code>__bridge</code>，<code>__bridge_retain</code>，<code>__bridge_transfer</code>等修饰来控制对应内存。</p></li>
<li><p>arc和block的时候需要注意循环引用的问题。</p></li>
<li><p>还有和C混用的时候需要注意，先將对象赋nil再free掉相关内存。避免使用 C 的 memcpy 和 realloc 函数等等。</p></li>
<li>在dealloc中把成员变量置nil</li>
</ul>


<h4>7、 总结</h4>

<p>ARC相对于MRC时弱引用时运行效率确实会慢一些，但他在<code>[[[XXX alloc] init] autorelease]</code>时ARC不但可以简化其写法，还可以让它更快的处理，减少不必要的入池操作，而且他的优势也是十分明显的。ARC只是为了提高您的工作效率，而不是一个神奇而没有缺点的一项技术。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSObjective-C之id/NSObject/id&lt;NSObject>区别]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/16/ios-nsobject-id-difference/"/>
    <updated>2014-02-16T16:23:26+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/16/ios-nsobject-id-difference</id>
    <content type="html"><![CDATA[<h3>概述</h3>

<p>我们在iOS开发过程中，经常会碰到id、NSObject、id&lt; NSObject>，但我们也经常会混淆这三种申明（我之前也不是很留意这个），现在Abel带你一起去看看他们的真实面目。</p>

<!--more-->


<h3>目录</h3>

<ul>
<li>1、 id</li>
<li>2、 NSObject *</li>
<li>3、 id&lt;NSObject></li>
<li>4、 如何选择你要用的类型</li>
<li>5、 补充说明</li>
</ul>


<h4>1、 id</h4>

<p>第一种是最常用的，它简单地申明了指向对象的指针，没有给编译器任何类型信息，因此，编译器不会做类型检查。但也因为是这样，你可以发送任何信息给id类型的对象。这就是为什么+alloc返回id类型，但调用[[Foo alloc] init]不会产生编译错误。</p>

<p>因此，id类型是运行时的动态类型，编译器无法知道它的真实类型，即使你发送一个id类型没有的方法，也不会产生编译警告。</p>

<h4>2、 NSObject *</h4>

<p>我们知道，id类型是一个Objective-C对象，但并不是都指向继承自NSOjbect的对象，即使这个类型和NSObject对象有很多共同的方法，像retain和release。要让编译器知道这个类继承自NSObject，一种解决办法就是像第2种那样，使用NSObject静态类型，当你发送NSObject没有的方法，像length或者count时，编译器就会给出警告。这也意味着，你可以安全地使用像retain，release，description这些方法。</p>

<p>因此，申明一个通用的NSObject对象指针和你在其它语言里做的类似，像java，但其它语言有一定的限制，没有像Objective-C这样灵活。并不是所有的Foundation/Cocoa对象都继承息NSObject，比如NSProxy就不从NSObject继承，所以你无法使用NSObject＊指向这个对象，即使NSProxy对象有release和retain这样的通用方法。为了解决这个问题，这时候，你就需要一个指向拥有NSObject方法对象的指针，这就是第3种申明的使用情景。</p>

<h4>3、 id&lt;NSObject></h4>

<p>id&lt;NSObject>告诉编译器，你不关心对象是什么类型，但它必须遵守NSObject协议(protocol)，编译器就能保证所有赋值给id&lt;NSObject>类型的对象都遵守NSObject协议(protocol)。这样的指针可以指向任何NSObject对象，因为NSObject对象遵守NSObject协议(protocol)，而且，它也可以用来保存NSProxy对象，因为它也遵守NSObject协议(protocol)。这是非常强大，方便且灵活，你不用关心对象是什么类型，而只关心它实现了哪些方法。</p>

<h4>4、 如何选择你要用的类型</h4>

<p>如果你不需要任何的类型检查，使用id，它经常作为返回类型，也经常用于申明代理(delegate)类型。因为代理类型通常在运行时，才会检查是否实现了那些方法。</p>

<p>如果真的需要编译器检查，那你就考虑使用第2种或者第3种。很少看到NSObject＊能正常运行，但id&lt;NSObject>无法正常运行的。使用协议(protocol)的优点是，它能指向NSProxy对象，而更常用的情况是，你只想知道某个对象遵守了哪个协议，而不用关心它是什么类型。</p>

<h4>5、补充说明</h4>

<ul>
<li>id 还可以表示基础类型，但是不能表示float，double类型</li>
<li>NSObject *foo2; 如果使用这种形式，用到的时候需要强制类型转换，可能会很麻烦</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective C之Block教程]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/15/ios-block/"/>
    <updated>2014-02-15T21:06:42+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/15/ios-block</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>Block是C级别的语法和运行时特性。Block比较类似C函数，但是Block比之C函数，其灵活性体现在栈内存、堆内存的引用，我们甚至可以将一个Block作为参数传给其他的函数或者Block。</p>

<!--more-->


<h3>目录</h3>

<ul>
<li>一、Block的基本介绍

<ul>
<li>1、什么是Block</li>
<li>2、Block和C语言函数指针和什么区别</li>
<li>3、如何调用Block</li>
</ul>
</li>
<li>二、Block内存管理与其他特性

<ul>
<li>1、Block放在哪里</li>
<li>2、Block引用的变量在哪里</li>
</ul>
</li>
<li>三、Block揭开神秘面纱</li>
</ul>


<h4>一、Block的基本介绍</h4>

<h5>1、什么是Block</h5>

<p>Block是一个C Level的语法以及运行时的一个特性，和标准C中的函数（函数指针）类似，但是其运行需要编译器和运行时支持，从iOS4.0开始就很好的支持Block了。广泛用于两个对象之前的回调函数。</p>

<p>下面我们来看一下Block的声明：</p>

<pre><code>int(^hbFunction) (BOOL a);
</code></pre>

<p>其中int为block的返回类型，hbFunction为block名称，a为参数。</p>

<h5>2、Block和C语言函数指针和什么区别</h5>

<p>首先我们来看看C函数指针：</p>

<pre><code>int (* hbFunction) (int a);  // 函数声明
int resut = hbFunction(10);  // 函数调用
</code></pre>

<p>再看看Block的用法：</p>

<pre><code>int (^ hbFunction) (int a);  // 函数声明
int resut = hbFunction(10);   // 函数调用
</code></pre>

<p>C语言函数指针typedef</p>

<pre><code>typedef int (*SumFunction)(int a,int b);
</code></pre>

<p>Block中的typedef</p>

<pre><code>typedef int (^SumBlock)(int a,int b);   
</code></pre>

<h5>3、如何调用Blocks</h5>

<p>主动调用一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">someMethod</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">BoolBlock</span> <span class="n">ablock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Bool block!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">ablock</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>作为参数返回：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">^</span><span class="n">BoolBlock</span><span class="p">)(</span><span class="kt">BOOL</span><span class="p">);</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">BoolBlock</span><span class="p">)</span><span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">BoolBlock</span> <span class="n">ablock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Bool block!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[[</span><span class="n">ablock</span> <span class="k">copy</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span><span class="c1">//一定要copy，将其复制到堆上，更详细的原理，将在后续章节讲解</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类的一个成员：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">OBJ1</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span><span class="n">BoolBlock</span> <span class="n">block</span><span class="p">;</span><span class="c1">//理由同上啊，同学们</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">OBJ1</span> <span class="o">*</span><span class="n">obj1</span> <span class="o">=</span> <span class="p">...</span>
</span><span class='line'><span class="n">obj1</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bValue</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Bool block!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
其他函数的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo</span><span class="p">(</span><span class="n">BoolBlock</span> <span class="n">block</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">block</span><span class="p">();</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
甚至其他block的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">BoolBlock</span> <span class="n">bBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">BOOL</span> <span class="n">bV</span><span class="p">){</span><span class="k">if</span><span class="p">(</span><span class="n">Bv</span><span class="p">){</span><span class="cm">/*do some thing*/</span><span class="p">}};</span>
</span><span class='line'><span class="n">HugeBlock</span> <span class="n">hBlock</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">BoolBlock</span> <span class="n">bB</span><span class="p">)</span> <span class="p">{</span><span class="n">bB</span><span class="p">();};</span>
</span><span class='line'>
</span><span class='line'><span class="n">hBolck</span><span class="p">(</span><span class="n">bBlock</span><span class="p">);</span>   
</span></code></pre></td></tr></table></div></figure>


<h4>二、Block内存管理与其他特性</h4>

<h5>1、Block放在哪里</h5>

<h6>1.1栈和堆</h6>

<p>以下情况中的block位于堆中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blkInHeap</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d, %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);};</span><span class="c1">//blk在栈里</span>
</span><span class='line'>  <span class="n">blkInHeap</span> <span class="o">=</span> <span class="n">Block_copy</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span><span class="c1">//blkInHeap在堆里</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fooBar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">_oi</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="n">OBJ1</span><span class="o">*</span> <span class="n">oj</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">oblk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oj</span><span class="p">.</span><span class="n">oi</span><span class="p">);};</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">oblkInHeap</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">oblk</span> <span class="k">copy</span><span class="p">];</span><span class="c1">//oblkInHeap在堆中</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h6>1.2全局</h6>

<p>以下情况中的block位于全局区：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="nf">int</span><span class="p">(</span><span class="o">^</span><span class="n">maxIntBlock</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span><span class="k">return</span> <span class="n">a</span><span class="o">&gt;</span><span class="n">b</span><span class="o">?</span><span class="nl">a</span><span class="p">:</span><span class="n">b</span><span class="p">;};</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fooBar</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">maxIntBlockCopied</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span><span class="p">[</span><span class="n">maxIntBlock</span> <span class="k">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span><span class="p">(</span><span class="o">^</span><span class="n">maxIntBlockCopied</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">Block_copy</span><span class="p">(</span><span class="n">maxIntBlock</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，这里复制过后的block依旧位于全局区，实际上，复制操作是直接返回了原block对象。</p>

<h5>2、Block引用的变量在哪里</h5>

<h5>1.全局区</h5>

<p>全局区的变量存储位置与block无关：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">gVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="c1">//__block static int gMVar = 1;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">static</span> <span class="kt">int</span> <span class="n">stackVar</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="c1">//    __block static int stackMVar = 0;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
注意，static变量是不允许添加__block标记的</p>

<h5>2.堆栈</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span> <span class="c1">// 此时i在栈上</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 此时j在栈上</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d,  %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'>  <span class="p">};</span>   <span class="c1">//此时blk位于栈上，其使用的变量也在栈上</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">blk</span><span class="p">();</span>
</span><span class='line'>  <span class="n">j</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">^</span><span class="n">blkInHeap</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="n">Block_copy</span><span class="p">(</span><span class="n">blk</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// 复制block后，block位于堆上，有__block标记的i会被复制一份至堆，而没有__block标记的j并不会动依旧位于栈上。</span>
</span><span class='line'>  
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>三、Block揭开神秘面纱</h4>

<h5>1、Block到底是什么</h5>

<p>我们使用clang的rewrite-objc命令来获取转码后的代码。</p>

<p>我们来看看最简单的一个block：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">__block</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="n">blk</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i :%d,j:%d,&amp;i:%p,&amp;j:%p&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个block仅仅打印栈变量i和j的值，其被clang转码为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
</span><span class='line'>    <span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>    <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span><span class="kt">int</span> <span class="n">_j</span><span class="p">,</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">_i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">j</span><span class="p">(</span><span class="n">_j</span><span class="p">),</span><span class="kt">int</span><span class="p">(</span><span class="n">_i</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">){</span>
</span><span class='line'>         <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>         <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>         <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>         <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">){</span>
</span><span class='line'>   <span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">j</span><span class="p">;</span>
</span><span class='line'>   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i :%d,j:%d,&amp;i:%p,&amp;j:%p&quot;</span><span class="p">,</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="o">&amp;</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">),</span><span class="o">&amp;</span><span class="n">j</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">src</span><span class="p">){</span>
</span><span class='line'>   <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">src</span><span class="p">){</span>
</span><span class='line'>   <span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="p">{</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">,</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span><span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">),</span><span class="n">__main_block_copy_0</span><span class="p">,</span><span class="n">__main_block_dispose_0</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_i_0</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_i_0</span><span class="p">),</span><span class="mi">1024</span><span class="p">};</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">blk</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'>  <span class="n">blk</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span> <span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span><span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span><span class="n">j</span><span class="p">,(</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="mi">570425344</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>首先是一个结构体<code>__main_block_impl_0</code>（从图二中的最后一行可以看到，block是一个指向<code>__main_block_impl_0</code>的指针，初始化后被类型强转为函数指针），其中包含的<code>__block_impl</code>是一个公共实现（学过c语言的同学都知道，<code>__main_block_impl_0</code>的这种写法表示其可以被类型强转为<code>__block_impl</code>类型）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>          <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>          <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>
 isa指针说明block可以成为一个objc 对象。</p>

<pre><code>__main_block_impl_0的意思是main函数中的第0个block的implementation，这就是这个block的主体了。
</code></pre>

<p>这个结构体的构造函数的参数：</p>

<ul>
<li><p>1、block实际执行代码所在的函数的指针，当block真正被执行时，实际上是调用了这个函数，其命名也是类似的方式。</p></li>
<li><p>2、block的描述结构体，注意这个结构体声明结束时就创建了一个唯一的desc，这个desc包含了block的大小，以及复制和析构block时需要额外调用的函数。</p></li>
<li><p>3、接下来是block所引用到的变量们</p></li>
<li><p>4、最后是一个标记值，内部实现需要用到的。（我用计算器看了一下，570425344这个值等于1&lt;&lt;29，即BLOCK_HAS_DESCRIPTOR这个枚举值）</p></li>
</ul>


<p>所以，我们可以看到：</p>

<ul>
<li>1、为什么上一篇我们说j已经不是原来的j了，因为j是作为参数传入了block的构造函数，进行了值复制。</li>
<li>2、带有__block标记的变量会被取地址来传入构造函数，为修改其值奠定了基础</li>
</ul>


<p>接下来是block执行函数<code>__main_block_func_0</code>:</p>

<p>其唯一的参数是<code>__main_block_impl_0</code>的指针，我们看到printf语句的数据来源都取自<code>__cself</code>这个指针，比较有意思的是i的取值方式（带有<code>__block</code>标记的变量i被转码为一个结构体），先取<code>__forward</code>指针，再取i，这为将i复制到堆中奠定了基础。</p>

<p>再下来是预定义好的两个复制/释放辅助函数，其作用后面会讲到。</p>

<p>最后是block的描述信息结构体 <code>__main_block_desc_0</code>，其包含block的内存占用长度，已经复制/释放辅助函数的指针，其声明结束时，就创建了一个名为<code>__main_block_desc_0_DATA</code>的结构体，我们看它构造时传入的值，这个DATA结构体的作用就一目了然了：</p>

<p>长度用sizeof计算，辅助函数的指针分别为上面预定义的两个辅助函数。</p>

<pre><code>注意，如果这个block没有使用到需要在block复制时进行copy/retian的变量，那么desc中不会有辅助函数
</code></pre>

<p>至此，一个block所有的部件我们都看齐全了，一个主体，一个真正的执行代码函数，一个描述信息(可能包含两个辅助函数)。</p>

<h5>2、构造一个block</h5>

<p>我们进入main函数：</p>

<p>图一中的第三行（block的声明），在图二中，转化为一个函数指针的声明，并且都没有被赋予初始值。
而图一中的最后一行（创建一个block），在图二中，成为了对<code>__main_block_impl_0</code>的构造函数的调用，传入的参数的意义上面我们已经讲过了。</p>

<p>所以构造一个block就是创建了<code>__main_block_impl_0</code> 这个c++类的实例。</p>

<h5>3、调用一个block</h5>

<p>调用一个block的写法很简单，与调用c语言函数的语法一样：</p>

<pre><code>blk();
</code></pre>

<p>其转码后的语句：</p>

<pre><code>((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);
</code></pre>

<p>将blk这个函数指针类型强转为<strong>block_impl类型，然后取其执行函数指针，然后将此指针类型强转为返回void*并接收一个</strong>block_impl<em>的函数指针，最后调用这个函数，传入强转为__block_impl</em>类型的blk，</p>

<p>即调用了前述的函数__main_block_func_0</p>

<h5>4、objective-c类成员函数中的block</h5>

<p>源码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">of1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">OBJ1</span><span class="o">*</span> <span class="n">oj</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">oblk</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">oj</span><span class="p">.</span><span class="n">oi</span><span class="p">);};</span>
</span><span class='line'>  <span class="n">Block_copy</span><span class="p">(</span><span class="n">oblk</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这里我故意将self赋值给oj这个变量，是为了验证前一章提出的一个结论：无法通过简单的间接引用self来防止retain循环，要避免循环，我们需要__block标记（多谢楼下网友的提醒）
转码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__OBJ1__of1_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__OBJ1__of1_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>          <span class="n">OBJ1</span> <span class="o">*</span><span class="n">oj</span><span class="p">;</span>
</span><span class='line'>          <span class="n">__OBJ1__of1_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__OBJ1__of1_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">OBJ1</span> <span class="o">*</span><span class="n">_oj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">oj</span><span class="p">(</span><span class="n">_oj</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>  <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>  <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__OBJ1__of1_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__OBJ1__of1_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">OBJ1</span> <span class="o">*</span><span class="n">oj</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">oj</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">((</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">oj</span><span class="p">,</span>         <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;oi&quot;</span><span class="p">)));</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
objc方法中的block与c中的block并无太多差别，只是一些标记值可能不同，为了标记其是objc方法中的blcok。</p>

<p>注意其构造函数的参数:OBJ1 *_oj</p>

<p>这个<em>oj在block复制到heap时，会被retain，而</em>oj与self根本就是相等的，所以，最终retain的就是self，所以如果当前实例持有了这个block，retain循环就形成了。</p>

<p>而一旦为其增加了__block标记：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">of1</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">__block</span> <span class="n">OBJ1</span> <span class="o">*</span><span class="n">bSelf</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="o">^</span><span class="p">{</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">bSelf</span><span class="p">.</span><span class="n">oi</span><span class="p">);</span> <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
其转码则变为：</p>

<p>//增加了如下行</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_bSelf_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_bSelf_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="n">OBJ1</span> <span class="o">*</span><span class="n">bSelf</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_copy_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">40</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_dispose_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_dispose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<pre><code>//声明处变为
__block __Block_byref_bSelf_0 bSelf = {(void*)0,(__Block_byref_bSelf_0 *)&amp;bSelf, 33554432, sizeof(__Block_byref_bSelf_0),   __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, self};
</code></pre>

<p>clang为我们的bSelf结构体创建了自己的copy/dispose辅助函数，33554432（即1&lt;&lt;25 BLOCK_HAS_COPY_DISPOSE）这个值告诉系统，我们的bSelf结构体具有copy/dispose辅助函数。</p>

<p>而131这个参数（二进制1000 0011，即BLOCK_FIELD_IS_OBJECT (3) |BLOCK_BYREF_CALLER（128））
中的BLOCK_BYREF_CALLER在内部实现中告诉系统不要进行retain或者copy，
也就是说，在 __block bSelf 被复制至heap上时，系统会发现有辅助函数，而辅助函数调用后，并不retain或者copy 其结构体内的bSelf。
这样就避免了循环retain。</p>

<h4>2、内存管理的真面目</h4>

<p>objc层面如何区分不同内存区的block</p>

<p>Block_private.h中有这样一组值：</p>

<pre><code>/* the raw data space for runtime classes for blocks */
/* class+meta used for stack, malloc, and collectable based blocks */
BLOCK_EXPORT void * _NSConcreteStackBlock[32];
BLOCK_EXPORT void * _NSConcreteMallocBlock[32];
BLOCK_EXPORT void * _NSConcreteAutoBlock[32];
BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32];
BLOCK_EXPORT void * _NSConcreteGlobalBlock[32];
BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32];
</code></pre>

<p>其用于对block的isa指针赋值
1.栈</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__OBJ1__of2_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>          <span class="k">struct</span> <span class="n">__OBJ1__of2_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>          <span class="n">OBJ1</span> <span class="o">*</span><span class="nb">self</span><span class="p">;</span>
</span><span class='line'>          <span class="n">__OBJ1__of2_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__OBJ1__of2_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">OBJ1</span> <span class="o">*</span><span class="n">_self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="nb">self</span><span class="p">(</span><span class="n">_self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>      <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>      <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>      <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在栈上创建的block，其isa指针是_NSConcreteStackBlock。</p>

<h5>2.全局区</h5>

<p>在全局区创建的block，其比较类似，其构造函数会将isa指针赋值为_NSConcreteGlobalBlock。</p>

<h5>3.堆</h5>

<p>我们无法直接创建堆上的block，堆上的block需要从stack block拷贝得来，在runtime.c中的_Block_copy_internal函数中，有这样几行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Its a stack block.  Make a copy.</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isGC</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">result</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">_NSConcreteMallocBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
可以看到，栈block复制得来的新block，其isa指针会被赋值为_NSConcreteMallocBlock</p>

<h5>4.其余的isa类型</h5>

<pre><code>BLOCK_EXPORT void * _NSConcreteAutoBlock[32];
BLOCK_EXPORT void * _NSConcreteFinalizingBlock[32];
BLOCK_EXPORT void * _NSConcreteWeakBlockVariable[32];
</code></pre>

<p>其他三种类型是用于gc和arc，我们暂不讨论</p>

<p>复制block</p>

<p> 对block调用Block_copy方法，或者向其发送objc copy消息，最终都会调用runtime.c中的<code>_Block_copy_internal</code>函数，其内部实现会检查block的flag，从而进行不同的操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_Block_copy_internal</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="n">aBlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>1.栈block的复制</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="c1">// reset refcount</span>
</span><span class='line'> <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">);</span>    <span class="c1">// XXX not needed</span>
</span><span class='line'> <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BLOCK_NEEDS_FREE</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'> <span class="n">result</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">_NSConcreteMallocBlock</span><span class="p">;</span>
</span><span class='line'> <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_HAS_COPY_DISPOSE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="c1">//printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span>
</span><span class='line'>     <span class="p">(</span><span class="o">*</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="k">copy</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">);</span> <span class="c1">// do fixup</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了修改isa指针的值之外，拷贝过程中，还会将BLOCK_NEEDS_FREE置入，大家记住这个值，后面会用到。
最后，如果block有辅助copy/dispose函数，那么辅助的copy函数会被调用。</p>

<p>2.全局block的复制</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_IS_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
全局block进行copy是直接返回了原block，没有任何的其他操作。</p>

<p>3.堆block的复制</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// latches on high</span>
</span><span class='line'>    <span class="n">latching_incr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
栈block复制时，置入的BLOCK_NEEDS_FREE标记此时起作用，_Block_copy_internal函数识别当前block是一个堆block，则仅仅增加引用计数，然后返回原block。</p>

<p>辅助copy/dispose函数</p>

<p>1.普通变量的复制
辅助copy函数用于拷贝block所引用的可修改变量，我们这里以 __block int i = 1024为例：
先看看Block_private.h中的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Block_byref</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">forwarding</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* refcount; */</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">byref_keep</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">byref_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="cm">/* long shared[0]; */</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>
而我们的__block int i = 1024的转码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_i_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span><span class="c1">//所以我们知道，当此结构体被类型强转为Block_byref时，前四个成员是一致的，访问flags就相当于访问__flags，而内部实现就是这样使用的</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_i_0</span> <span class="n">i</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span>    <span class="p">(</span><span class="n">__Block_byref_i_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_i_0</span><span class="p">),</span> <span class="mi">1024</span><span class="p">};</span><span class="c1">//i初始化时__flags为0</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span>    <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时，复制时调用的辅助函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span><span class="c1">//此处flags为8，即BLOCK_FIELD_IS_BYREF</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>      <span class="c1">// copying a __block reference from the stack Block to the heap</span>
</span><span class='line'>      <span class="c1">// flags will indicate if it holds a __weak reference and needs a special isa</span>
</span><span class='line'>          <span class="n">_Block_byref_assign_copy</span><span class="p">(</span><span class="n">destAddr</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_Block_byref_assign_copy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span><span class="c1">//此处flags为8，即BLOCK_FIELD_IS_BYREF</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="n">destp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span><span class="c1">//当初次拷贝i时，flags为0，进入此分支会进行复制操作并改变flags值，置入BLOCK_NEEDS_FREE和初始的引用计数</span>
</span><span class='line'>   <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// already copied to heap</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span><span class="c1">//当再次拷贝i时，则仅仅增加其引用计数</span>
</span><span class='line'>      <span class="n">latching_incr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// assign byref data block pointer into new Block</span>
</span><span class='line'>  <span class="n">_Block_assign</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">destp</span><span class="p">);</span><span class="c1">//这句仅仅是直接赋值，其函数实现只有一行赋值语句，查阅runtime.c可知</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
所以，我们知道，当我们多次copy一个block时，其引用的__block变量只会被拷贝一次。</p>

<p>2.objc变量的复制</p>

<p>当objc变量没有__block修饰时：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__OBJ1__of2_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__OBJ1__of2_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__OBJ1__of2_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">//printf(&quot;retaining object at %p\n&quot;, object);</span>
</span><span class='line'>      <span class="n">_Block_retain_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span><span class="c1">//当我们没有开启arc时，这个函数会retian此object</span>
</span><span class='line'>      <span class="c1">//printf(&quot;done retaining object at %p\n&quot;, object);</span>
</span><span class='line'>      <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="p">....</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
当objc变量有__block修饰时：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_bSelf_0</span> <span class="p">{</span>
</span><span class='line'>          <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_bSelf_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>      <span class="n">OBJ1</span> <span class="o">*</span><span class="n">bSelf</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_copy_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">40</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span><span class="c1">//131即为BLOCK_FIELD_IS_OBJECT|BLOCK_BYREF_CALLER</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Block_byref_id_object_dispose_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">_Block_object_dispose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span> <span class="c1">//33554432即为BLOCK_HAS_COPY_DISPOSE</span>
</span><span class='line'>
</span><span class='line'><span class="k">__block</span> <span class="n">__Block_byref_bSelf_0</span> <span class="n">bSelf</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_bSelf_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">bSelf</span><span class="p">,</span> <span class="mi">33554432</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_bSelf_0</span><span class="p">),</span> <span class="n">__Block_byref_id_object_copy_131</span><span class="p">,</span> <span class="n">__Block_byref_id_object_dispose_131</span><span class="p">,</span> <span class="nb">self</span><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>BLOCK_HAS_COPY_DISPOSE告诉内部实现，这个变量结构体具有自己的copy/dispose辅助函数，而此时我们的内部实现不会进行默认的复制操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">//printf(&quot;_Block_object_assign(*%p, %p, %x)\n&quot;, destAddr, object, flags);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_WEAK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">_Block_assign_weak</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// do *not* retain or *copy* __block variables whatever they are</span>
</span><span class='line'>        <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>  <br/>
当我们没有开启arc，且flags中具有BLOCK_BYREF_CALLER时，会进入_Block_assign函数，而此函数仅仅是赋值
所以，如果要避免objc实例中的block引起的循环引用，我们需要让block间接使用self：</p>

<pre><code>__block bSelf = self;
</code></pre>

<p>其他</p>

<p>对于dipose辅助函数，其行为与copy是类似的，我们不再重复同样的东西，如果大家要了解，自行查阅runtime.c和Block_private.h即可。</p>

<p>我们已经理解了非arc非gc情况下的block的内存管理内部实现，对arc和gc的情况，其行为也是类似的，只是一些函数的指针指向的真正函数会改变，比如_Block_use_GC函数，会将一些函数指向其他的实现，使其适用于gc开启的情况。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS安全攻防（一）：Hack必备的命令与工具]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/11/iossafety-hacktools/"/>
    <updated>2014-02-11T23:32:27+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/11/iossafety-hacktools</id>
    <content type="html"><![CDATA[<h3>Hack必备的命令与工具</h3>

<p>你的应用正在被其他对手反向工程、跟踪和操作！你的应用是否依旧裸奔豪不防御？
郑重声明一下，懂得如何攻击才会懂得如何防御，一切都是为了之后的防御作准备。废话少说，进入正题。
今天总结一下为hack而做的准备工作。</p>

<!--more-->


<h3>常用的命令和工具</h3>

<pre><code>ps           ——显示进程状态，CPU使用率，内存使用情况等
sysctl       ——检查设定Kernel配置
netstat      ——显示网络连接，路由表，接口状态等
route        ——路由修改
renice       ——调整程序运行的优先级
ifconfig     ——查看网络配置
tcpdump      ——截获分析网络数据包
lsof         ——列出当前系统打开的文件列表，别忘记一切皆文件，包括网络连接、硬件等
otool ①     ——查看程序依赖哪些动态库信息，反编代码段……等等等等
nm ②        ——显示符号表
ldid ③      ——签名工具
gdb         ——调试工具
patch       ——补丁工具
SSH         ——远程控制
</code></pre>

<p>备注：</p>

<p>① otool，可查看可执行程序都链接了那些库：</p>

<pre><code>   otool  -L WQAlbum 
</code></pre>

<p>可以得到：</p>

<pre><code>WQAlbum:
    /System/Library/Frameworks/StoreKit.framework/StoreKit (compatibility version 1.0.0, current version 1.0.0)
    /System/Library/Frameworks/AdSupport.framework/AdSupport (compatibility version 1.0.0, current version 1.0.0)
    /usr/lib/libz.1.dylib (compatibility version 1.0.0, current version 1.2.5)
    /System/Library/Frameworks//MediaPlayer.framework/MediaPlayer (compatibility version 1.0.0, current version 1.0.0)
    /System/Library/Frameworks/MobileCoreServices.framework/MobileCoreServices (compatibility version 1.0.0, current version 40.0.0)
    /System/Library/Frameworks/CoreMedia.framework/CoreMedia (compatibility version 1.0.0, current version 1.0.0)
    ……
</code></pre>

<p>可以反编译WQAlbum的<strong>TEXT</strong>段内容, 截前10行：</p>

<pre><code>otool -tV WQAlbum |head -n 10 
</code></pre>

<p>可以得到：</p>

<pre><code>WQAlbum:
(__TEXT,__text) section
start:
00002de0    pushl   $0x00
00002de2    movl    %esp,%ebp
00002de4    andl    $0xf0,%esp
00002de7    subl    $0x10,%esp
00002dea    movl    0x04(%ebp),%ebx
……
</code></pre>

<p>② nm，显示程序符号表，用我自己的应用程序私人相册现身说法一下：
nm -g WQAlbum  （ -g 代表 global）</p>

<p>可以得到：</p>

<pre><code>001e5eec S _OBJC_IVAR_$_WQPhotoViewController.albumObject
001e5efc S _OBJC_IVAR_$_WQPhotoViewController.int_current
001e5f00 S _OBJC_IVAR_$_WQPhotoViewController.int_total
</code></pre>

<p>其中，WQPhotoViewController为类名，albumObject为该类的成员</p>

<p>③ ldid，是iPhoneOS.platform提供的签名工具，我们自己编译的程序需要签上名才能跑在iPhone/iPad上，使用方法</p>

<pre><code>export CODESIGN_ALLOCATE=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/codesign_allocate
ldid -S helloworld 
</code></pre>

<p>编译Hello world</p>

<h4>1.首先找到编译器：</h4>

<p>arm-apple-darwin10-llvm-gcc-4.2 就是了。
为了方便起见，可以在.bashrc或者profile 配置下环境变量，方便编译。</p>

<h4>2.找到SDK</h4>

<p>编译我们自己的程序的时候需要指定该目录下的SDK。</p>

<h4>3.来个经典Hello world ：</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;stdio.h&gt;                                                                                             </span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
</span><span class='line'>   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello world !!!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>4.编译</h4>

<p>其中 -isysroot用来指定build时的SDK</p>

<h4>5.校验</h4>

<p>file查看一下类型，没问题。</p>

<h4>6.SCP给iPhone、iPad</h4>

<p>前提是，设备已经越狱并且安装了SSH,且必须在同一网段。</p>

<pre><code>$scp helloworld root@x.x.x.x:hello world
</code></pre>

<h4>7.登录设备签名</h4>

<pre><code>$ssh -l root x.x.x.x
#ldid -S helloworld
</code></pre>

<h4>8.执行程序</h4>

<pre><code>#./helloworld
Hello world !!!
</code></pre>

<p>运行成功，这就完成了最简单的手动执行自己的应用程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ABELWebImageKit使用介绍]]></title>
    <link href="http://www.beyondabel.com/blog/2014/02/10/abelwebimagekit/"/>
    <updated>2014-02-10T20:30:17+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/02/10/abelwebimagekit</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>ABELWebImageKit托管在github上：<a href="https://github.com/beyondabel/ABELWebImage">https://github.com/beyondabel/ABELWebImage</a></p>

<!--more-->


<h3>目录</h3>

<pre><code>1、ABELWebImageKit介绍
2、ABELWebImageKit库结构的简单分析
3、ABELWebImageKit库的图片管理
4、ABELWebImageKit库使用的简单举例
</code></pre>

<h3>1、ABELWebImageKit介绍</h3>

<p>这个库提供一个ABELImageView类以支持加载来自网络的远程图片。具有缓存管理、异步下载、同一个URL下载次数控制和优化等特征。将ABELWebImageKit类库添加入工程时，一定注意需要添加ImageIO.framework。UIImage+Tools依赖这个framework。</p>

<h3>2、ABELWebImageKit库结构的简单分析</h3>

<p>ABELImageView：ABELImageView继承于UIImageView的，它主要用于加载来自网络的远程图片。其中avater用于区别是否为头像图片（默认非头像）。</p>

<p>ABELWebImageCacheManager：ABELWebImageCacheManager是一个单例，对图片进行管理的中转站，读取图片（向下层读取Cache或者读取网络），实现ABELWebImageCache和ABELWebImageRequest的回调。</p>

<p>ABELWebImageCache：根据URL的MD5摘要对图片进行存储和读取（实现存在内存中或者存在硬盘上两种实现）     实现图片和内存清理工作。
ABELWebImageRequest：根据URL向网络读取数据</p>

<h3>3、ABELWebImageKit库的图片管理</h3>

<p>ABELWebImageCache分两个部分，一个是内存层面的，一个是硬盘层面的。</p>

<p>内存层面的相当是个缓存器，以Key-Value的形式存储图片。当内存不够的时候会清除所有缓存图片。用搜索文件系统的方式做管理，文件替换方式是以时间为单位，剔除时间大于一周的图片文件。当ABELWebImageCacheManager向ABELWebImageCache要资源时，先搜索内存层面的数据，如果有直接返回，没有的话去访问磁盘，将图片从磁盘读取出来，然后做Decoder，将图片对象放到内存层面做备份，再返回调用层。</p>

<h3>4、ABELWebImageKit库使用的简单举例</h3>

<pre><code>self.avatarImageView = [[ABELImageView alloc] init];
// 设置avatar为YES为显示圆形头像图片，否则为普通的图片
self.avatarImageView.avatar = YES;
self.avatarImageView.frame = CGRectMake(15, 10, 40, 40);
[self.avatarImageView setImageWithURL:[NSURL URLWithString:URLString]]
[self.contentView addSubview:self.avatarImageView];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISwitch详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/11/uiswitch/"/>
    <updated>2014-01-11T12:34:31+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/11/uiswitch</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>UISwitch继承于UIControl（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）,您可以使用UISwitch类来创建和管理使用开/关按钮。例如，在对选项，如飞行模式和蓝牙设置应用程序。这些对象被称为交换机。</p>

<!--more-->


<h3>目录</h3>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
</code></pre>

<h3>1、基本属性及方法</h3>

<p>// 开关是否打开</p>

<pre><code>BOOL on;
</code></pre>

<p>// 这个frame会被忽略，他会强制设置大小</p>

<pre><code>- (id)initWithFrame:(CGRect)frame;
</code></pre>

<p>// 打开/关闭调用函数(animated：是否使用动画)</p>

<pre><code>- (void)setOn:(BOOL)on animated:(BOOL)animated;
</code></pre>

<h3>2、iOS5新增</h3>

<p>// 开关打开时颜色</p>

<pre><code>UIColor *onTintColor;
</code></pre>

<h3>3、iOS6新增</h3>

<p>// 背影颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 开关的圆形滑钮的颜色</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 开关打开时自定义图片</p>

<pre><code>UIImage *onImage;
</code></pre>

<p>// 开关关闭时自定义图片</p>

<pre><code>UIImage *offImage;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISlider详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/11/uislider/"/>
    <updated>2014-01-11T12:34:24+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/11/uislider</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>UISlider继承于UIControl（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。UISlider对象是用来从一个连续的数值范围内选择单个值的可视化控制。滑块总是显示为水平条形图。一个指标，注意到滑块的当前值，并且可以由用户进行移动来改变该设置。</p>

<!--more-->


<h3>目录</h3>

<pre><code>1、设置初始值
2、改变UISlider的外观
3、供子类重写的方法
</code></pre>

<h3>1、设置初始值</h3>

<p>// 指定初始值</p>

<pre><code>float value;
</code></pre>

<p>// 指定可变最小值</p>

<pre><code>float minimumValue;
</code></pre>

<p>// 指定可变最大值</p>

<pre><code>float maximumValue;
</code></pre>

<h3>2、改变UISlider的外观</h3>

<p>//  设置滑轮左边图片</p>

<pre><code>UIImage *minimumValueImage;
</code></pre>

<p>// 设置滑轮右边图片</p>

<pre><code>UIImage *maximumValueImage;
</code></pre>

<p>//  （默认YES）</p>

<pre><code>BOOL continuous;
</code></pre>

<p>//  滑轮左边颜色如果设置了左边的图片就不会显示（iOS 5.0）</p>

<pre><code>UIColor *minimumTrackTintColor;
</code></pre>

<p>// 滑轮右边颜色如果设置了右边的图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *maximumTrackTintColor;
</code></pre>

<p>// 设置了滑轮的颜色如果设置了滑轮的样式图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 动态设置滑动值</p>

<pre><code>- (void)setValue:(float)value animated:(BOOL)animated;
</code></pre>

<p>// 定制自己的滑块图片</p>

<pre><code>- (void)setThumbImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置左边的图片</p>

<pre><code>- (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置右边的图片</p>

<pre><code>- (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>//  根据状态返回滑动图片</p>

<pre><code>- (UIImage *)thumbImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态左边的图片</p>

<pre><code>- (UIImage *)minimumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态右边的图片</p>

<pre><code>- (UIImage *)maximumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 当前的滑动图片（只读）</p>

<pre><code>UIImage* currentThumbImage;
</code></pre>

<p>// 当前左边的图片（只读）</p>

<pre><code>UIImage* currentMinimumTrackImage;
</code></pre>

<p>// 当前右边的图片（只读）</p>

<pre><code>UIImage* currentMaximumTrackImage;
</code></pre>

<h3>3、供子类重写的方法</h3>

<p>// 以下四种方法用于子类覆盖,用来自定义thumb、track的CGRect</p>

<pre><code>- (CGRect)minimumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)maximumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)trackRectForBounds:(CGRect)bounds;
- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITextField详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/10/uitextfield/"/>
    <updated>2014-01-10T12:34:12+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/10/uitextfield</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>UITextField对象是显示可编辑的文本，当用户按下键盘上的return按钮发送一个动作消息到目标对象,UITextField继承于UIControl（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。</p>

<p>除了其基本的文本编辑行为，UITextField类还提供了清除当前文本内置按钮等一些功能。</p>

<!--more-->


<h3>目录</h3>

<pre><code>1、基本属性及方法
2、重写方法实现定制化UITextfiled
3、第一响应设置
4、UIView的UITextField的扩展属性
5、UITextFieldDelegate代理协议（可选）
</code></pre>

<h3>1、基本属性及方法</h3>

<p>// 设置文本内容</p>

<pre><code>NSString               *text;                 
</code></pre>

<p>// 设置文本显示属性（iOS6.0）</p>

<pre><code>NSAttributedString     *attributedText;
</code></pre>

<p>// 设置字体颜色</p>

<pre><code>UIColor                *textColor;            
</code></pre>

<p>// 设置字体</p>

<pre><code>UIFont                 *font;                 
</code></pre>

<p>// 内容的对齐方式（默认为NSLeftTextAlignment）</p>

<pre><code>NSTextAlignment         textAlignment;        
</code></pre>

<p>// 设置边框样式，只有设置了才会显示边框样式</p>

<pre><code>UITextBorderStyle       borderStyle;          
</code></pre>

<p>// 设置文本的显示属性（iOS7.0）</p>

<pre><code>NSDictionary           *defaultTextAttributes; 
</code></pre>

<p>// 当输入框没有内容时，水印提示</p>

<pre><code>NSString               *placeholder;          
</code></pre>

<p>// （iOS 6.0）</p>

<pre><code>NSAttributedString     *attributedPlaceholder;
</code></pre>

<p>// 再次编辑就清空(默认为NO)</p>

<pre><code>BOOL                    clearsOnBeginEditing;
</code></pre>

<p>// 设置为YES时文本会自动缩小以适应文本窗口大小.默认是保持原来大小,而让长文本滚动　</p>

<pre><code>BOOL                    adjustsFontSizeToFitWidth; 
</code></pre>

<p>// 设置自动缩小显示的最小字体大小</p>

<pre><code>CGFloat                 minimumFontSize;      
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UITextFieldDelegate&gt; delegate; 
</code></pre>

<p>// 设置背景图片</p>

<pre><code>UIImage                *background;
</code></pre>

<p>// 设置背景</p>

<pre><code>UIImage                *disabledBackground;
</code></pre>

<p>// 是否正在编辑(只读)</p>

<pre><code>BOOL editing;
</code></pre>

<p>// （iOS 6.0）</p>

<pre><code>BOOL allowsEditingTextAttributes;
</code></pre>

<p>// （iOS 6.0）</p>

<pre><code>NSDictionary *typingAttributes;
</code></pre>

<p>// 输入框中是否有个叉号，在什么时候显示，用于一次性删除输入框中的内容</p>

<pre><code>UITextFieldViewMode  clearButtonMode;
</code></pre>

<p>//</p>

<pre><code>UIView              *leftView;
UITextFieldViewMode  leftViewMode;

UIView              *rightView;
UITextFieldViewMode  rightViewMode;
</code></pre>

<h3>2、重写方法实现定制化UITextfiled</h3>

<p>//重写来重置边缘区域</p>

<pre><code>- (CGRect)borderRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 重写来重置文字区域</p>

<pre><code>- (CGRect)textRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 重写来重置占位符区域</p>

<pre><code>- (CGRect)placeholderRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 重写来重置编辑区域</p>

<pre><code>- (CGRect)editingRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 重写来重置clearButton位置,改变size可能导致button的图片失真</p>

<pre><code>- (CGRect)clearButtonRectForBounds:(CGRect)bounds;
</code></pre>

<p>//</p>

<pre><code>- (CGRect)leftViewRectForBounds:(CGRect)bounds;
- (CGRect)rightViewRectForBounds:(CGRect)bounds;

- (void)drawTextInRect:(CGRect)rect;
- (void)drawPlaceholderInRect:(CGRect)rect;
</code></pre>

<h3>3、第一响应设置</h3>

<pre><code>UIView *inputView;             
UIView *inputAccessoryView;

BOOL clearsOnInsertion NS_AVAILABLE_IOS(6_0);
</code></pre>

<h3>4、UIView的UITextField的扩展属性</h3>

<pre><code>- (BOOL)endEditing:(BOOL)force;
</code></pre>

<h3>5、UITextFieldDelegate代理协议（可选）</h3>

<p>// 返回一个BOOL值，指定是否循序文本字段开始编辑　</p>

<pre><code>- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;        
</code></pre>

<p>// 开始编辑时触发，文本字段将成为first responder</p>

<pre><code>- (void)textFieldDidBeginEditing:(UITextField *)textField;
</code></pre>

<p>//返回BOOL值，指定是否允许文本字段结束编辑，当编辑结束，文本字段会让出first responder　要想在用户结束编辑时阻止文本字段消失，可以返回NO.这对一些文本字段必须始终保持活跃状态的程序很有用，比如即时消息</p>

<pre><code>- (BOOL)textFieldShouldEndEditing:(UITextField *)textField;
</code></pre>

<p>// 结束编辑</p>

<pre><code>- (void)textFieldDidEndEditing:(UITextField *)textField; 
</code></pre>

<p>//当用户使用自动更正功能，把输入的文字修改为推荐的文字时，就会调用这个方法。　
//这对于想要加入撤销选项的应用程序特别有用　
//可以跟踪字段内所做的最后一次修改，也可以对所有编辑做日志记录,用作审计用途。　　
//要防止文字被改变可以返回NO　
//这个方法的参数中有一个NSRange对象，指明了被改变文字的位置，建议修改的文本也在其中</p>

<pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string; 
</code></pre>

<p>//返回一个BOOL值指明是否允许根据用户请求清除内容.可以设置在特定条件下才允许清除内容</p>

<pre><code>- (BOOL)textFieldShouldClear:(UITextField *)textField; 
</code></pre>

<p>//返回一个BOOL值，指明是否允许在按下回车键时结束编辑　</p>

<pre><code>- (BOOL)textFieldShouldReturn:(UITextField *)textField;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISegmentedControl详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/10/uisegmentedcontrol/"/>
    <updated>2014-01-10T12:34:00+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/10/uisegmentedcontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISegmentedControl对象是一个水平控制使多个区段，每个区段用作离散的按钮。分段控件提供了一次小型的手段组合在一起的一些控制。</p>

<p>UISegmentedControl继承于UIControl（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）.</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS 5.0新增
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化UISegmentedControl（items可以是NSString类型或者UIImages）</p>

<pre><code>- (id)initWithItems:(NSArray *)items;
</code></pre>

<p>//设置样式 （该样式只在ios2.0~7.0有效果）</p>

<pre><code>UISegmentedControlStyle segmentedControlStyle;
</code></pre>

<p>//设置在点击后是否恢复原样（默认是NO）</p>

<pre><code>BOOL momentary;
</code></pre>

<p>// 设置总选项数</p>

<pre><code>NSUInteger numberOfSegments;
</code></pre>

<p>//是否根据segment的内容改变segment的宽度 (只使用ios5.0，默认为NO)</p>

<pre><code>BOOL apportionsSegmentWidthsByContent;
</code></pre>

<p>//在指定的索引插入一个选项并设置题目</p>

<pre><code>- (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//在指定的索引插入一个选项并设置图片</p>

<pre><code>- (void)insertSegmentWithImage:(UIImage *)image  atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除指定索引的选项</p>

<pre><code>- (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除所有的选项</p>

<pre><code>- (void)removeAllSegments;
</code></pre>

<p>//设置指定索引题目</p>

<pre><code>- (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的标题</p>

<pre><code>- (NSString *)titleForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引的图片</p>

<pre><code>- (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的图片</p>

<pre><code>- (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项的宽度（默认是0）</p>

<pre><code>- (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的宽度</p>

<pre><code>- (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置选项中图片等的左上角的位置</p>

<pre><code>- (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取选项中图片等的左上角的位置</p>

<pre><code>- (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项不可选</p>

<pre><code>- (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//判断指定索引选项是否可选</p>

<pre><code>- (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置默认选项索引</p>

<pre><code>NSInteger selectedSegmentIndex; 
</code></pre>

<p>//设置UISegmentedControl的颜色</p>

<pre><code>UIColor *tintColor; 
</code></pre>

<p><strong>2、iOS 5.0新增</strong></p>

<p>//设置在某个状态下的背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>//获取在某个状态下的背景图片</p>

<pre><code>- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics   
</code></pre>

<p>//设置分割线背景图片</p>

<pre><code>- (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetCT
</code></pre>

<p>//获取分割线背景图片</p>

<pre><code>- (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMeE 
</code></pre>

<p>//设置文字显示样式</p>

<pre><code>- (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
</code></pre>

<p>//获取文字显示样式</p>

<pre><code>- (NSDictionary *)titleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//设置选项中内容的调整位置</p>

<pre><code>- (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics; 
</code></pre>

<p>//获取选项中内容的调整位置</p>

<pre><code>- (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIPageControl详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/09/uipagecontrol/"/>
    <updated>2014-01-09T12:33:46+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/09/uipagecontrol</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>UIPageControl继承于UIControl（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。您可以使用UIPageControl类来创建和管理页面控件。一个页面控件显示一个水平一系列的点，每个对应一个页面应用程序的文档（或其他数据模型实体）中。当前浏览的页面是由一个白色的圆点表示。</p>

<p>当用户点击一个页面控件移动到下一页或上一页，控制处理由委托发送UIControlEventValueChanged事件。然后委托可以评估当前属性来确定要显示的页面。网页控制在任何一个方向前进只有一个页面。</p>

<!--more-->


<h3>目录</h3>

<p>&mdash;-1、基本属性及方法
2、iOS6.0新增</p>

<h3>1、基本属性及方法</h3>

<p>// 指定页面个数（默认为0）</p>

<pre><code>NSInteger numberOfPages;
</code></pre>

<p>// 当前选中的页面（默认为0，范围为0 ～ numberOfPages-1）</p>

<pre><code>NSInteger currentPage;
</code></pre>

<p>// 如果在numberOfPages为1的情况下隐藏指示器，可以将hideForSinglePage的值设为YES。默认情况下，即使只有一个页面，指示器也会显示进来。</p>

<pre><code>BOOL hidesForSinglePage;
</code></pre>

<p>// 如果你希望直到有时间执行完你的操作之后，才更新当前指示器当前指示页，可以将 defersCurrentPageDisPlay 设为YES。这样的话你必须调用控件的 updateCurentPageDisPlay 来更新当前页</p>

<pre><code>BOOL defersCurrentPageDisplay;
</code></pre>

<p>// 更新当前页</p>

<pre><code>- (void)updateCurrentPageDisplay;
</code></pre>

<p>// 返回接受者的边界大小，与容纳被给的页面数有关</p>

<pre><code>- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;
</code></pre>

<h3>2、iOS6.0新增</h3>

<p>// 未选中的点的颜色</p>

<pre><code>UIColor *pageIndicatorTintColor;
</code></pre>

<p>// 当前点颜色</p>

<pre><code>UIColor *currentPageIndicatorTintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIDatePicker详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/09/uidatepicker/"/>
    <updated>2014-01-09T12:33:27+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/09/uidatepicker</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>该的UIDatePicker类实现使用多个车轮转动，以允许用户选择日期和时间的对象。UIDatePicker iPhone的例子是定时器和时钟应用程序的闹钟（设置闹钟）窗格。您也可以使用日期选择器作为一个倒数计时器。</p>

<p>如果配置正确，一个的UIDatePicker对象发送一个动作消息，当一个用户完成旋转的轮子之一更改日期或时间，相关的控制事件是UIControlEventValueChanged 。一个的UIDatePicker对象呈现倒数计时，但没有实现它，应用程序必须设立的NSTimer对象，并为他们倒计数更新秒。</p>

<p>UIDatePicker不是从UIPickerView的继承，而是继承于UIControl（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。，但它管理的自定义选择器视图对象作为一个子视图。</p>

<!--more-->


<pre><code>typedef enum {
    //根据区域设置,显示小时,分钟,并指定AM/PM(例如:6|53|PM)
    UIDatePickerModeTime,
    //根据区域设置,显示月,日,年(例如:November|15|2007)
    UIDatePickerModeDate, 
    //根据区域设置,显示日期(星期,月,日),小时,分钟,并指定AM/PM(例如:Wed Nov 15|6|53|PM)
    UIDatePickerModeDateAndTime,
    //显示小时,分钟(例如:1|53)  
    UIDatePickerModeCountDownTimer
} UIDatePickerMode;
</code></pre>

<p>// 设置UIDatePicker的显示模式(默认为UIDatePickerModeDateAndTime)</p>

<pre><code>UIDatePickerMode datePickerMode; 
</code></pre>

<p>//设置为语言显示</p>

<pre><code>NSLocale   *locale;   
</code></pre>

<p>// 设置日历</p>

<pre><code>NSCalendar *calendar;
</code></pre>

<p>// 设置时区</p>

<pre><code>NSTimeZone *timeZone; 
</code></pre>

<p>// 设置当前显示时间</p>

<pre><code>NSDate *date;
</code></pre>

<p>//如果animated为YES,时间轮会自动显示新的时间</p>

<pre><code>- (void)setDate:(NSDate *)date animated:(BOOL)animated;        
</code></pre>

<p>// 设置显示最小时间</p>

<pre><code>NSDate *minimumDate;
</code></pre>

<p>// 设置显示最大时间（此处为当前时间）</p>

<pre><code>NSDate *maximumDate;
</code></pre>

<p>//用于UIDatePickerModeCountDownTimer,否则忽略.默认为0.0.最大限制为23:59 (86,399秒)</p>

<pre><code>NSTimeInterval countDownDuration;
</code></pre>

<p>//设置分钟之间的间隔.间隔必须均匀的分为60.默认为1.最小为1,最大为30</p>

<pre><code>NSInteger      minuteInterval;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIButton详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/08/uibutton/"/>
    <updated>2014-01-08T12:33:18+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/08/uibutton</id>
    <content type="html"><![CDATA[<p>引言</p>

<p>UIButton的类是一个UIControl子类（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>），它实现了在触摸屏上的按钮。触摸一个按钮拦截事件和动作消息发送到目标对象时，它的挖掘。设定的目标和行动方法都继承自UIControl。这个类提供了方法来设置标题，图像，按钮等外观属性。通过使用set方法，你可以指定一个不同的外观为每个按钮状态。</p>

<!--more-->


<p>目录</p>

<p>// 初始化 button 样式</p>

<pre><code>+ (id)buttonWithType:(UIButtonType)buttonType;
</code></pre>

<p>// 每边（左，右，顶部和底部）可以有不同的值。使用UIEdgeInsetsMake功能设置图片和文字的位置(默认为UIEdgeInsetsZero)</p>

<pre><code>UIEdgeInsets contentEdgeInsets; 
</code></pre>

<p>// 设置标题、图片的边缘值（默认UIEdgeInsetsZero）</p>

<pre><code>UIEdgeInsets titleEdgeInsets;                
</code></pre>

<p>// 决定是否点击按钮会导致其发光</p>

<pre><code>BOOL         reversesTitleShadowWhenHighlighted; 
</code></pre>

<p>// 图像插图或一开始就为每个边缘</p>

<pre><code>UIEdgeInsets imageEdgeInsets;                
</code></pre>

<p>// 决定是否按钮时，突出显示图像的变化。</p>

<pre><code>BOOL         adjustsImageWhenHighlighted;    
</code></pre>

<p>// 决定是否形象的变化时，该按钮被禁用</p>

<pre><code>BOOL         adjustsImageWhenDisabled;       
</code></pre>

<p>// 决定是否点击按钮会导致其发光</p>

<pre><code>BOOL         showsTouchWhenHighlighted;      
</code></pre>

<p>// 设置背景颜色(iOS 5.0)</p>

<pre><code>UIColor     *tintColor;
</code></pre>

<p>// button样式(只读)</p>

<pre><code>UIButtonType buttonType;
</code></pre>

<p>// 设置某个状态下的title</p>

<pre><code>- (void)setTitle:(NSString *)title forState:(UIControlState)state;                    
</code></pre>

<p>// 设置某个状态下的title颜色</p>

<pre><code>- (void)setTitleColor:(UIColor *)color forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的阴影颜色</p>

<pre><code>- (void)setTitleShadowColor:(UIColor *)color forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的图片</p>

<pre><code>- (void)setImage:(UIImage *)image forState:(UIControlState)state;                      
</code></pre>

<p>// 设置某个状态下的背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)image forState:(UIControlState)state; 
</code></pre>

<p>// 设置某个状态下的title属性（iOS 6.0）</p>

<pre><code>- (void)setAttributedTitle:(NSAttributedString *)title forState:(UIControlState)state; 
</code></pre>

<p>// 返回一个按钮的状态中使用的字体内容。</p>

<pre><code>- (NSString *)titleForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的字体颜色。</p>

<pre><code>- (UIColor *)titleColorForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的阴影颜色。</p>

<pre><code>- (UIColor *)titleShadowColorForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的图像。</p>

<pre><code>- (UIImage *)imageForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的背景图像</p>

<pre><code>- (UIImage *)backgroundImageForState:(UIControlState)state;
</code></pre>

<p>// 返回一个按钮的状态中使用的内容属性（iOS 6.0）</p>

<pre><code>- (NSAttributedString *)attributedTitleForState:(UIControlState)state;
</code></pre>

<p>// 当前状态的title(只读)</p>

<pre><code>NSString *currentTitle;
</code></pre>

<p>// 当前状态的title字体颜色(只读)</p>

<pre><code>UIColor  *currentTitleColor;
</code></pre>

<p>// 当前状态的阴影(只读)</p>

<pre><code>UIColor  *currentTitleShadowColor;
</code></pre>

<p>// 当前状态的图片(只读)</p>

<pre><code>UIImage  *currentImage;
</code></pre>

<p>// 当前状态的背景图片(只读)</p>

<pre><code>UIImage  *currentBackgroundImage;
</code></pre>

<p>// 当前状态的title的内容属性(只读 iOS 6.0)</p>

<pre><code>NSAttributedString *currentAttributedTitle;
</code></pre>

<p>// UIButton的titleLabel(只读)</p>

<pre><code>UILabel     *titleLabel;
</code></pre>

<p>// UIButton的contentImageView(只读)</p>

<pre><code>UIImageView *imageView;
</code></pre>

<p>// 返回矩形的接收绘制其背景。</p>

<pre><code>- (CGRect)backgroundRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 返回矩形的接收提请其全部内容。</p>

<pre><code>- (CGRect)contentRectForBounds:(CGRect)bounds;
</code></pre>

<p>// 返回title的绘制范围</p>

<pre><code>- (CGRect)titleRectForContentRect:(CGRect)contentRect;
</code></pre>

<p>// 返回图片的绘制范围</p>

<pre><code>- (CGRect)imageRectForContentRect:(CGRect)contentRect;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITableView详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/07/uitableview/"/>
    <updated>2014-01-07T12:33:02+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/07/uitableview</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>UITableView简单来说是一个表视图，继承于UIScrollView（有关UIScrollView请参照<a href="http://www.beyondabel.com/blog/2014/01/05/uiscrollView/">《iOS组件之UIScrollView详解》</a>），用于显示和编辑信息的分层列表。</p>

<!--more-->


<h3>目录</h3>

<pre><code>1、tableView的基本属性及方法
2、访问tableView的画图区
3、访问cells和sections
4、滚动tableView
5、插入、删除、移动行和sections
6、管理和编辑cell
7、管理sections
8、配置
9、iOS5.0新增
10、iOS6.0新增
11、iOS7.0
12、UITableViewDataSource协议
    12.1必须实现
    12.2可选
        12.2.1编辑模式
    12.2.2数据操作  
13、UITableViewDelegate协议（可选）
    13.1定制化
    13.2iOS6新增
    13.3可变高度支持
    13.4iOS7.0新增
    13.5header 和 footer Section 信息
    13.6附属公开的接口
    13.7选择
    13.8编辑
    13.9移动
    13.10缩格
    13.11复制/粘贴
</code></pre>

<h3>1、tableView的基本属性及方法</h3>

<p>// 初始化</p>

<pre><code>- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;
</code></pre>

<p>// 设置tableView的样式（只读）</p>

<pre><code>UITableViewStyle style;
</code></pre>

<p>// 设置数据资源代理</p>

<pre><code>id &lt;UITableViewDataSource&gt; dataSource;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UITableViewDelegate&gt; delegate;
</code></pre>

<p>// 设置每个row的高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat rowHeight;
</code></pre>

<p>// 设置sectionHeader高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionHeaderHeight;   
</code></pre>

<p>// 设置sectionFooter高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionFooterHeight;   
</code></pre>

<p>//  设置tableView的背景view</p>

<pre><code>UIView *backgroundView;
</code></pre>

<p>// 刷新tableView</p>

<pre><code>- (void)reloadData;
</code></pre>

<p>// 刷新tableView中的section</p>

<pre><code>- (void)reloadSectionIndexTitles;
</code></pre>

<p>// sections的数量</p>

<pre><code>- (NSInteger)numberOfSections;
</code></pre>

<p>// 下标为section中的row数量</p>

<pre><code>- (NSInteger)numberOfRowsInSection:(NSInteger)section;
</code></pre>

<h3>2、访问tableView的画图区</h3>

<p>// 返回指定section的矩形</p>

<pre><code>- (CGRect)rectForSection:(NSInteger)section; 
</code></pre>

<p>// 返回indexPath指定行的矩形</p>

<pre><code>- (CGRect)rectForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的footer矩形</p>

<pre><code>- (CGRect)rectForFooterInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的header矩形</p>

<pre><code>- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h3>3、访问cells和sections</h3>

<p>// 通过cell得到这个cell在tableView的位置</p>

<pre><code>- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;
</code></pre>

<p>// 根据一个几何点返回indexPath,如果超过边界返回nil</p>

<pre><code>- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;
</code></pre>

<p>// 根据一个几何的矩形返回矩形所覆盖的行,返回是一个indexPath数组</p>

<pre><code>- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;         
</code></pre>

<p>//  根据IndexPath返回cell</p>

<pre><code>- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;            
</code></pre>

<p>//</p>

<pre><code>- (NSArray *)visibleCells;
- (NSArray *)indexPathsForVisibleRows;
</code></pre>

<h3>4、滚动tableView</h3>

<p>// 滚动到指定位置</p>

<pre><code>- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<p>//  同上</p>

<pre><code>- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<h3>5、插入、删除、移动行和sections</h3>

<p>// 和endUpdates一起用，让插入、删除、选择操作同时动画，没用过</p>

<pre><code>- (void)beginUpdates;
</code></pre>

<p>//</p>

<pre><code>- (void)endUpdates;
</code></pre>

<p>//根据indexPath数组插入行</p>

<pre><code>- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//根据indexPath数组删除行</p>

<pre><code>- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动一行到另一行</p>

<pre><code>- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//插入sections</p>

<pre><code>- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//删除sections</p>

<pre><code>- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动section</p>

<pre><code>- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<h3>6、管理和编辑cell</h3>

<p>// YES进入编辑模式，tableview cell会出现插入、删除、重排序的控件</p>

<pre><code>BOOL editing;
</code></pre>

<p>// 设置进入退出编辑模式</p>

<pre><code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<h3>7、管理sections</h3>

<p>//是否允许用户选取一行</p>

<pre><code>BOOL allowsSelection;
</code></pre>

<p>//返回选定行的indexPath,单行</p>

<pre><code>- (NSIndexPath *)indexPathForSelectedRow;
</code></pre>

<p>// 根据indexPath选择一行</p>

<pre><code>- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;
</code></pre>

<p>// 根据indexPath取消选择这一行</p>

<pre><code>- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;
</code></pre>

<h3>8、配置</h3>

<p>// 指定当tableView中多少行的时候开始显示IndexList，默认的设置是NSIntegerMax，即默认是不显示indexList的</p>

<pre><code>NSInteger sectionIndexMinimumDisplayRowCount;
</code></pre>

<p>// 分隔线的样式(默认为UITableViewCellSeparatorStyleSingleLine)</p>

<pre><code>UITableViewCellSeparatorStyle separatorStyle;
</code></pre>

<p>// cell之间的分割线</p>

<pre><code>UIColor *separatorColor;              
</code></pre>

<p>// 设置headerView</p>

<pre><code>UIView *tableHeaderView;                            
</code></pre>

<p>// 设置footerView</p>

<pre><code>UIView *tableFooterView;                            
</code></pre>

<p>// 必须要实现的方法，与tableView同生同死</p>

<pre><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;  
</code></pre>

<h3>9、iOS5.0新增</h3>

<p>// 移动section</p>

<pre><code>- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;
</code></pre>

<p>// 移动一行到另一行</p>

<pre><code>- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;
</code></pre>

<p>// 返回选定行的indexPath数组，多行</p>

<pre><code>- (NSArray *)indexPathsForSelectedRows;
</code></pre>

<p>//</p>

<pre><code>- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;
</code></pre>

<p>//  编辑模式时是否可选取一行</p>

<pre><code>BOOL allowsSelectionDuringEditing;
</code></pre>

<p>//  是否选取多行，缺省为NO(iOS 5.0)</p>

<pre><code>BOOL allowsMultipleSelection;
</code></pre>

<p>//  编辑模式时可否选取多行</p>

<pre><code>BOOL allowsMultipleSelectionDuringEditing;
</code></pre>

<h3>10、iOS6.0新增</h3>

<p>// 我想在numberOfRowsInSection方法内获取该section的header View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;
</code></pre>

<p>// 我想在numberOfRowsInSection方法内获取该section的footer View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;
</code></pre>

<p>// 设置索引号颜色</p>

<pre><code>UIColor *sectionIndexColor;
</code></pre>

<p>// 设置索引号背景颜色</p>

<pre><code>UIColor *sectionIndexTrackingBackgroundColor;
</code></pre>

<p>// 注册（没有测试有什么用)</p>

<pre><code>- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier; 
- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier;
- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;
- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;
</code></pre>

<h3>11、iOS7.0</h3>

<p>// 预设SectionFooter的高度</p>

<pre><code>CGFloat estimatedSectionFooterHeight;
UIEdgeInsets separatorInset;
UIColor *sectionIndexBackgroundColor;
</code></pre>

<p>// 预设row的高度</p>

<pre><code>CGFloat estimatedRowHeight;     
</code></pre>

<p>// 预设SectionHeader的高度</p>

<pre><code>CGFloat estimatedSectionHeaderHeight; 
</code></pre>

<h3>12、UITableViewDataSource协议</h3>

<h4>12.1必须实现</h4>

<p>// 返回每个section中row的数量</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
</code></pre>

<p>// 返回每个UITableViewCell</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h4>12.2可选</h4>

<p>// 返回section的个数</p>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;              
</code></pre>

<p>//  section headerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section; 
</code></pre>

<p>// section footerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;
</code></pre>

<h5>12.2.1 编辑模式</h5>

<p>// 设置可编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h6>12.2.1.1 移动</h6>

<p>// 设置是否可移动</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 设置索引号</p>

<pre><code>- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView
</code></pre>

<p>// 点击索引触发</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index;
</code></pre>

<h6>12.2.2 数据操作</h6>

<p>// 插入/删除指定数据</p>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 重新排序/移动数据操作</p>

<pre><code>- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
</code></pre>

<h3>13、UITableViewDelegate协议（可选）</h3>

<h4>13.1定制化</h4>

<p>// cell将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h4>13.2iOS6新增</h4>

<p>// HeaderView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// cell结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;
</code></pre>

<p>// HeaderView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<h4>13.3可变高度支持</h4>

<p>// 根据indexPath返回row的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 根据indexPath返回HeaderView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据indexPath返回FooterView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;
</code></pre>

<h4>13.4iOS7.0新增</h4>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的cell的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Header的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Footer的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;
</code></pre>

<h4>13.5 header 和 footer Section 信息</h4>

<p>// 根据section创建header section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据section创建footer section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;
</code></pre>

<h4>13.6 附属公开的接口</h4>

<p>// 回调设置辅助按钮被点击后的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h4>13.7 选择</h4>

<p>// 回调设置某行是否当被点击后处于高亮状态</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行处于高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行失去高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调某行将要被选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行将要被取消选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经被选中点击的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经取消选中的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h4>13.8 编辑</h4>

<p>// 回调设置某行进入了哪种编辑模式</p>

<pre><code>- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置某行进入删除模式的删除按钮名字</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 是否允许对row进行编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 开始编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 结束编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h4>13.9 移动</h4>

<p>// 移动Row时会把触发，在交换Row位置的时候，必须同时交换DataSource中数据的位置。</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;               
</code></pre>

<h4>13.10 缩格</h4>

<p>// 设置内容缩进</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<h4>13.11 复制/粘贴</h4>

<p>// 回调设置某行被长按是否出现菜单栏</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置菜单栏是否显示哪些菜单栏选项</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>

<p>// 回调点击菜单栏选项触发的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIControl详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/06/uicontrol/"/>
    <updated>2014-01-06T12:32:49+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/06/uicontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIControl的是控制对象,继承于UIView（有关UIControl请参照<a href="http://www.beyondabel.com/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>），如传达用户意图的应用程序按钮和滑块的基类。你不能使用uicontrol的类直接实例化控件。相反，它定义了它的所有子类的通用接口和行为结构。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 控件默认是启用的。要禁用控件，可以将enabled属性设置为NO，这将导致控件忽略任何触摸事件。被禁用后，控件还可以用不同的方式显示自己，比如变成灰色不可用。虽然是由控件的子类完成的，这个属性却存在于UIControl中。</p>

<pre><code>BOOL enabled;
</code></pre>

<p>// 当用户选中控件时，UIControl类会将其selected属性设置为YES。子类有时使用这个属性来让控件选择自身，或者来表现不同的行为方式。</p>

<pre><code>BOOL selected;
</code></pre>

<p>//</p>

<pre><code>BOOL highlighted;
</code></pre>

<p>// 控件如何在垂直方向上布置自身的内容。默认是将内容顶端对其，对于文本字段，可能会改成UIControlContentVerticalAlignmentCenter。对于这个字段，可以使用下列诸值.</p>

<pre><code>UIControlContentVerticalAlignment contentVerticalAlignment;    

UIControlContentVerticalAlignmentCenter //居中
UIControlContentVerticalAlignmentTop    //居顶
UIControlContentVerticalAlignmentBottom // 居下
UIControlContentVerticalAlignmentFill   
</code></pre>

<p>// 控件如何在水平方向上布置自身的内容</p>

<pre><code>UIControlContentHorizontalAlignment contentHorizontalAlignment; 
</code></pre>

<p>// UIControl状态(只读)</p>

<pre><code>UIControlState state;
</code></pre>

<p>// 只读</p>

<pre><code>BOOL tracking;
</code></pre>

<p>// 是否touchInside（只读）</p>

<pre><code>BOOL touchInside; 
</code></pre>

<p>//</p>

<pre><code>- (BOOL)beginTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;
- (BOOL)continueTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;
- (void)endTrackingWithTouch:(UITouch *)touch withEvent:(UIEvent *)event;
- (void)cancelTrackingWithEvent:(UIEvent *)event;   // event may be nil if cancelled for non-event reasons, e.g. removed from window
</code></pre>

<p>// 事件通知。UIControl类提供了一个标准机制，来进行事件登记和接收。这令你可以指定你的控件在发生特定事件时，通知代理类的一个方法。如果要注册一个事件，可以使用addTarget方法：</p>

<pre><code>- (void)addTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;
</code></pre>

<p>// 移除事件通知。要删除一个或多个事件的相应动作，可以使用UIControl类的removeTarget方法。使用nil值就可以将给定事件目标的所有动作删除</p>

<pre><code>- (void)removeTarget:(id)target action:(SEL)action forControlEvents:(UIControlEvents)controlEvents;
</code></pre>

<p>// 取得关于一个控件所有指定动作的列表，可以使用allTargets方法。这个方法返回一个NSSet，其中包含事件的完整列表</p>

<pre><code>- (NSSet*)allTargets;
</code></pre>

<p>// 获取关于一个控件所有事件的列表</p>

<pre><code>- (UIControlEvents)allControlEvents;
</code></pre>

<p>// 获取针对某一特定事件目标的全部动作列表</p>

<pre><code>- (NSArray *)actionsForTarget:(id)target forControlEvent:(UIControlEvents)controlEvent;
</code></pre>

<p>//</p>

<pre><code>- (void)sendAction:(SEL)action to:(id)target forEvent:(UIEvent *)event;
</code></pre>

<p>// 如果设计了一个自定义控件类，可以使用sendActionsForControlEvent方法，为基本的UIControl事件或自己的自定义事件发送通知。例如，如果你的控件值正在发生变化，就可以发送相应通知，通过控件的代码可以指定时间目标，这个通知将被传播到这些指定的目标。</p>

<pre><code>- (void)sendActionsForControlEvents:(UIControlEvents)controlEvents;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIWebView详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/05/uiwebview/"/>
    <updated>2014-01-05T12:32:39+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/05/uiwebview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIWebView是继承于UIView(有关UIView请参照<a href="http://www.beyondabel.com/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>),在您的应用程序中，您可以使用UIWebView嵌入网页内容。要做到这一点，你只需创建一个UIWebView对象，将其附加到一个窗口，并发送一个请求来加载网页内容。您也可以使用此类前进和后退的网页的历史记录，甚至可以通过编程设置一些网页内容属性。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
4、iOS7新增
5、UIWebViewDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 设置代理</p>

<pre><code>id&lt;UIWebViewDelegate&gt; delegate;
</code></pre>

<p>//  加载一个url地址</p>

<pre><code>- (void)loadRequest:(NSURLRequest *)request;
</code></pre>

<p>// 加载一个html的string</p>

<pre><code>- (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL;
</code></pre>

<p>//</p>

<pre><code>- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>

<p>// 获取web的请求</p>

<pre><code>NSURLRequest *request;
</code></pre>

<p>// 重新加载</p>

<pre><code>- (void)reload; 
</code></pre>

<p>// 停止加载</p>

<pre><code>- (void)stopLoading;
</code></pre>

<p>// 返回</p>

<pre><code>- (void)goBack;
</code></pre>

<p>// 前进</p>

<pre><code>- (void)goForward;
</code></pre>

<p>// 是否能返回(只读)</p>

<pre><code>BOOL canGoBack;
</code></pre>

<p>// 是否能前进（只读)</p>

<pre><code>BOOL canGoForward;
</code></pre>

<p>// 是否正在加载（只读）</p>

<pre><code>BOOL loading;
</code></pre>

<p>// 添加javascript</p>

<pre><code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
</code></pre>

<p>// 默认值为NO，用户不可以放大或缩小页面；如果设置为YES，页面可以通过放大缩小去适应，用户也可以通过手势来放大和缩小</p>

<pre><code>BOOL scalesPageToFit;
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。</p>

<pre><code>BOOL detectsPhoneNumbers;
</code></pre>

<p>//  把网页上内容转换成可点击的链接类型</p>

<pre><code>UIDataDetectorTypes dataDetectorTypes;
</code></pre>

<p>// 这个值决定了用内嵌HTML5播放视频还是用本地的全屏控制。为了内嵌视频播放，不仅仅需要在这个页面上设置这个属性，还必须的是在HTML中的video元素必须包含webkit-playsinline属性。(iPhone默认为NO, iPad默认为YES)</p>

<pre><code>BOOL allowsInlineMediaPlayback;
</code></pre>

<p>// 在iPhone和iPad上默认使YES。这个值决定了HTML5视频可以自动播放还是需要用户去启动播放</p>

<pre><code>BOOL mediaPlaybackRequiresUserAction; 
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 获取webView中的scrollView(只读)</p>

<pre><code>UIScrollView *scrollView;
</code></pre>

<p>// 这个值决定了从这个页面是否可以Air Play(默认YES)</p>

<pre><code>BOOL mediaPlaybackAllowsAirPlay; 
</code></pre>

<p><strong>3、iOS6新增</strong></p>

<p>// 这个值决定了网页内容的渲染是否在把内容全部加载到内存中再去处理。如果设置为YES，只有网页内容加载到内存里了才会去渲染(默认值为NO)</p>

<pre><code>BOOL suppressesIncrementalRendering; 
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。(默认为YES)</p>

<pre><code>BOOL keyboardDisplayRequiresUserAction;
</code></pre>

<p><strong>4、iOS7新增</strong></p>

<p>// 随意翻阅模式</p>

<pre><code>UIWebPaginationMode paginationMode;
UIWebPaginationBreakingMode paginationBreakingMode;
CGFloat pageLength;
CGFloat gapBetweenPages;
</code></pre>

<p>当在原生应用中，使用 UIWebView 实现丰富内容时，或者对于原生 webapp，我们可以为了电子书阅读体验使用 Paginate （随意翻阅）特性，避免垂直滚动条（类似 Windows 8 应用体验）。如果应用显示动态内容，这一特性是完美的，我们不能预先优化分页。有不同的 Objective-C 属性配置分页过程。要启用它，需要这么做：</p>

<pre><code>myWebView.paginationMode = UIWebPaginationModeLeftToRight;
myWebView.paginationBreakingMode = UIWebPaginationBreakingModePage;
myWebView.gapBetweenPages = 50; 
</code></pre>

<p>// 获取页码总数(只读)</p>

<pre><code>NSUInteger pageCount;
</code></pre>

<p><strong>5、UIWebViewDelegate协议（可选）</strong></p>

<p>//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。</p>

<pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
</code></pre>

<p>// 开始加载的时候执行该方法。</p>

<pre><code>- (void)webViewDidStartLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载完成的时候执行该方法。</p>

<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载出错的时候执行该方法。</p>

<pre><code>- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISearchBar详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/05/uisearchbar/"/>
    <updated>2014-01-05T12:32:30+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/05/uisearchbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong>
UISearchBar类实现一个文本字段控制基于文本的搜索，它是继承于UIView(有关UIView的介绍请到<a href="http://www.beyondabel.com/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>)。控制输入文字，一个搜索按钮，书签按钮和取消按钮提供了一个文本字段。该对象的UISearchBar实际上并不执行任何搜查。您可以使用委托符合UISearchBarDelegate协议对象，实现这些输入文字和点击按钮的事件。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性和方法
2、iOS5新增
3、iOS7新增
4、UISearchBarDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性和方法</strong></p>

<p>// 设置控件样式（默认UIBarStyleDefault）</p>

<pre><code>UIBarStyle              barStyle;              
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UISearchBarDelegate&gt; delegate;              
</code></pre>

<p>// 控件上面显示的文字</p>

<pre><code>NSString               *text;                  
</code></pre>

<p>// 显示在顶部的单行文字，通常作为一个提示行</p>

<pre><code>NSString               *prompt;                
</code></pre>

<p>// 半透明的提示文字，输入搜索内容会消失</p>

<pre><code>NSString               *placeholder;           
</code></pre>

<p>// 是否在控件的右端显示一个书的按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsBookmarkButton;   
</code></pre>

<p>// 是否显示cancel按钮</p>

<pre><code>BOOL                    showsCancelButton; 
- (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated;    
</code></pre>

<p>// 是否在控件的右端显示搜索结果按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsSearchResultsButton; 
</code></pre>

<p>// 搜索结果按钮是否被选中</p>

<pre><code>BOOL searchResultsButtonSelected; 
</code></pre>

<p>// bar的颜色(具有渐变效果)</p>

<pre><code>UIColor *tintColor;
UIColor *barTintColor(iOS7.0);

UISearchBarStyle searchBarStyle (iOS7.0);
</code></pre>

<p> // 指定控件是否会有透明效果</p>

<pre><code>BOOL translucent;
</code></pre>

<p>// 设置在什么情况下自动大写（默认UITextAutocapitalizationTypeNone）</p>

<pre><code>UITextAutocapitalizationType autocapitalizationType;  
</code></pre>

<p>// 对于文本对象自动校正风格 （默认UITextAutocorrectionTypeDefault）</p>

<pre><code>UITextAutocorrectionType     autocorrectionType;      
</code></pre>

<p>//  （默认UITextSpellCheckingTypeDefault）</p>

<pre><code>UITextSpellCheckingType      spellCheckingType;       
</code></pre>

<p>// 键盘样式 （默认UIKeyboardTypeDefault）</p>

<pre><code>UIKeyboardType               keyboardType;            
</code></pre>

<p>// 搜索栏下部的选择栏，数组里面的内容是按钮的标题</p>

<pre><code>NSArray   *scopeButtonTitles;
</code></pre>

<p>// 搜索栏下部的选择栏按钮的个数</p>

<pre><code>NSInteger  selectedScopeButtonIndex; 
</code></pre>

<p>// 控制搜索栏下部的选择栏是否显示出来</p>

<pre><code>BOOL       showsScopeBar; 
</code></pre>

<p>// 提供一个遮盖视图</p>

<pre><code>UIView *inputAccessoryView;
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 设置背景图片</p>

<pre><code>UIImage *backgroundImage;
</code></pre>

<p>// 设置scope的背景颜色</p>

<pre><code>UIImage *scopeBarBackgroundImage;


- (void)setSearchFieldBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state;
- (UIImage *)searchFieldBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下search的ico图片</p>

<pre><code>- (void)setImage:(UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 获取某个状态下的ico图片</p>

<pre><code>- (UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下scopeBarButton的背景图片</p>

<pre><code>- (void)setScopeBarButtonBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; 
</code></pre>

<p>// 获取某个状态下scopeBarButton的背景图片</p>

<pre><code>- (UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
- (UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
- (NSDictionary *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchFieldBackgroundPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchTextPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>- (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon;
- (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon;
</code></pre>

<p><strong>3、iOS7新增</strong></p>

<p>//</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;  
</code></pre>

<p>//</p>

<pre><code>- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p><strong>4、UISearchBarDelegate协议（可选）</strong></p>

<p>// 是否允许编辑，如果返回为NO则不能成为第一响应者</p>

<pre><code>- (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar;                      
</code></pre>

<p>// 开始编辑</p>

<pre><code>- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar;                     
</code></pre>

<p>// 是否允许结束编辑</p>

<pre><code>- (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar;                        
</code></pre>

<p>// 结束编辑</p>

<pre><code>- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar;                       
</code></pre>

<p>// 文本内容改变时调用</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText;   
</code></pre>

<p>// 如果允许继续输入，那么返回YES，否则返回NO。（可以对字数进行限制）</p>

<pre><code>- (BOOL)searchBar:(UISearchBar *)searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text; 
</code></pre>

<p>// 当搜索按钮被点击的时候</p>

<pre><code>- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar;                     
</code></pre>

<p>//</p>

<pre><code>- (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar;                   
</code></pre>

<p>// cancel按钮点击时调用</p>

<pre><code>- (void)searchBarCancelButtonClicked:(UISearchBar *) searchBar;                    
</code></pre>

<p>// ResultsList按钮被点击时调用</p>

<pre><code>- (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar; 
</code></pre>

<p>// 还有一个很重要的事情，设了按钮就要给他们安排功能。所以说，我们要实现这个代理UISearchBarDelegate里的这个方法searchBar:selectedScopeButtonIndexDidChange:告诉表格，你选择的范围是啥。</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIScrollView详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/05/uiscrollview/"/>
    <updated>2014-01-05T12:32:18+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/05/uiscrollview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIScrollView控制继承于UIView(有关UIView的介绍请到<a href="http://www.beyondabel.com/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>),该UIScrollView的类提供了用于显示的内容比应用程序的窗口的大小支持。它使用户能够通过使刷卡手势内容中滚动，并从内容部分通过使捏的手势和背部放大。</p>

<p>UIScrollView的是几个UIKit类包括的UITableView和UITextView中的超类。</p>

<p>一个UIScrollView对象（或者，简单地说，一个滚动视图）的核心概念是，它是一个视图，其起源是可调过的内容视图。它剪辑的内容，它的框架，这通常（但不一定）恰逢该应用程序的主窗口。滚动视图跟踪手指的变动，并相应调整原点。这正显示出它的内容“，通过”滚动视图的视图绘制的基础上，新的原点，它被固定在内容视图的偏移部分本身。滚动视图本身没有绘制，除了显示垂直和水平滚动的指标。滚动视图必须知道的内容视图的大小，所以它知道何时停止滚动，默认情况下，它“反弹”回来时，滚动超出了内容的范围。</p>

<!--more-->


<p>用于管理内容的绘制有关的对象显示在一个滚动视图应该瓦片的内容的子视图，以便没有视图超过屏幕的大小。当用户在滚动滚动视图，这个对象应该添加和删除子视图是必要的。</p>

<p>由于滚动视图没有滚动条，它必须知道是否触摸信号的意图与滚动意图在内容跟踪一个子视图。做出此决定，它暂时拦截触摸按下事件通过启动一个定时器，并在定时器触发之前，看是否触摸手指做任何运动。如果定时器触发无位置显著的变化，滚动视图将跟踪事件的内容视图的感动子视图。然后，如果用户在定时器期满前拉着自己的手指远远不够，滚动视图将取消任何跟踪的子视图，并进行滚动本身。子类可以重写touchesShouldBegin ： withEvent：方法inContentView ：,pagingEnabled和touchesShouldCancelInContentView ：方法（这是由滚动视图调用）来影响滚动视图如何处理滚动手势。</p>

<p>滚动视图还处理缩放和平移的内容。当用户使一个夹在或向外挤压手势，滚动视图调整偏移量和内容的标度。当手势结束，管理内容视图中的对象应该要更新的内容为必要的子视图。 （请注意，手势可以结束和手指仍可能下跌。 ）虽然手势正在进行中，滚动视图不发送任何跟踪调用子视图。</p>

<p>该UIScrollView的类可以有必须采取UIScrollViewDelegate协议的委托。对于缩放和平移工作，委托必须实现viewForZoomingInScrollView ：和scrollViewDidEndZooming ： withView ： atScale ： ，此外，最大（ maximumZoomScale ）和最小（ minimumZoomScale ）变焦倍数必须是不同的。</p>

<p><strong>目录</strong></p>

<p>// 监控目前滚动的位置(默认CGPointZero)</p>

<pre><code>CGPoint                      contentOffset; 
- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;
</code></pre>

<p>// 滚动范围的大小(默认CGSizeZero)</p>

<pre><code>CGSize                       contentSize; 
</code></pre>

<p>// 视图在scrollView中的位置(UIEdgeInsetsZero)</p>

<pre><code>UIEdgeInsets                 contentInset;                   
</code></pre>

<p>// 设置协议</p>

<pre><code>id&lt;UIScrollViewDelegate&gt;      delegate;                       
</code></pre>

<p>// 指定控件是否只能在一个方向上滚动(默认为NO)</p>

<pre><code>BOOL directionalLockEnabled;         
</code></pre>

<p>// 控制控件遇到边框是否反弹(默认为YES)</p>

<pre><code>BOOL                         bounces;                        
</code></pre>

<p>// 控制垂直方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceVertical;           
</code></pre>

<p>// 控制水平方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceHorizontal;         
</code></pre>

<p>// 控制控件是否整页翻动(默认为NO)</p>

<pre><code>BOOL          pagingEnabled;                  
</code></pre>

<p>// 控制控件是否能滚动</p>

<pre><code>BOOL          scrollEnabled;                  
</code></pre>

<p>// 控制是否显示水平方向的滚动条</p>

<pre><code>BOOL                         showsHorizontalScrollIndicator; 
</code></pre>

<p>// 控制是否显示垂直方向的滚动条</p>

<pre><code>BOOL                         showsVerticalScrollIndicator;   
</code></pre>

<p>// 指定滚动条在scrollerView中的位置</p>

<pre><code>UIEdgeInsets                 scrollIndicatorInsets;          
</code></pre>

<p>// 设定滚动条的样式</p>

<pre><code>UIScrollViewIndicatorStyle   indicatorStyle;                 
</code></pre>

<p>// 改变scrollerView的减速点位置</p>

<pre><code>CGFloat                      decelerationRate;
</code></pre>

<p>// UITableView 在EnablePage状态下滚动到指定的页面上</p>

<pre><code>- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>//  这个很有用，闪一下滚动条，暗示是否有可滚动的内容。可以在ViewDidAppear或[table reload]之后调用。</p>

<pre><code>- (void)flashScrollIndicators; 
</code></pre>

<p>// 监控当前目标是否正在被跟踪(只读)</p>

<pre><code>BOOL tracking;
</code></pre>

<p>//  监控当前目标是否正在被拖拽(只读)</p>

<pre><code>BOOL dragging;
</code></pre>

<p>// 监控当前目标是否正在减速(只读)</p>

<pre><code>BOOL decelerating;    
</code></pre>

<p>// 控制视图是否延时调用开始滚动的方法</p>

<pre><code>BOOL delaysContentTouches;       
</code></pre>

<p>// 控制控件是否接触取消touch的事件</p>

<pre><code>BOOL canCancelContentTouches;
</code></pre>

<p>//返回yes 是不滚动 scroll 返回no 是滚动scroll</p>

<pre><code>- (BOOL)touchesShouldBegin:(NSSet *)touches withEvent:(UIEvent *)event inContentView:(UIView *)view;
</code></pre>

<p>//NO scroll不可以滚动 YES scroll可以滚动</p>

<pre><code>- (BOOL)touchesShouldCancelInContentView:(UIView *)view;
</code></pre>

<p>// 缩小的最小比例</p>

<pre><code>CGFloat minimumZoomScale;     
</code></pre>

<p>// 放大的最大比例</p>

<pre><code>CGFloat maximumZoomScale;     
</code></pre>

<p>// 设置变化比例</p>

<pre><code>CGFloat zoomScale;  
- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated;
</code></pre>

<p>//  设置变化范围</p>

<pre><code>- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>// 控制缩放的时候是否会反弹</p>

<pre><code>BOOL  bouncesZoom;
</code></pre>

<p>// 判断控件的大小是否正在改变(只读)</p>

<pre><code>BOOL zooming;
</code></pre>

<p>// 判断是否正在进行缩放反弹(只读)</p>

<pre><code>BOOL zoomBouncing;
</code></pre>

<p>// 控制控件滚动到顶部</p>

<pre><code>BOOL  scrollsToTop;
</code></pre>

<p>// Use these accessors to configure the scroll view&rsquo;s built-in gesture recognizers.
// Do not change the gestures&#8217; delegates or override the getters for these properties.
// 只读</p>

<pre><code>UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);
</code></pre>

<p>// <code>pinchGestureRecognizer</code> will return nil when zooming is disabled.
// 只读</p>

<pre><code>UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);

UIScrollViewKeyboardDismissMode keyboardDismissMode NS_AVAILABLE_IOS(7_0); // default is UIScrollViewKeyboardDismissModeNone
</code></pre>

<p>@end</p>

<p>UIScrollViewDelegate协议（可选）</p>

<p>//只要滚动了就会触发</p>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView;
</code></pre>

<p>// 当scrollview发生缩放的时相应</p>

<pre><code>- (void)scrollViewDidZoom:(UIScrollView *)scrollView;
</code></pre>

<p>// 将要拖拽视图</p>

<pre><code>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;
</code></pre>

<p>// 开始拖拽视图</p>

<pre><code>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset;
</code></pre>

<p>// 完成拖拽</p>

<pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;
</code></pre>

<p>// 将开始降速时</p>

<pre><code>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;   
</code></pre>

<p>// 减速停止了时执行</p>

<pre><code>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;      
</code></pre>

<p>// 滚动动画停止时执行,代码改变时出发,也就是setContentOffset改变时</p>

<pre><code>- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; 
</code></pre>

<p>// 设置放大缩小的视图，要是uiscrollview的subview</p>

<pre><code>- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;     
</code></pre>

<p>// 当scrollview将要发生缩放的时相应</p>

<pre><code>- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view; 
</code></pre>

<p>// 完成放大缩小时调用</p>

<pre><code>- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale; 
</code></pre>

<p>// //如果你不是完全滚动到滚轴视图的顶部，你可以轻点状态栏，那个可视的滚轴视图会一直滚动到顶部，那是默认行为，你可以通过该方法返回NO来关闭它 。点击状态栏，scroll view回到顶部，如果想实现这个，实现代理方法scrollViewShouldScrollToTop返回YES，当完成时，给代理发送scrollViewDidScrollToTop: 消息</p>

<pre><code>- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;   
- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIAlertView详解]]></title>
    <link href="http://www.beyondabel.com/blog/2014/01/05/uialertview/"/>
    <updated>2014-01-05T12:32:06+08:00</updated>
    <id>http://www.beyondabel.com/blog/2014/01/05/uialertview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>使用UIAlertView类显示一个警告信息给用户。警报视图的功能类似，但不同的外观在一个动作片（ UIActionSheet的一个实例）。UIAlertView继承于UIView(有关UIView的介绍请到<a href="http://www.beyondabel.com/blog/2014/01/01/uiview/">《iOS组件之UIView详解》</a>)。</p>

<p>使用定义的属性和方法在这个类来设置标题，消息和警报视图的委托和配置按钮。你必须设置一个委托，如果你添加自定义按钮。委托应符合UIAlertViewDelegate协议。使用show方法来显示一个警报视图，一旦它被配置。</p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 初始化UIAlertView</p>

<pre><code>- (id)initWithTitle:(NSString *)title message:(NSString *)message delegate:(id &lt;UIAlertViewDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UIAlertViewDelegate&gt; delegate;
</code></pre>

<p>// 设置title</p>

<pre><code>NSString *title;
</code></pre>

<p>// 显示的消息文本文字</p>

<pre><code>NSString *message;
</code></pre>

<p>// 添加一个Button到AlertView并且指定按钮显示的文字，并且返回它的索引(从0开始，cancelButton的索引是0)</p>

<pre><code>- (NSInteger)addButtonWithTitle:(NSString *)title; 
</code></pre>

<p>// 通过下标获取button的title</p>

<pre><code>- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// button的总数(只读)</p>

<pre><code>NSInteger numberOfButtons;
</code></pre>

<p>// 取消按钮的下标</p>

<pre><code>NSInteger cancelButtonIndex;
</code></pre>

<p>// 第一个其他button的下标(只读)</p>

<pre><code>NSInteger firstOtherButtonIndex;
</code></pre>

<p>// 是否显示了(只读)</p>

<pre><code>BOOL visible;
</code></pre>

<p>// 动画显示alert.</p>

<pre><code>- (void)show;
</code></pre>

<p>// 隐藏按下指定索引值的按钮之后，隐藏AlertView，并制定是否启动动画效果</p>

<pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre>

<p>// 设置alertView样式（iOS5.0）</p>

<pre><code>UIAlertViewStyle alertViewStyle;
</code></pre>

<p>// 返回指定索引值的TextField ，这个API仅存在于IOS5.0以上</p>

<pre><code>- (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex;
</code></pre>

<p>UIAlertViewDelegate协议（可选）</p>

<p>// 当一个指定索引的按钮被点击的时候，回调此方法，buttonIndex是按钮的索引值，从0开始</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 当用户按下HOME键的时候，回调此方法，用户点击Cancel按钮的时候不会回调此方法</p>

<pre><code>- (void)alertViewCancel:(UIAlertView *)alertView;
</code></pre>

<p>// 开始显示View的动画之前进行回调</p>

<pre><code>- (void)willPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 显示动画完成之后进行回调</p>

<pre><code>- (void)didPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 将要开始View隐藏动画的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 
</code></pre>

<p>// 当View的隐藏动画结束的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 编辑任何默认的字段添加的风格之后调用</p>

<pre><code>- (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView;
</code></pre>
]]></content>
  </entry>
  
</feed>
