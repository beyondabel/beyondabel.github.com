<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Abel之家]]></title>
  <link href="http://beyondabel.github.io/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2014-01-08T10:23:59+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISwitch详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/11/uiswitch/"/>
    <updated>2014-01-11T12:34:31+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/11/uiswitch</id>
    <content type="html"><![CDATA[<p>// 开关是否打开</p>

<pre><code>BOOL on;
</code></pre>

<p>// 这个frame会被忽略，他会强制设置大小</p>

<!--more-->


<pre><code>- (id)initWithFrame:(CGRect)frame;
</code></pre>

<p>// 打开/关闭调用函数(animated：是否使用动画)</p>

<pre><code>- (void)setOn:(BOOL)on animated:(BOOL)animated;
</code></pre>

<p><strong>iOS5新增    </strong></p>

<p>// 开关打开时颜色</p>

<pre><code>UIColor *onTintColor;
</code></pre>

<p><strong>iOS6新增</strong>
// 背影颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 开关的圆形滑钮的颜色</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 开关打开时自定义图片</p>

<pre><code>UIImage *onImage;
</code></pre>

<p>// 开关关闭时自定义图片</p>

<pre><code>UIImage *offImage;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIPageControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/09/uipagecontrol/"/>
    <updated>2014-01-09T12:33:46+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/09/uipagecontrol</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS6.0新增
</code></pre>

<!--more-->


<p><strong>1、基本属性及方法</strong></p>

<p>// 指定页面个数（默认为0）</p>

<pre><code>NSInteger numberOfPages;
</code></pre>

<p>// 当前选中的页面（默认为0，范围为0 ～ numberOfPages-1）</p>

<pre><code>NSInteger currentPage;
</code></pre>

<p>// 如果在numberOfPages为1的情况下隐藏指示器，可以将hideForSinglePage的值设为YES。默认情况下，即使只有一个页面，指示器也会显示进来。</p>

<pre><code>BOOL hidesForSinglePage;
</code></pre>

<p>// 如果你希望直到有时间执行完你的操作之后，才更新当前指示器当前指示页，可以将 defersCurrentPageDisPlay 设为YES。这样的话你必须调用控件的 updateCurentPageDisPlay 来更新当前页</p>

<pre><code>BOOL defersCurrentPageDisplay;
</code></pre>

<p>// 更新当前页</p>

<pre><code>- (void)updateCurrentPageDisplay;
</code></pre>

<p>// 返回接受者的边界大小，与容纳被给的页面数有关</p>

<pre><code>- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;
</code></pre>

<p><strong>2、iOS6.0新增</strong>
// 未选中的点的颜色</p>

<pre><code>UIColor *pageIndicatorTintColor;
</code></pre>

<p>// 当前点颜色</p>

<pre><code>UIColor *currentPageIndicatorTintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITableView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/07/uitableview/"/>
    <updated>2014-01-07T12:33:02+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/07/uitableview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UITableView简单来说是一个表视图，继承于UIScrollView，用于显示和编辑信息的分层列表。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、tableView的基本属性及方法
2、访问tableView的画图区
3、访问cells和sections
4、滚动tableView
5、插入、删除、移动行和sections
6、管理和编辑cell
7、管理sections
8、配置
9、iOS5.0新增
10、iOS6.0新增
11、iOS7.0
12、UITableViewDataSource协议
    12.1必须实现
    12.2可选
        12.2.1编辑模式
    12.2.2数据操作  
13、UITableViewDelegate协议（可选）
    13.1定制化
    13.2iOS6新增
    13.3可变高度支持
    13.4iOS7.0新增
    13.5header 和 footer Section 信息
    13.6附属公开的接口
    13.7选择
    13.8编辑
    13.9移动
    13.10缩格
    13.11复制/粘贴
</code></pre>

<p><strong>1、tableView的基本属性及方法</strong></p>

<p>// 初始化</p>

<pre><code>- (id)initWithFrame:(CGRect)frame style:(UITableViewStyle)style;
</code></pre>

<p>// 设置tableView的样式（只读）</p>

<pre><code>UITableViewStyle style;
</code></pre>

<p>// 设置数据资源代理</p>

<pre><code>id &lt;UITableViewDataSource&gt; dataSource;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UITableViewDelegate&gt; delegate;
</code></pre>

<p>// 设置每个row的高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat rowHeight;
</code></pre>

<p>// 设置sectionHeader高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionHeaderHeight;   
</code></pre>

<p>// 设置sectionFooter高度，这个高度将被当成默认高度</p>

<pre><code>CGFloat sectionFooterHeight;   
</code></pre>

<p>//  设置tableView的背景view</p>

<pre><code>UIView *backgroundView;
</code></pre>

<p>// 刷新tableView</p>

<pre><code>- (void)reloadData;
</code></pre>

<p>// 刷新tableView中的section</p>

<pre><code>- (void)reloadSectionIndexTitles;
</code></pre>

<p>// sections的数量</p>

<pre><code>- (NSInteger)numberOfSections;
</code></pre>

<p>// 下标为section中的row数量</p>

<pre><code>- (NSInteger)numberOfRowsInSection:(NSInteger)section;
</code></pre>

<p><strong>2、访问tableView的画图区</strong></p>

<p>// 返回指定section的矩形</p>

<pre><code>- (CGRect)rectForSection:(NSInteger)section; 
</code></pre>

<p>// 返回indexPath指定行的矩形</p>

<pre><code>- (CGRect)rectForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的footer矩形</p>

<pre><code>- (CGRect)rectForFooterInSection:(NSInteger)section;
</code></pre>

<p>// 返回section的header矩形</p>

<pre><code>- (CGRect)rectForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>3、访问cells和sections</strong></p>

<p>// 通过cell得到这个cell在tableView的位置</p>

<pre><code>- (NSIndexPath *)indexPathForCell:(UITableViewCell *)cell;
</code></pre>

<p>// 根据一个几何点返回indexPath,如果超过边界返回nil</p>

<pre><code>- (NSIndexPath *)indexPathForRowAtPoint:(CGPoint)point;
</code></pre>

<p>// 根据一个几何的矩形返回矩形所覆盖的行,返回是一个indexPath数组</p>

<pre><code>- (NSArray *)indexPathsForRowsInRect:(CGRect)rect;         
</code></pre>

<p>//  根据IndexPath返回cell</p>

<pre><code>- (UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;            
</code></pre>

<p>//</p>

<pre><code>- (NSArray *)visibleCells;
- (NSArray *)indexPathsForVisibleRows;
</code></pre>

<p><strong>4、滚动tableView</strong></p>

<p>// 滚动到指定位置</p>

<pre><code>- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<p>//  同上</p>

<pre><code>- (void)scrollToNearestSelectedRowAtScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;
</code></pre>

<p><strong>5、插入、删除、移动行和sections</strong></p>

<p>// 和endUpdates一起用，让插入、删除、选择操作同时动画，没用过</p>

<pre><code>- (void)beginUpdates;
</code></pre>

<p>//</p>

<pre><code>- (void)endUpdates;
</code></pre>

<p>//根据indexPath数组插入行</p>

<pre><code>- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//根据indexPath数组删除行</p>

<pre><code>- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动一行到另一行</p>

<pre><code>- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//插入sections</p>

<pre><code>- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//删除sections</p>

<pre><code>- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p>//移动section</p>

<pre><code>- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;
</code></pre>

<p><strong>6、管理和编辑cell</strong></p>

<p>// YES进入编辑模式，tableview cell会出现插入、删除、重排序的控件</p>

<pre><code>BOOL editing;
</code></pre>

<p>// 设置进入退出编辑模式</p>

<pre><code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<p><strong>7、管理sections</strong></p>

<p>//是否允许用户选取一行</p>

<pre><code>BOOL allowsSelection;
</code></pre>

<p>//返回选定行的indexPath,单行</p>

<pre><code>- (NSIndexPath *)indexPathForSelectedRow;
</code></pre>

<p>// 根据indexPath选择一行</p>

<pre><code>- (void)selectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated scrollPosition:(UITableViewScrollPosition)scrollPosition;
</code></pre>

<p>// 根据indexPath取消选择这一行</p>

<pre><code>- (void)deselectRowAtIndexPath:(NSIndexPath *)indexPath animated:(BOOL)animated;
</code></pre>

<p><strong>8、配置</strong></p>

<p>// 指定当tableView中多少行的时候开始显示IndexList，默认的设置是NSIntegerMax，即默认是不显示indexList的</p>

<pre><code>NSInteger sectionIndexMinimumDisplayRowCount;
</code></pre>

<p>// 分隔线的样式(默认为UITableViewCellSeparatorStyleSingleLine)</p>

<pre><code>UITableViewCellSeparatorStyle separatorStyle;
</code></pre>

<p>// cell之间的分割线</p>

<pre><code>UIColor *separatorColor;              
</code></pre>

<p>// 设置headerView</p>

<pre><code>UIView *tableHeaderView;                            
</code></pre>

<p>// 设置footerView</p>

<pre><code>UIView *tableFooterView;                            
</code></pre>

<p>// 必须要实现的方法，与tableView同生同死</p>

<pre><code>- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;  
</code></pre>

<p><strong>9、iOS5.0新增</strong></p>

<p>// 移动section</p>

<pre><code>- (void)moveSection:(NSInteger)section toSection:(NSInteger)newSection;
</code></pre>

<p>// 移动一行到另一行</p>

<pre><code>- (void)moveRowAtIndexPath:(NSIndexPath *)indexPath toIndexPath:(NSIndexPath *)newIndexPath;
</code></pre>

<p>// 返回选定行的indexPath数组，多行</p>

<pre><code>- (NSArray *)indexPathsForSelectedRows;
</code></pre>

<p>//</p>

<pre><code>- (void)registerNib:(UINib *)nib forCellReuseIdentifier:(NSString *)identifier;
</code></pre>

<p>//  编辑模式时是否可选取一行</p>

<pre><code>BOOL allowsSelectionDuringEditing;
</code></pre>

<p>//  是否选取多行，缺省为NO(iOS 5.0)</p>

<pre><code>BOOL allowsMultipleSelection;
</code></pre>

<p>//  编辑模式时可否选取多行</p>

<pre><code>BOOL allowsMultipleSelectionDuringEditing;
</code></pre>

<p><strong>10、iOS6.0新增</strong></p>

<p>// 我想在numberOfRowsInSection方法内获取该section的header View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;
</code></pre>

<p>// 我想在numberOfRowsInSection方法内获取该section的footer View。须要在使用之前用 tableView 的 registerNib:forHeaderFooterViewReuseIdentifier:  或 registerClass:forHeaderFooterViewReuseIdentifier:。</p>

<pre><code>- (UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;
</code></pre>

<p>// 设置索引号颜色</p>

<pre><code>UIColor *sectionIndexColor;
</code></pre>

<p>// 设置索引号背景颜色</p>

<pre><code>UIColor *sectionIndexTrackingBackgroundColor;
</code></pre>

<p>// 注册（没有测试有什么用)</p>

<pre><code>- (void)registerClass:(Class)cellClass forCellReuseIdentifier:(NSString *)identifier;
- (void)registerNib:(UINib *)nib forHeaderFooterViewReuseIdentifier:(NSString *)identifier; 
- (void)registerClass:(Class)aClass forHeaderFooterViewReuseIdentifier:(NSString *)identifier;
- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier forIndexPath:(NSIndexPath *)indexPath;
- (id)dequeueReusableHeaderFooterViewWithIdentifier:(NSString *)identifier;
</code></pre>

<p><strong>11、iOS7.0</strong></p>

<p>// 预设SectionFooter的高度</p>

<pre><code>CGFloat estimatedSectionFooterHeight;
UIEdgeInsets separatorInset;
UIColor *sectionIndexBackgroundColor;
</code></pre>

<p>// 预设row的高度</p>

<pre><code>CGFloat estimatedRowHeight;     
</code></pre>

<p>// 预设SectionHeader的高度</p>

<pre><code>CGFloat estimatedSectionHeaderHeight; 
</code></pre>

<p><strong>12、UITableViewDataSource协议</strong></p>

<p><strong>12.1必须实现</strong>
// 返回每个section中row的数量</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;
</code></pre>

<p>// 返回每个UITableViewCell</p>

<pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>12.2可选</strong></p>

<p>// 返回section的个数</p>

<pre><code>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;              
</code></pre>

<p>//  section headerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section; 
</code></pre>

<p>// section footerView的title文本内容</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>12.2.1编辑模式</strong></p>

<p>// 设置可编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>12.2.1.1移动</strong></p>

<p>// 设置是否可移动</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 设置索引号</p>

<pre><code>- (NSArray *)sectionIndexTitlesForTableView:(UITableView *)tableView
</code></pre>

<p>// 点击索引触发</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView sectionForSectionIndexTitle:(NSString *)title atIndex:(NSInteger)index;
</code></pre>

<p><strong>12.2.2数据操作</strong></p>

<p>// 插入/删除指定数据</p>

<pre><code>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 重新排序/移动数据操作</p>

<pre><code>- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;
</code></pre>

<p><strong>13、UITableViewDelegate协议（可选）</strong></p>

<p><strong>13.1定制化</strong></p>

<p>// cell将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.2iOS6新增</strong></p>

<p>// HeaderView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView将要显示的时候被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView willDisplayFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// cell结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath*)indexPath;
</code></pre>

<p>// HeaderView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingHeaderView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p>// FooterView结束显示时被调用</p>

<pre><code>- (void)tableView:(UITableView *)tableView didEndDisplayingFooterView:(UIView *)view forSection:(NSInteger)section;
</code></pre>

<p><strong>13.3可变高度支持</strong></p>

<p>// 根据indexPath返回row的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 根据indexPath返回HeaderView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据indexPath返回FooterView的高度</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.4iOS7.0新增</strong></p>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的cell的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Header的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 代理函数或者设置estimatedRowHeight属性值，提供一个预估高度值，对于可变高度的Footer的表格视图可改进性能</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.5header 和 footer Section 信息</strong></p>

<p>// 根据section创建header section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;
</code></pre>

<p>// 根据section创建footer section</p>

<pre><code>- (UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;
</code></pre>

<p><strong>13.6附属公开的接口</strong></p>

<p>// 回调设置辅助按钮被点击后的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView accessoryButtonTappedForRowWithIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.7选择</strong></p>

<p>// 回调设置某行是否当被点击后处于高亮状态</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行处于高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didHighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调当某行失去高亮状态时的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didUnhighlightRowAtIndexPath:(NSIndexPath *)indexPath NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>// 回调某行将要被选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行将要被取消选中的行为</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView willDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经被选中点击的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调某行已经取消选中的行为</p>

<pre><code>- (void)tableView:(UITableView *)tableView didDeselectRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.8编辑</strong></p>

<p>// 回调设置某行进入了哪种编辑模式</p>

<pre><code>- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置某行进入删除模式的删除按钮名字</p>

<pre><code>- (NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 是否允许对row进行编辑</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldIndentWhileEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 开始编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView willBeginEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 结束编辑row时触发</p>

<pre><code>- (void)tableView:(UITableView*)tableView didEndEditingRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.9移动</strong></p>

<p>// 移动Row时会把触发，在交换Row位置的时候，必须同时交换DataSource中数据的位置。</p>

<pre><code>- (NSIndexPath *)tableView:(UITableView *)tableView targetIndexPathForMoveFromRowAtIndexPath:(NSIndexPath *)sourceIndexPath toProposedIndexPath:(NSIndexPath *)proposedDestinationIndexPath;               
</code></pre>

<p><strong>13.10缩格</strong></p>

<p>// 设置内容缩进</p>

<pre><code>- (NSInteger)tableView:(UITableView *)tableView indentationLevelForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p><strong>13.11复制/粘贴</strong></p>

<p>// 回调设置某行被长按是否出现菜单栏</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView shouldShowMenuForRowAtIndexPath:(NSIndexPath *)indexPath;
</code></pre>

<p>// 回调设置菜单栏是否显示哪些菜单栏选项</p>

<pre><code>- (BOOL)tableView:(UITableView *)tableView canPerformAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>

<p>// 回调点击菜单栏选项触发的事件</p>

<pre><code>- (void)tableView:(UITableView *)tableView performAction:(SEL)action forRowAtIndexPath:(NSIndexPath *)indexPath withSender:(id)sender;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIWebView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiwebview/"/>
    <updated>2014-01-05T12:32:39+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiwebview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>在您的应用程序中，您可以使用UIWebView嵌入网页内容。要做到这一点，你只需创建一个UIWebView对象，将其附加到一个窗口，并发送一个请求来加载网页内容。您也可以使用此类前进和后退的网页的历史记录，甚至可以通过编程设置一些网页内容属性。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
4、iOS7新增
5、UIWebViewDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 设置代理</p>

<pre><code>id&lt;UIWebViewDelegate&gt; delegate;
</code></pre>

<p>//  加载一个url地址</p>

<pre><code>- (void)loadRequest:(NSURLRequest *)request;
</code></pre>

<p>// 加载一个html的string</p>

<pre><code>- (void)loadHTMLString:(NSString *)string baseURL:(NSURL *)baseURL;
</code></pre>

<p>//</p>

<pre><code>- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>

<p>// 获取web的请求</p>

<pre><code>NSURLRequest *request;
</code></pre>

<p>// 重新加载</p>

<pre><code>- (void)reload; 
</code></pre>

<p>// 停止加载</p>

<pre><code>- (void)stopLoading;
</code></pre>

<p>// 返回</p>

<pre><code>- (void)goBack;
</code></pre>

<p>// 前进</p>

<pre><code>- (void)goForward;
</code></pre>

<p>// 是否能返回(只读)</p>

<pre><code>BOOL canGoBack;
</code></pre>

<p>// 是否能前进（只读)</p>

<pre><code>BOOL canGoForward;
</code></pre>

<p>// 是否正在加载（只读）</p>

<pre><code>BOOL loading;
</code></pre>

<p>// 添加javascript</p>

<pre><code>- (NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;
</code></pre>

<p>// 默认值为NO，用户不可以放大或缩小页面；如果设置为YES，页面可以通过放大缩小去适应，用户也可以通过手势来放大和缩小</p>

<pre><code>BOOL scalesPageToFit;
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。</p>

<pre><code>BOOL detectsPhoneNumbers;
</code></pre>

<p>//  把网页上内容转换成可点击的链接类型</p>

<pre><code>UIDataDetectorTypes dataDetectorTypes;
</code></pre>

<p>// 这个值决定了用内嵌HTML5播放视频还是用本地的全屏控制。为了内嵌视频播放，不仅仅需要在这个页面上设置这个属性，还必须的是在HTML中的video元素必须包含webkit-playsinline属性。(iPhone默认为NO, iPad默认为YES)</p>

<pre><code>BOOL allowsInlineMediaPlayback;
</code></pre>

<p>// 在iPhone和iPad上默认使YES。这个值决定了HTML5视频可以自动播放还是需要用户去启动播放</p>

<pre><code>BOOL mediaPlaybackRequiresUserAction; 
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 获取webView中的scrollView(只读)</p>

<pre><code>UIScrollView *scrollView;
</code></pre>

<p>// 这个值决定了从这个页面是否可以Air Play(默认YES)</p>

<pre><code>BOOL mediaPlaybackAllowsAirPlay; 
</code></pre>

<p><strong>3、iOS6新增</strong></p>

<p>// 这个值决定了网页内容的渲染是否在把内容全部加载到内存中再去处理。如果设置为YES，只有网页内容加载到内存里了才会去渲染(默认值为NO)</p>

<pre><code>BOOL suppressesIncrementalRendering; 
</code></pre>

<p>// 如果设置为YES，用户必须明确的点击页面上的元素或者相关联的输入页面来显示键盘；如果设置为NO，一个元素的焦点事件导致输入视图的显示和自动关联这个元素。(默认为YES)</p>

<pre><code>BOOL keyboardDisplayRequiresUserAction;
</code></pre>

<p><strong>4、iOS7新增</strong></p>

<p>// 随意翻阅模式</p>

<pre><code>UIWebPaginationMode paginationMode;
UIWebPaginationBreakingMode paginationBreakingMode;
CGFloat pageLength;
CGFloat gapBetweenPages;
</code></pre>

<p>当在原生应用中，使用 UIWebView 实现丰富内容时，或者对于原生 webapp，我们可以为了电子书阅读体验使用 Paginate （随意翻阅）特性，避免垂直滚动条（类似 Windows 8 应用体验）。如果应用显示动态内容，这一特性是完美的，我们不能预先优化分页。有不同的 Objective-C 属性配置分页过程。要启用它，需要这么做：</p>

<pre><code>myWebView.paginationMode = UIWebPaginationModeLeftToRight;
myWebView.paginationBreakingMode = UIWebPaginationBreakingModePage;
myWebView.gapBetweenPages = 50; 
</code></pre>

<p>// 获取页码总数(只读)</p>

<pre><code>NSUInteger pageCount;
</code></pre>

<p><strong>5、UIWebViewDelegate协议（可选）</strong></p>

<p>//当网页视图被指示载入内容而得到通知。应当返回YES，这样会进行加载。</p>

<pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
</code></pre>

<p>// 开始加载的时候执行该方法。</p>

<pre><code>- (void)webViewDidStartLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载完成的时候执行该方法。</p>

<pre><code>- (void)webViewDidFinishLoad:(UIWebView *)webView;
</code></pre>

<p>// 加载出错的时候执行该方法。</p>

<pre><code>- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISearchBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uisearchbar/"/>
    <updated>2014-01-05T12:32:30+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uisearchbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong>
UISearchBar类实现一个文本字段控制基于文本的搜索，它是继承于UIView(有关UIView的介绍请到《视图鼻祖之UIView详解》)。控制输入文字，一个搜索按钮，书签按钮和取消按钮提供了一个文本字段。该对象的UISearchBar实际上并不执行任何搜查。您可以使用委托符合UISearchBarDelegate协议对象，实现这些输入文字和点击按钮的事件。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性和方法
2、iOS5新增
3、iOS7新增
4、UISearchBarDelegate协议（可选）
</code></pre>

<p><strong>1、基本属性和方法</strong></p>

<p>// 设置控件样式（默认UIBarStyleDefault）</p>

<pre><code>UIBarStyle              barStyle;              
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UISearchBarDelegate&gt; delegate;              
</code></pre>

<p>// 控件上面显示的文字</p>

<pre><code>NSString               *text;                  
</code></pre>

<p>// 显示在顶部的单行文字，通常作为一个提示行</p>

<pre><code>NSString               *prompt;                
</code></pre>

<p>// 半透明的提示文字，输入搜索内容会消失</p>

<pre><code>NSString               *placeholder;           
</code></pre>

<p>// 是否在控件的右端显示一个书的按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsBookmarkButton;   
</code></pre>

<p>// 是否显示cancel按钮</p>

<pre><code>BOOL                    showsCancelButton; 
- (void)setShowsCancelButton:(BOOL)showsCancelButton animated:(BOOL)animated;    
</code></pre>

<p>// 是否在控件的右端显示搜索结果按钮（没有文字的时候）</p>

<pre><code>BOOL                    showsSearchResultsButton; 
</code></pre>

<p>// 搜索结果按钮是否被选中</p>

<pre><code>BOOL searchResultsButtonSelected; 
</code></pre>

<p>// bar的颜色(具有渐变效果)</p>

<pre><code>UIColor *tintColor;
UIColor *barTintColor(iOS7.0);

UISearchBarStyle searchBarStyle (iOS7.0);
</code></pre>

<p> // 指定控件是否会有透明效果</p>

<pre><code>BOOL translucent;
</code></pre>

<p>// 设置在什么情况下自动大写（默认UITextAutocapitalizationTypeNone）</p>

<pre><code>UITextAutocapitalizationType autocapitalizationType;  
</code></pre>

<p>// 对于文本对象自动校正风格 （默认UITextAutocorrectionTypeDefault）</p>

<pre><code>UITextAutocorrectionType     autocorrectionType;      
</code></pre>

<p>//  （默认UITextSpellCheckingTypeDefault）</p>

<pre><code>UITextSpellCheckingType      spellCheckingType;       
</code></pre>

<p>// 键盘样式 （默认UIKeyboardTypeDefault）</p>

<pre><code>UIKeyboardType               keyboardType;            
</code></pre>

<p>// 搜索栏下部的选择栏，数组里面的内容是按钮的标题</p>

<pre><code>NSArray   *scopeButtonTitles;
</code></pre>

<p>// 搜索栏下部的选择栏按钮的个数</p>

<pre><code>NSInteger  selectedScopeButtonIndex; 
</code></pre>

<p>// 控制搜索栏下部的选择栏是否显示出来</p>

<pre><code>BOOL       showsScopeBar; 
</code></pre>

<p>// 提供一个遮盖视图</p>

<pre><code>UIView *inputAccessoryView;
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 设置背景图片</p>

<pre><code>UIImage *backgroundImage;
</code></pre>

<p>// 设置scope的背景颜色</p>

<pre><code>UIImage *scopeBarBackgroundImage;


- (void)setSearchFieldBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state;
- (UIImage *)searchFieldBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下search的ico图片</p>

<pre><code>- (void)setImage:(UIImage *)iconImage forSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 获取某个状态下的ico图片</p>

<pre><code>- (UIImage *)imageForSearchBarIcon:(UISearchBarIcon)icon state:(UIControlState)state;
</code></pre>

<p>// 设置某个状态下scopeBarButton的背景图片</p>

<pre><code>- (void)setScopeBarButtonBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state; 
</code></pre>

<p>// 获取某个状态下scopeBarButton的背景图片</p>

<pre><code>- (UIImage *)scopeBarButtonBackgroundImageForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
- (UIImage *)scopeBarButtonDividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState;
</code></pre>

<p>//</p>

<pre><code>- (void)setScopeBarButtonTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
- (NSDictionary *)scopeBarButtonTitleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchFieldBackgroundPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>UIOffset searchTextPositionAdjustment;
</code></pre>

<p>//</p>

<pre><code>- (void)setPositionAdjustment:(UIOffset)adjustment forSearchBarIcon:(UISearchBarIcon)icon;
- (UIOffset)positionAdjustmentForSearchBarIcon:(UISearchBarIcon)icon;
</code></pre>

<p><strong>3、iOS7新增</strong></p>

<p>//</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;  
</code></pre>

<p>//</p>

<pre><code>- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p><strong>4、UISearchBarDelegate协议（可选）</strong></p>

<p>// 是否允许编辑，如果返回为NO则不能成为第一响应者</p>

<pre><code>- (BOOL)searchBarShouldBeginEditing:(UISearchBar *)searchBar;                      
</code></pre>

<p>// 开始编辑</p>

<pre><code>- (void)searchBarTextDidBeginEditing:(UISearchBar *)searchBar;                     
</code></pre>

<p>// 是否允许结束编辑</p>

<pre><code>- (BOOL)searchBarShouldEndEditing:(UISearchBar *)searchBar;                        
</code></pre>

<p>// 结束编辑</p>

<pre><code>- (void)searchBarTextDidEndEditing:(UISearchBar *)searchBar;                       
</code></pre>

<p>// 文本内容改变时调用</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText;   
</code></pre>

<p>// 如果允许继续输入，那么返回YES，否则返回NO。（可以对字数进行限制）</p>

<pre><code>- (BOOL)searchBar:(UISearchBar *)searchBar shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text; 
</code></pre>

<p>// 当搜索按钮被点击的时候</p>

<pre><code>- (void)searchBarSearchButtonClicked:(UISearchBar *)searchBar;                     
</code></pre>

<p>//</p>

<pre><code>- (void)searchBarBookmarkButtonClicked:(UISearchBar *)searchBar;                   
</code></pre>

<p>// cancel按钮点击时调用</p>

<pre><code>- (void)searchBarCancelButtonClicked:(UISearchBar *) searchBar;                    
</code></pre>

<p>// ResultsList按钮被点击时调用</p>

<pre><code>- (void)searchBarResultsListButtonClicked:(UISearchBar *)searchBar; 
</code></pre>

<p>// 还有一个很重要的事情，设了按钮就要给他们安排功能。所以说，我们要实现这个代理UISearchBarDelegate里的这个方法searchBar:selectedScopeButtonIndexDidChange:告诉表格，你选择的范围是啥。</p>

<pre><code>- (void)searchBar:(UISearchBar *)searchBar selectedScopeButtonIndexDidChange:(NSInteger)selectedScope;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIScrollView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiscrollview/"/>
    <updated>2014-01-05T12:32:18+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiscrollview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 监控目前滚动的位置(默认CGPointZero)</p>

<pre><code>CGPoint                      contentOffset; 
- (void)setContentOffset:(CGPoint)contentOffset animated:(BOOL)animated;
</code></pre>

<p>// 滚动范围的大小(默认CGSizeZero)</p>

<pre><code>CGSize                       contentSize; 
</code></pre>

<p>// 视图在scrollView中的位置(UIEdgeInsetsZero)</p>

<pre><code>UIEdgeInsets                 contentInset;                   
</code></pre>

<p>// 设置协议</p>

<pre><code>id&lt;UIScrollViewDelegate&gt;      delegate;                       
</code></pre>

<p>// 指定控件是否只能在一个方向上滚动(默认为NO)</p>

<pre><code>BOOL directionalLockEnabled;         
</code></pre>

<p>// 控制控件遇到边框是否反弹(默认为YES)</p>

<pre><code>BOOL                         bounces;                        
</code></pre>

<p>// 控制垂直方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceVertical;           
</code></pre>

<p>// 控制水平方向遇到边框是否反弹(默认为NO,如果为YES，bounces也是YES)</p>

<pre><code>BOOL                         alwaysBounceHorizontal;         
</code></pre>

<p>// 控制控件是否整页翻动(默认为NO)</p>

<pre><code>BOOL          pagingEnabled;                  
</code></pre>

<p>// 控制控件是否能滚动</p>

<pre><code>BOOL          scrollEnabled;                  
</code></pre>

<p>// 控制是否显示水平方向的滚动条</p>

<pre><code>BOOL                         showsHorizontalScrollIndicator; 
</code></pre>

<p>// 控制是否显示垂直方向的滚动条</p>

<pre><code>BOOL                         showsVerticalScrollIndicator;   
</code></pre>

<p>// 指定滚动条在scrollerView中的位置</p>

<pre><code>UIEdgeInsets                 scrollIndicatorInsets;          
</code></pre>

<p>// 设定滚动条的样式</p>

<pre><code>UIScrollViewIndicatorStyle   indicatorStyle;                 
</code></pre>

<p>// 改变scrollerView的减速点位置</p>

<pre><code>CGFloat                      decelerationRate;
</code></pre>

<p>// UITableView 在EnablePage状态下滚动到指定的页面上</p>

<pre><code>- (void)scrollRectToVisible:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>//  这个很有用，闪一下滚动条，暗示是否有可滚动的内容。可以在ViewDidAppear或[table reload]之后调用。</p>

<pre><code>- (void)flashScrollIndicators; 
</code></pre>

<p>// 监控当前目标是否正在被跟踪(只读)</p>

<pre><code>BOOL tracking;
</code></pre>

<p>//  监控当前目标是否正在被拖拽(只读)</p>

<pre><code>BOOL dragging;
</code></pre>

<p>// 监控当前目标是否正在减速(只读)</p>

<pre><code>BOOL decelerating;    
</code></pre>

<p>// 控制视图是否延时调用开始滚动的方法</p>

<pre><code>BOOL delaysContentTouches;       
</code></pre>

<p>// 控制控件是否接触取消touch的事件</p>

<pre><code>BOOL canCancelContentTouches;
</code></pre>

<p>//返回yes 是不滚动 scroll 返回no 是滚动scroll</p>

<pre><code>- (BOOL)touchesShouldBegin:(NSSet *)touches withEvent:(UIEvent *)event inContentView:(UIView *)view;
</code></pre>

<p>//NO scroll不可以滚动 YES scroll可以滚动</p>

<pre><code>- (BOOL)touchesShouldCancelInContentView:(UIView *)view;
</code></pre>

<p>// 缩小的最小比例</p>

<pre><code>CGFloat minimumZoomScale;     
</code></pre>

<p>// 放大的最大比例</p>

<pre><code>CGFloat maximumZoomScale;     
</code></pre>

<p>// 设置变化比例</p>

<pre><code>CGFloat zoomScale;  
- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated;
</code></pre>

<p>//  设置变化范围</p>

<pre><code>- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated;
</code></pre>

<p>// 控制缩放的时候是否会反弹</p>

<pre><code>BOOL  bouncesZoom;
</code></pre>

<p>// 判断控件的大小是否正在改变(只读)</p>

<pre><code>BOOL zooming;
</code></pre>

<p>// 判断是否正在进行缩放反弹(只读)</p>

<pre><code>BOOL zoomBouncing;
</code></pre>

<p>// 控制控件滚动到顶部</p>

<pre><code>BOOL  scrollsToTop;
</code></pre>

<p>// Use these accessors to configure the scroll view&rsquo;s built-in gesture recognizers.
// Do not change the gestures&#8217; delegates or override the getters for these properties.
// 只读</p>

<pre><code>UIPanGestureRecognizer *panGestureRecognizer NS_AVAILABLE_IOS(5_0);
</code></pre>

<p>// <code>pinchGestureRecognizer</code> will return nil when zooming is disabled.
// 只读</p>

<pre><code>UIPinchGestureRecognizer *pinchGestureRecognizer NS_AVAILABLE_IOS(5_0);

UIScrollViewKeyboardDismissMode keyboardDismissMode NS_AVAILABLE_IOS(7_0); // default is UIScrollViewKeyboardDismissModeNone
</code></pre>

<p>@end</p>

<p>UIScrollViewDelegate协议（可选）</p>

<p>//只要滚动了就会触发</p>

<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView;
</code></pre>

<p>// 当scrollview发生缩放的时相应</p>

<pre><code>- (void)scrollViewDidZoom:(UIScrollView *)scrollView;
</code></pre>

<p>// 将要拖拽视图</p>

<pre><code>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView;
</code></pre>

<p>// 开始拖拽视图</p>

<pre><code>- (void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContentOffset;
</code></pre>

<p>// 完成拖拽</p>

<pre><code>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;
</code></pre>

<p>// 将开始降速时</p>

<pre><code>- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;   
</code></pre>

<p>// 减速停止了时执行</p>

<pre><code>- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;      
</code></pre>

<p>// 滚动动画停止时执行,代码改变时出发,也就是setContentOffset改变时</p>

<pre><code>- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; 
</code></pre>

<p>// 设置放大缩小的视图，要是uiscrollview的subview</p>

<pre><code>- (UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView;     
</code></pre>

<p>// 当scrollview将要发生缩放的时相应</p>

<pre><code>- (void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view; 
</code></pre>

<p>// 完成放大缩小时调用</p>

<pre><code>- (void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale; 
</code></pre>

<p>// //如果你不是完全滚动到滚轴视图的顶部，你可以轻点状态栏，那个可视的滚轴视图会一直滚动到顶部，那是默认行为，你可以通过该方法返回NO来关闭它 。点击状态栏，scroll view回到顶部，如果想实现这个，实现代理方法scrollViewShouldScrollToTop返回YES，当完成时，给代理发送scrollViewDidScrollToTop: 消息</p>

<pre><code>- (BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView;   
- (void)scrollViewDidScrollToTop:(UIScrollView *)scrollView;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIAlertView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uialertview/"/>
    <updated>2014-01-05T12:32:06+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uialertview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 初始化UIAlertView</p>

<pre><code>- (id)initWithTitle:(NSString *)title message:(NSString *)message delegate:(id &lt;UIAlertViewDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;
</code></pre>

<p>// 设置代理</p>

<pre><code>id &lt;UIAlertViewDelegate&gt; delegate;
</code></pre>

<p>// 设置title</p>

<pre><code>NSString *title;
</code></pre>

<p>// 显示的消息文本文字</p>

<pre><code>NSString *message;
</code></pre>

<p>// 添加一个Button到AlertView并且指定按钮显示的文字，并且返回它的索引(从0开始，cancelButton的索引是0)</p>

<pre><code>- (NSInteger)addButtonWithTitle:(NSString *)title; 
</code></pre>

<p>// 通过下标获取button的title</p>

<pre><code>- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// button的总数(只读)</p>

<pre><code>NSInteger numberOfButtons;
</code></pre>

<p>// 取消按钮的下标</p>

<pre><code>NSInteger cancelButtonIndex;
</code></pre>

<p>// 第一个其他button的下标(只读)</p>

<pre><code>NSInteger firstOtherButtonIndex;
</code></pre>

<p>// 是否显示了(只读)</p>

<pre><code>BOOL visible;
</code></pre>

<p>// 动画显示alert.</p>

<pre><code>- (void)show;
</code></pre>

<p>// 隐藏按下指定索引值的按钮之后，隐藏AlertView，并制定是否启动动画效果</p>

<pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre>

<p>// 设置alertView样式（iOS5.0）</p>

<pre><code>UIAlertViewStyle alertViewStyle;
</code></pre>

<p>// 返回指定索引值的TextField ，这个API仅存在于IOS5.0以上</p>

<pre><code>- (UITextField *)textFieldAtIndex:(NSInteger)textFieldIndex;
</code></pre>

<p>UIAlertViewDelegate协议（可选）</p>

<p>// 当一个指定索引的按钮被点击的时候，回调此方法，buttonIndex是按钮的索引值，从0开始</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 当用户按下HOME键的时候，回调此方法，用户点击Cancel按钮的时候不会回调此方法</p>

<pre><code>- (void)alertViewCancel:(UIAlertView *)alertView;
</code></pre>

<p>// 开始显示View的动画之前进行回调</p>

<pre><code>- (void)willPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 显示动画完成之后进行回调</p>

<pre><code>- (void)didPresentAlertView:(UIAlertView *)alertView;  
</code></pre>

<p>// 将要开始View隐藏动画的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView willDismissWithButtonIndex:(NSInteger)buttonIndex; 
</code></pre>

<p>// 当View的隐藏动画结束的时候进行回调</p>

<pre><code>- (void)alertView:(UIAlertView *)alertView didDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 编辑任何默认的字段添加的风格之后调用</p>

<pre><code>- (BOOL)alertViewShouldEnableFirstOtherButton:(UIAlertView *)alertView;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIActionSheet详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/05/uiactionsheet/"/>
    <updated>2014-01-05T12:31:54+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/05/uiactionsheet</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p>目录</p>

<p>// 初始化UIActionSheet上的button按钮</p>

<pre><code>- (id)initWithTitle:(NSString *)title delegate:(id&lt;UIActionSheetDelegate&gt;)delegate cancelButtonTitle:(NSString *)cancelButtonTitle destructiveButtonTitle:(NSString *)destructiveButtonTitle otherButtonTitles:(NSString *)otherButtonTitles, ... ;
</code></pre>

<p>// 设置UIActionSheet代理</p>

<pre><code>id&lt;UIActionSheetDelegate&gt; delegate;    // weak reference
</code></pre>

<p>// 设置UIActionSheet的title</p>

<pre><code>NSString *title;
</code></pre>

<p>// 设置UIActionSheet的样式（默认为UIActionSheetStyleAutomatic）</p>

<pre><code>UIActionSheetStyle actionSheetStyle;
</code></pre>

<p>// 通过按钮的title获取这个按钮在UIActionSheet上的下标</p>

<pre><code>- (NSInteger)addButtonWithTitle:(NSString *)title;
</code></pre>

<p>// 通过下标获得按钮的title</p>

<pre><code>- (NSString *)buttonTitleAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 获取按钮的总个数(只读)</p>

<pre><code>NSInteger numberOfButtons;
</code></pre>

<p>// 获取取消按钮的下标</p>

<pre><code>NSInteger cancelButtonIndex;
</code></pre>

<p>// 红色按钮的下标（翻译成破坏性的，其实就是那个红色的按钮）</p>

<pre><code>NSInteger destructiveButtonIndex;
</code></pre>

<p>// 获取第一个其他按钮的下标(只读)</p>

<pre><code>NSInteger firstOtherButtonIndex;
</code></pre>

<p>// UIActionSheet是否可见（只读）</p>

<pre><code>BOOL visible;
</code></pre>

<p>// show a sheet animated. you can specify either a toolbar, a tab bar, a bar butto item or a plain view. We do a special animation if the sheet rises from
// a toolbar, tab bar or bar button item and we will automatically select the correct style based on the bar style. if not from a bar, we use
// UIActionSheetStyleDefault if automatic style set
// 如果要将ActonSheet 与工具栏或者标签栏对齐，可以使用showFromToolBar(showFromTabBar)</p>

<pre><code>- (void)showFromToolbar:(UIToolbar *)view;
- (void)showFromTabBar:(UITabBar *)view;
</code></pre>

<p>// showFromBarButtonItem，就是popover会指向个BarButtonItem。在iPhone上只能使用showInView，如果是universal app，要用些if来判断。用delegate来知道用户选择了什么</p>

<pre><code>- (void)showFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>// showFromRect，在ipad上指定个矩形区域，它会在其上显示个popover</p>

<pre><code>- (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated;
</code></pre>

<p>// 显示在iphone的中间位置，它会从下往上滑动；在ipad上它会放在中间，所以在ipad上从不用showInView</p>

<pre><code>- (void)showInView:(UIView *)view;
</code></pre>

<p>// hides alert sheet or popup. use this method when you need to explicitly dismiss the alert.
// it does not need to be called if the user presses on a button</p>

<pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre>

<p>UIActionSheetDelegate协议（可选）</p>

<p>// 点击UIActionSheet会调用的函数，buttonIndex为所点击button在UIActionSheet的下标</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet clickedButtonAtIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// 点击取消按钮会调用的函数</p>

<pre><code>- (void)actionSheetCancel:(UIActionSheet *)actionSheet;
</code></pre>

<p>// 将来显示ActionSheet</p>

<pre><code>- (void)willPresentActionSheet:(UIActionSheet *)actionSheet;
</code></pre>

<p>// 显示ActionSheet</p>

<pre><code>- (void)didPresentActionSheet:(UIActionSheet *)actionSheet;
</code></pre>

<p>// ActionSheet将要消失</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet willDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>

<p>// ActionSheet消失</p>

<pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITableViewCell详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uitableviewcell/"/>
    <updated>2014-01-04T12:31:43+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uitableviewcell</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p>// 初始化方法</p>

<pre><code>- (id)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier;
</code></pre>

<p>// cell上默认图片显示view，（默认为nil,当需要的时候才会被创建）</p>

<pre><code>UIImageView *imageView;
</code></pre>

<p>// cell上默认的UILabel(默认为nil，当需要的时候才会被创建)</p>

<pre><code>UILabel     *textLabel;
</code></pre>

<p>//  cell简介（默认为nil，如果当前的style支持的话需要时将会被创建）</p>

<pre><code>UILabel     *detailTextLabel;
</code></pre>

<p>// 与cell自带的删除按钮平级的view</p>

<pre><code>UIView *contentView;
</code></pre>

<p>// 背景view</p>

<pre><code>UIView *backgroundView;
</code></pre>

<p>// 多选时的背景view</p>

<pre><code>UIView *multipleSelectionBackgroundView;
</code></pre>

<p>// cell的标识符</p>

<pre><code>NSString *reuseIdentifier;
</code></pre>

<p>//  重用cell时会调用这个函数</p>

<pre><code>- (void)prepareForReuse; 
</code></pre>

<p>// 选中时的cell样式（默认为UITableViewCellSelectionStyleBlue）</p>

<pre><code>UITableViewCellSelectionStyle   selectionStyle; 
</code></pre>

<p>// 是否选中</p>

<pre><code>BOOL         selected; 
</code></pre>

<p>// 是否高亮</p>

<pre><code>BOOL      highlighted;
</code></pre>

<p>// 设置cell为选中状态</p>

<pre><code>- (void)setSelected:(BOOL)selected animated:(BOOL)animated;                  
</code></pre>

<p>// 设置为高亮状态</p>

<pre><code>- (void)setHighlighted:(BOOL)highlighted animated:(BOOL)animated;
</code></pre>

<p>// 设置cell的编辑样式</p>

<pre><code>UITableViewCellEditingStyle editingStyle;
</code></pre>

<p>// showsReorderControl = YES时Cell显示移动按钮（默认为NO）</p>

<pre><code>BOOL showsReorderControl;        // default is NO
</code></pre>

<p>// 没有出现delete控件和行头控件，可cell的宽度还是变了，有没有办法使cell在edit模式下，宽度不改变</p>

<pre><code>BOOL shouldIndentWhileEditing;
</code></pre>

<p>// 设置cell的样式</p>

<pre><code>UITableViewCellAccessoryType accessoryType;
</code></pre>

<p>UITableViewCellAccessoryNone;//cell没有任何的样式</p>

<p>UITableViewCellAccessoryDisclosureIndicator;//cell的右边有一个小箭头，距离右边有十几像素；</p>

<p>UITableViewCellAccessoryDetailDisclosureButton;//cell右边有一个蓝色的圆形button；</p>

<p>UITableViewCellAccessoryCheckmark;//cell右边的形状是对号；</p>

<p>// 除此上面之外，如果你想使用自定义附件按钮的其他样式，必需使用UITableView的accessoryView属性</p>

<pre><code>UIView *accessoryView;
</code></pre>

<p>// 设置当cell进入编辑模式时的辅助按钮样式</p>

<pre><code>UITableViewCellAccessoryType editingAccessoryType;
</code></pre>

<p>// 自定义cell进入编辑模式后辅助按钮</p>

<pre><code>UIView *editingAccessoryView;       
</code></pre>

<p>// 获取cell的缩进级别</p>

<pre><code>NSInteger indentationLevel;           
</code></pre>

<p>// 获取cell的缩进宽度</p>

<pre><code>CGFloat indentationWidth;
</code></pre>

<p>// 设置是否处于编辑模式</p>

<pre><code>BOOL           editing;
</code></pre>

<p>// 设置编辑模式</p>

<pre><code>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
</code></pre>

<p>// 当前是否显示delete按钮</p>

<pre><code>BOOL showingDeleteConfirmation;  // currently showing "Delete" button
</code></pre>

<p>// 这两个方法应该在子类中覆写，当前Cell的状态发生改变的时刻就会触发这些方法，可以在这些方法中进行一些额外的操作。（例如：cell被点击以后就会进入UITableViewCellStateShowingDeleteConfirmationMask 状态）</p>

<pre><code>- (void)willTransitionToState:(UITableViewCellStateMask)state;
- (void)didTransitionToState:(UITableViewCellStateMask)state;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UINavigaionBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uinavigaionbar/"/>
    <updated>2014-01-04T12:31:24+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uinavigaionbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<p><strong>1、UINavigaionBar</strong></p>

<p>// 设置bar的样式</p>

<pre><code>UIBarStyle barStyle;
</code></pre>

<p>// 设置代理</p>

<pre><code>id delegate;
</code></pre>

<p>// 设置是否透明（在iOS6中默认为NO,如果barStyle为UIBarStyleBlackTranslucent为YES）</p>

<pre><code>BOOL translucent;
</code></pre>

<p>// Pushing a navigation item displays the item&rsquo;s title in the center of the navigation bar.
// 方法将新的UINavigationItem 压入栈</p>

<pre><code>- (void)pushNavigationItem:(UINavigationItem *)item animated:(BOOL)animated;
</code></pre>

<p>//  方法将顶部的UINavigationItem 推出栈</p>

<pre><code>- (UINavigationItem *)popNavigationItemAnimated:(BOOL)animated; // Returns the item that was popped.
</code></pre>

<p>// 获取顶部的item（只读）</p>

<pre><code>UINavigationItem *topItem;
</code></pre>

<p>// 获取返回的item</p>

<pre><code>UINavigationItem *backItem;
</code></pre>

<p>// 设置items组</p>

<pre><code>NSArray *items;
- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 设置背景颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 设置背影颜色（iOS7.0新增）</p>

<pre><code>UIColor *barTintColor;
</code></pre>

<p>iOS5新增</p>

<p>//  根据屏幕状态设置背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarMetrics:(UIBarMetrics)barMetrics;

如果支持竖屏，那么应该设置UIBarMetricsDefault
[navBar setBackgroundImage:[UIImage imageNamed:@"navBarBg.png"] forBarMetrics:UIBarMetricsDefault];

如果支持横屏，那么应该设置UIBarMetricsLandscapePhone
[navBar setBackgroundImage:[UIImage imageNamed:@"navBarBg.png"] forBarMetrics:UIBarMetricsLandscapePhone];
</code></pre>

<p>// 根据屏幕状态获取背景图片</p>

<pre><code>- (UIImage *)backgroundImageForBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 对titleText设置字体属性</p>

<pre><code>NSDictionary *titleTextAttributes;
</code></pre>

<p>// 根据屏幕状态设置标题的垂直偏移量</p>

<pre><code>- (void)setTitleVerticalPositionAdjustment:(CGFloat)adjustment forBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 根据屏幕状态获得标题的垂直偏移量</p>

<pre><code>- (CGFloat)titleVerticalPositionAdjustmentForBarMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>iOS6新增</p>

<p>// 设置阴影图片</p>

<pre><code> UIImage *shadowImage;
</code></pre>

<p>iOS7新增</p>

<p>// iOS7下设置背景图片(iOS上默认是64，可以通过这个方法设置成44)。</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 获取图片</p>

<pre><code>- (UIImage *)backgroundImageForBarPosition:(UIBarPosition)barPosition barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>// 如果想要用自己的图片替换V型，可以设置图片的backIndicatorImage backIndicatorTransitionMaskImage。</p>

<pre><code>UIImage *backIndicatorImage;
UIImage *backIndicatorTransitionMaskImage;

如下代码所示：
[[UINavigationBar appearance] setBackIndicatorImage:[UIImage imageNamed:@"backBtton.png"]]; 
[[UINavigationBar appearance] setBackIndicatorTransitionMaskImage:[UIImage imageNamed:@"backBtton.png"]]; 
</code></pre>

<p>UINavigationBarDelegate协议（可选）
// 是否支持pushItem，如果返回NO就不能。</p>

<pre><code>- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPushItem:(UINavigationItem *)item;
</code></pre>

<p>// pushItem时会调用的函数</p>

<pre><code>- (void)navigationBar:(UINavigationBar *)navigationBar didPushItem:(UINavigationItem *)item;
</code></pre>

<p>// 是否支持popItem，如果返回NO就不能。</p>

<pre><code>- (BOOL)navigationBar:(UINavigationBar *)navigationBar shouldPopItem:(UINavigationItem *)item;
</code></pre>

<p>// popItem时会调用的函数</p>

<pre><code>- (void)navigationBar:(UINavigationBar *)navigationBar didPopItem:(UINavigationItem *)item;
</code></pre>

<p><strong>2、UINavigationItem </strong></p>

<p>// 初始化item的title</p>

<pre><code>- (id)initWithTitle:(NSString *)title;
</code></pre>

<p>// 设置item的title</p>

<pre><code>NSString        *title; 
</code></pre>

<p>// 设置返回barButtonItem</p>

<pre><code>UIBarButtonItem *backBarButtonItem;
</code></pre>

<p>// 设置titleView</p>

<pre><code>UIView          *titleView;
</code></pre>

<p>// 一个显示在顶部导航栏的单行文本</p>

<pre><code>NSString *prompt;    
</code></pre>

<p>// 是否隐藏返回按钮</p>

<pre><code>BOOL hidesBackButton; 
</code></pre>

<p>// 隐藏返回按钮</p>

<pre><code>- (void)setHidesBackButton:(BOOL)hidesBackButton animated:(BOOL)animated;
</code></pre>

<p>// 设置左边按钮</p>

<pre><code>UIBarButtonItem *leftBarButtonItem;
- (void)setLeftBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>// 设置右边按钮</p>

<pre><code>UIBarButtonItem *rightBarButtonItem;
- (void)setRightBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated;
</code></pre>

<p>iOS5新增</p>

<pre><code>NSArray *leftBarButtonItems;
NSArray *rightBarButtonItems;
- (void)setLeftBarButtonItems:(NSArray *)items animated:(BOOL)animated; 
- (void)setRightBarButtonItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 当某个UIViewController自定义了LeftBarButtonItem(如：返回首页的Home按钮)，同时这个UIViewController存在被其他UIViewController，pushViewController(即：从其他试图控制器，跳转到自定义LeftBarButtonItem的试图控制器),这时如果没有在自定义LeftBarButtonItem设置UINavigationItem的属性leftItemsSupplementBackButton，那么系统会默认为NO，那麽其他控制器跳转到此控制器时，导航栏就只会展示你自定的LeftBarButtonItem，而不会显示后退按钮。但这样很不友好。如果想显示后退按钮，这在自定义LeftBarButtonItem时，设置UINavigationItem的属性leftItemsSupplementBackButton为YES即可。</p>

<pre><code>BOOL leftItemsSupplementBackButton;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIToolBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uitoolbar/"/>
    <updated>2014-01-03T12:31:14+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uitoolbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UIToolBar的基本属性及方法
2、iOS5.0新增
3、iOS6.0新增
4、iOS7.0新增
5、UIToolbar协议
</code></pre>

<p><strong>1、UIToolBar的基本属性及方法</strong></p>

<p>// UIToolBar的样式 （默认为blue）</p>

<pre><code>UIBarStyle barStyle;
</code></pre>

<p>// 设置tooBar的选项</p>

<pre><code>NSArray   *items;
</code></pre>

<p>// 设置上面的一层view是否半透明</p>

<pre><code>BOOL translucent;
</code></pre>

<p>//</p>

<pre><code>- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 背景颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>2、iOS5.0新增</p>

<p>// 背景图片设置</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>//</p>

<pre><code>- (UIImage *)backgroundImageForToolbarPosition:(UIBarPosition)topOrBottom barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>3、iOS6.0新增</p>

<p>// 设置ToolBar上边沿的阴影</p>

<pre><code>- (void)setShadowImage:(UIImage *)shadowImage forToolbarPosition:(UIBarPosition)topOrBottom;
- (UIImage *)shadowImageForToolbarPosition:(UIBarPosition)topOrBottom;
</code></pre>

<p>4、iOS7.0新增</p>

<p>// 设置背景颜色</p>

<pre><code>UIColor *barTintColor;
</code></pre>

<p>// 设置代理</p>

<pre><code>id&lt;UIToolbarDelegate&gt; delegate;
</code></pre>

<p><strong>5、UIToolbar协议</strong></p>

<p>目前还没有协议</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UITabBar详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uitabbar/"/>
    <updated>2014-01-03T12:31:06+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uitabbar</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UITabBar作为一个标签栏控制，它本身继承于UIView,也就是说UITabBar本身是一个视图控件。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UITabBar基本属性及方法
2、iOS5.0新增
3、iOS6.0新增
4、iOS7.0新增
5、UITabBarDelegate协议（可选）
</code></pre>

<p><strong>1、UITabBar基本属性及方法</strong></p>

<p>// 设置UITabBar的代理</p>

<pre><code>id&lt;UITabBarDelegate&gt; delegate;
</code></pre>

<p>//  设置UITabBar的选项值</p>

<pre><code>NSArray  *items;
</code></pre>

<p>//  设置UITabBar选中的item</p>

<pre><code>UITabBarItem *selectedItem; 
</code></pre>

<p>// 是否动画添加item（冒似没有效果）</p>

<pre><code>- (void)setItems:(NSArray *)items animated:(BOOL)animated;
</code></pre>

<p>// 定制化items</p>

<pre><code>- (void)beginCustomizingItems:(NSArray *)items;
</code></pre>

<p>// 结束定制化动画</p>

<pre><code>- (BOOL)endCustomizingAnimated:(BOOL)animated;
</code></pre>

<p>// 是否定制化</p>

<pre><code>- (BOOL)isCustomizing;
</code></pre>

<p><strong>2、iOS5.0新增</strong></p>

<p>// 改变UITabBar的着色(直接通过back背景颜色)</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 选中时背景颜色</p>

<pre><code>UIColor *selectedImageTintColor;
</code></pre>

<p>// 背景图片</p>

<pre><code>UIImage *backgroundImage;
</code></pre>

<p>// 选中的item的背景图片</p>

<pre><code>UIImage *selectionIndicatorImage; 
</code></pre>

<p><strong>3、iOS6.0新增</strong></p>

<pre><code>UIImage *shadowImage;
</code></pre>

<p><strong>4、iOS7.0新增 </strong></p>

<pre><code>UIColor *barTintColor;

UITabBarItemPositioning itemPositioning;

CGFloat itemWidth;


CGFloat itemSpacing;

UIBarStyle barStyle;

BOOL translucent;
</code></pre>

<p><strong>5、UITabBarDelegate协议（可选）</strong></p>

<pre><code>- (void)tabBar:(UITabBar *)tabBar didSelectItem:(UITabBarItem *)item;

- (void)tabBar:(UITabBar *)tabBar willBeginCustomizingItems:(NSArray *)items; 

- (void)tabBar:(UITabBar *)tabBar didBeginCustomizingItems:(NSArray *)items;
- (void)tabBar:(UITabBar *)tabBar willEndCustomizingItems:(NSArray *)items changed:(BOOL)changed;

- (void)tabBar:(UITabBar *)tabBar didEndCustomizingItems:(NSArray *)items changed:(BOOL)changed;  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIImageView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uiimageview/"/>
    <updated>2014-01-03T12:30:58+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uiimageview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、基本属性
2、动画图片相关
3、iOS7新增
</code></pre>

<!--more-->


<p><strong>1、基本属性</strong></p>

<p>// 初始化UIImageView展示的图片资源</p>

<pre><code>- (id)initWithImage:(UIImage *)image;
</code></pre>

<p>// 初始化UIImageView默认和选中时展示的图片资源</p>

<pre><code>- (id)initWithImage:(UIImage *)image highlightedImage:(UIImage *)highlightedImage;
</code></pre>

<p>// UIImageView的图片资源</p>

<pre><code>UIImage *image;
</code></pre>

<p>// UIImageView选中之后的图片资源</p>

<pre><code>UIImage *highlightedImage;
</code></pre>

<p>// 是否允许用户交互 （默认为NO）</p>

<pre><code>BOOL userInteractionEnabled;
</code></pre>

<p>// 是否选中 （默认为NO）</p>

<pre><code>BOOL highlighted;
</code></pre>

<p><strong>2、动画图片相关</strong></p>

<p>// UIImageView 动画播放的图片组资源（必须是UIImage,如果设置了单一的image，那么这个为nil）</p>

<pre><code>NSArray *animationImages;
</code></pre>

<p>// 选中时UIImageView 动画播放的图片组资源（同上）</p>

<pre><code>NSArray *highlightedAnimationImages;
</code></pre>

<p>// 图片播放的时间间隔</p>

<pre><code>NSTimeInterval animationDuration;
</code></pre>

<p>// 图片重复播放次数（默认为0，为表示一直重复播放）</p>

<pre><code>NSInteger      animationRepeatCount;
</code></pre>

<p>// 播放图片</p>

<pre><code>- (void)startAnimating;
</code></pre>

<p>// 停止播放</p>

<pre><code>- (void)stopAnimating;
</code></pre>

<p>// 是否正在播放</p>

<pre><code>- (BOOL)isAnimating;
</code></pre>

<p><strong>3、iOS7新增</strong></p>

<pre><code>UIColor *tintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIActivityIndicatorView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/03/uiactivityindicatorview/"/>
    <updated>2014-01-03T12:30:48+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/03/uiactivityindicatorview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、UIActivityIndicatorView基本属性及方法
2、iOS5.0新增
</code></pre>

<!--more-->


<p><strong>1、UIActivityIndicatorView基本属性及方法</strong></p>

<p>// 初始化样式</p>

<pre><code>- (id)initWithActivityIndicatorStyle:(UIActivityIndicatorViewStyle)style;
</code></pre>

<p>// 设置样式（默认为UIActivityIndicatorViewStyleWhite）</p>

<pre><code>UIActivityIndicatorViewStyle activityIndicatorViewStyle;
</code></pre>

<p>// 停止时是否隐藏</p>

<pre><code>BOOL hidesWhenStopped;
</code></pre>

<p>// 开始播放动画</p>

<pre><code>- (void)startAnimating;
</code></pre>

<p>// 停止播放动画</p>

<pre><code>- (void)stopAnimating;
</code></pre>

<p>// 是否正在播放动画</p>

<pre><code>- (BOOL)isAnimating;
</code></pre>

<p><strong>2、iOS5.0新增</strong></p>

<p>// 设置圈圈的颜色</p>

<pre><code>UIColor *color;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIProgressView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/02/uiprogressview/"/>
    <updated>2014-01-02T12:28:03+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/02/uiprogressview</id>
    <content type="html"><![CDATA[<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增内容
</code></pre>

<!--more-->


<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化progressView的样式</p>

<pre><code>- (id)initWithProgressViewStyle:(UIProgressViewStyle)style; 
</code></pre>

<p>// progressView的样式（默认为UIProgressViewStyleDefault）</p>

<pre><code>UIProgressViewStyle progressViewStyle;
</code></pre>

<p>// 进度（范围为0-1）</p>

<pre><code>float progress; 
</code></pre>

<p><strong>2、iOS5新增内容</strong></p>

<p>// 进度填充部分的颜色(譬如进度到40%,那么40%部分的颜色就是这个属性)</p>

<pre><code>UIColor* progressTintColor;
</code></pre>

<p>// 未填充部分的颜色</p>

<pre><code>UIColor* trackTintColor ;
</code></pre>

<p>// 进度填充部分的图片，如progressTintColor</p>

<pre><code>UIImage* progressImage;
</code></pre>

<p>// 未填充部分的图片，如trackTintColor</p>

<pre><code>UIImage* trackImage;
</code></pre>

<p>// 设置progress的进度</p>

<pre><code>- (void)setProgress:(float)progress animated:(BOOL)animated;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UILabel详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/02/uilabel/"/>
    <updated>2014-01-02T09:57:41+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/02/uilabel</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2014/01/06/uilabel.png" alt="image" /></p>

<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、属性
2、方法
</code></pre>

<p><strong>1、属性</strong></p>

<p>// UILabel显示内容</p>

<pre><code>NSString           *text;
</code></pre>

<p>// 文字字体(默认为系统字体，大小17)</p>

<pre><code>UIFont             *font;
</code></pre>

<p>// 字体颜色</p>

<pre><code>UIColor            *textColor;
</code></pre>

<p>// 阴影颜色（默认没有阴影）</p>

<pre><code>UIColor            *shadowColor;
</code></pre>

<p>// 阴影大小（默认为（0，-1））</p>

<pre><code>CGSize             shadowOffset; 
</code></pre>

<p>// 文字对齐模式（默认是居左）</p>

<pre><code>NSTextAlignment    textAlignment;
</code></pre>

<p>//  设置单词折行方式（默认NSLineBreakByTruncatingTail）</p>

<pre><code> NSLineBreakMode    lineBreakMode; 
</code></pre>

<p>// 文字显示属性(iOS6.0)</p>

<pre><code>NSAttributedString *attributedText;
</code></pre>

<p>// 文字高亮时的颜色</p>

<pre><code>UIColor *highlightedTextColor; 
</code></pre>

<p>// 是否支持高亮（默认为NO）</p>

<pre><code>BOOL     highlighted;          // default is NO
</code></pre>

<p>// 是否允许接收触摸事件(默认为NO)</p>

<pre><code>BOOL userInteractionEnabled;  // default is NO
</code></pre>

<p>// 文本是否可变(默认YES)</p>

<pre><code>BOOL enabled;                 // default is YES. changes how the label is drawn
</code></pre>

<p>// 设置label可以显示多少行(0表示多行，默认为1)</p>

<pre><code>NSInteger numberOfLines;
</code></pre>

<p>// 文本文字是否自适应大小(默认为NO)</p>

<pre><code>BOOL adjustsFontSizeToFitWidth;         // default is NO
</code></pre>

<p>//</p>

<pre><code>BOOL adjustsLetterSpacingToFitWidth NS_DEPRECATED_IOS(6_0,7_0); // deprecated - hand tune by using NSKernAttributeName to affect tracking
</code></pre>

<p>// 最小字体，行数为1时有效（默认为0.0 iOS2.0 &ndash; iOS6.0）</p>

<pre><code>CGFloat minimumFontSize;
</code></pre>

<p>// 控制文本的基线位置，只有文本行数为1是有效（默认为UIBaselineAdjustmentAlignBaselines）</p>

<pre><code>UIBaselineAdjustment baselineAdjustment;
//有三种方式
typedef enum {
    UIBaselineAdjustmentAlignBaselines = 0, 默认值文本最上端于label中线对齐
    UIBaselineAdjustmentAlignCenters,//文本中线于label中线对齐
    UIBaselineAdjustmentNone,//文本最低端与label中线对齐
} UIBaselineAdjustment;
</code></pre>

<p>// 设置最小字体,与minimumFontSize相同（iOS6.0）</p>

<pre><code>CGFloat minimumScaleFactor; 
</code></pre>

<p>// 优先选择标签布局的最大宽度(iOS 6.0)</p>

<pre><code>CGFloat preferredMaxLayoutWidth;    
</code></pre>

<p><strong>2、方法</strong></p>

<p>// 不可直接调用,需要子类重载,第二参数为0时没有行数限制</p>

<pre><code>- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines;
</code></pre>

<p>// 不可直接调用,需要子类重载</p>

<pre><code>- (void)drawTextInRect:(CGRect)rect;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[视图鼻祖之UIView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/01/uiview/"/>
    <updated>2014-01-01T21:04:48+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/01/uiview</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2014/01/04/uiview.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p>UIView表示屏幕上的一块矩形区域，它在App中占有绝对重要的地位，因为iOS中几乎所有可视化控件都是UIView的子类。负责渲染区域的内容，并且响应该区域内发生的触摸事件</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、UIView家族
2、UIView的基本属性
3、几何方法类
4、控制级别类
5、渲染类
6、动画类
7、手势类
8、移动效果类
9、基于布局约束类(iOS6.0)
10、基于布局的约束core方法(iOS 6.0)
11、基于约束的兼容性（iOS 6.0）
12、层次布局的约束（iOS 6.0）
13、设备大小布局约束(iOS 6.0)
14、布局调度(iOS 6.0)
15、状态恢复(iOS 6.0)
16、快照 （iOS7.0）
</code></pre>

<p><strong>1、UIView家族</strong></p>

<p>下图就是视图的内层次</p>

<p><img src="http://beyondabel.github.io/images/2014/01/04/uiviewStructure.png" alt="image" /></p>

<p><strong>2、UIView的基本属性</strong></p>

<pre><code>BOOL userInteractionEnabled;  // UIView是否接受events事件，默认为YES
NSInteger tag;                // 用于做标识所用，默认为0
CALayer  *layer;              // Core Animation layer有关，在常用方法中再详细讲解

CGRect            frame;    // UIView在父视图中的位置

CGRect            bounds;  // UIView相对自己的位置
CGPoint           center;      // UIView的中心点. animatable
CGAffineTransform transform;   // 线性代数里面讲的矩阵变换，这个是恒等变换,一般用来旋转，缩放
CGFloat contentScaleFactor;修改contentScaleFactor可以让UIView的渲染精度提高，这样即使在CGAffineTransform放大之后仍然能保持锐利。

BOOL multipleTouchEnabled;   // 是否允许多点触摸
BOOL       exclusiveTouch;         // default is NO
UIColor   backgroundColor;  // UIView的背影颜色
BOOL hidden;  // UIView是否隐藏
CGFloat  alpha; // 为0时完全透明，为1时完全不透明。

BOOL clipsToBounds; //在类的层次结构中，如果clipsTobounds设为YES,超出superView的部分subview就不会显示，否则会做显示， 默认情况下是NO。

BOOL opaque;   //这是一个优化属性，如果该值为YES, 那么绘图在绘制该视图的时候把整个视图当作不透明对待。这样，绘图系统在执行绘图过程中会优化一些操作并提升系统性能；如果是设置为NO, 绘图系统将其和其他内容平等对待，不去做优化操作。为了性能方面的考量，默认被置为YES(意味着‘优化’)。

UIView  *superview;// 父视图
NSArray *subviews;// 子视图
</code></pre>

<p>注：*frame和center都是相对于父视图的，bounds是相对于自身的。当view完全透明和隐藏时不能响应事件。</p>

<p>*opaque和alpha 是有关系的。 一个不透明视图需要整个边界里面的内容都是不透明的。基于这个原因，opaque设置为YES，要求对应的alpha必须为1.0。如果一个UIView实例opaque被设置为YES, 而同时它又没有完全填充它的边界(bounds),或者它包含了整个或部分的透明的内容视图，那么将会导致未知的结果。
因此，如果视图部分或全部支持透明，那么你必须把opaque这个值设置为NO.</p>

<p><strong>3、几何方法类</strong></p>

<pre><code>// hitTest主要用途是用来寻找那个视图是被触摸了
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;   
// 如果我们不想让某个视图响应事件，让此方法返回NO就行了。默认为YES
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;
</code></pre>

<p>举个例子，建立一个TestView里面重载hitTest和pointInside方法：</p>

<pre><code>- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    [super hitTest:point withEvent:event];
    return self;
}  

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    NSLog(@"view pointInside");
    return YES;
}  
</code></pre>

<p>然后在TestView中增加一个子视图TestSecondView也重载这两个方法</p>

<pre><code>- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    [super hitTest:point withEvent:event]; 
    return self;  
}  

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    NSLog(@"second view pointInside");
    return YES; 
}  
</code></pre>

<p>这里注意[super hitTest:point withEvent:event];必须要包括，否则hitTest无法调用父类的方法，这样就没法 使用PointInside:withEvent:进行判断，那么就没法进行子视图的遍历。当去掉这个语句的时候，触摸事件就不可能进到子视图中了，除非你在方法中直接返回子视图的对象。这样你在调试的过程中就会发现，每次你点击一个view都会先进入到这个view的父视图中的hitTest方法，然后 调用super的hitTest方法之后就会查找pointInside是否返回YES如果是，则就把消息传递个子视图处理，子视图用同样的方法递归查找 自己的子视图。所以从这里调试分析看，hitTest方法这种递归调用的方式就一目了然了。</p>

<pre><code>// 将像素point由point所在视图转换到目标视图view中，返回在目标视图view中的像素值
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView *)view;
// 将像素point从view中转换到当前视图中，返回在当前视图中的像素值
- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;

// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect
- (CGRect)convertRect:(CGRect)rect toView:(UIView *)view;
// 将rect从view中转换到当前视图中，返回在当前视图中的rect
- (CGRect)convertRect:(CGRect)rect fromView:(UIView *)view;
</code></pre>

<p><strong>4、控制级别类</strong></p>

<pre><code>// 把视图从父类移除
- (void)removeFromSuperview;
// 添加子视图到某个位置
- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;
// 更改子视图的位置
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;

// 添加子视图
- (void)addSubview:(UIView *)view;
// 把view放在siblingSubview下面
- (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview;
// 把view放在siblingSubview上面
- (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview;
</code></pre>

<p>注：1、addSubview:和insertSubview: atIndex:的区别：</p>

<pre><code>  [view addSubView:oneView] == [view insertSubview:oneView atIndex:view.subviews.cout];

// 将view显示在最前面（要将一个view显示在最前面，只要调用其父视图的bringSubviewToFront：方法）
- (void)bringSubviewToFront:(UIView *)view;
// 将view推送到背后
- (void)sendSubviewToBack:(UIView *)view;
// 当加入视图完成后调用  
- (void)didAddSubview:(UIView *)subview;
// 将移除子视图会调用
- (void)willRemoveSubview:(UIView *)subview;

// 通知即将移动到新的父视图中
- (void)willMoveToSuperview:(UIView *)newSuperview;
// 通知已经到新父视图
- (void)didMoveToSuperview;
// 通知即将已移动到新的窗口
- (void)willMoveToWindow:(UIWindow *)newWindow;
// 通知已经移动新的窗口
- (void)didMoveToWindow;

// 判断一个视图是否在父视图层中
- (BOOL)isDescendantOfView:(UIView *)view;  // returns YES for self.
// 获取标记的子视图
- (UIView *)viewWithTag:(NSInteger)tag;     // recursive search. includes self

// Allows you to perform layout before the drawing cycle happens. -layoutIfNeeded forces layout early
// 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，
// 但layoutSubviews一定会被调用
- (void)setNeedsLayout;
// 如果有需要刷新的标记，立即调用layoutSubviews进行布局
//（如果没有标记，不会调用layoutSubviews）
- (void)layoutIfNeeded;

// 重新布局
- (void)layoutSubviews; 
</code></pre>

<p><strong>5、渲染类</strong></p>

<pre><code>// 重写此方法，执行重绘
- (void)drawRect:(CGRect)rect;

// 标记为需要重绘，异步调用drawRect
- (void)setNeedsDisplay;
// 标记为需要局部重绘
- (void)setNeedsDisplayInRect:(CGRect)rect;
</code></pre>

<p>注：drawRect是对receiver的重绘。setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘</p>

<p><strong>6、动画类</strong></p>

<pre><code>// 开始一个动画
+ (void)beginAnimations:(NSString *)animationID context:(void *)context; 
// 执行动画,类似数据库的事务处理
+ (void)commitAnimations; 
// 设置动画代理，默认为nil
+ (void)setAnimationDelegate:(id)delegate; 

// 当动画执行开始时，执行selector方法，默认为NULL
+ (void)setAnimationWillStartSelector:(SEL)selector;
// 当动画执行结束时，执行selector方法
+ (void)setAnimationDidStopSelector:(SEL)selector; 

// 设置动画时间，时间参数为double类型，默认0.2
+ (void)setAnimationDuration:(NSTimeInterval)duration;
// 设置动画延迟时间
+ (void)setAnimationDelay:(NSTimeInterval)delay;  
// 设置在动画块内部动画内部动画属性改变的开始时间
+ (void)setAnimationStartDate:(NSDate *)startDate;
// 设置动画的旋转曲度变化，默认为UIViewAnimationCurveEaseInOut
//值定义在UIViewAnimationCurve结构体中。
//typedef NS_ENUM(NSInteger, UIViewAnimationCurve) { //动画曲线
    // slow at beginning and end 缓慢开始，中间加速，然后减速到结束
//  UIViewAnimationCurveEaseInOut,   
    // slow at beginning  缓慢开始，加速到结束     
//  UIViewAnimationCurveEaseIn,    
    // slow at end  加速开始，加速到结束        
//  UIViewAnimationCurveEaseOut, 
    //正常速度          
//  UIViewAnimationCurveLinear  
//};
+ (void)setAnimationCurve:(UIViewAnimationCurve)curve; 

// 设置动画在动画模块中的重复次数
+ (void)setAnimationRepeatCount:(float)repeatCount;                 
// 设置动画块中的动画效果是否自动重复播放
+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses;    
// 设置动画是否从当前状态开始播放，默认为NO. 
+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState;  

// 在动画设置过渡效果
+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache;

transition
把一个过渡效果应用到视图中。值定义在UIViewAnimationTransition结构体中。
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone, 没有过渡
    UIViewAnimationTransitionFlipFromLeft,  翻转视图从左到右
    UIViewAnimationTransitionFlipFromRight, 翻转视图从右到左
    UIViewAnimationTransitionCurlUp, 从上卷动
    UIViewAnimationTransitionCurlDown, 从下卷动
};
view
    需要过渡的视图对象。

cache
如果是YES，那么在开始和结束图片视图渲染一次并在动画中创建帧；否则，视图将会在每一帧都渲染。例如缓存，你不需要在视图转变中不停的更新，你只需要等到转换完成再去更新视图。
1、开始一个动画块。
2、在容器视图中设置转换。
3、在容器视图中移除子视图。
4、在容器视图中添加子视图。
5、结束动画块。

// 设置是否开启动画，默认YES,开启
+ (void)setAnimationsEnabled:(BOOL)enabled;
// 验证动画是否开启，YES开启，NO关闭
+ (BOOL)areAnimationsEnabled;               
// iOS7之后替代 setAnimationsEnabled
+ (void)performWithoutAnimation:(void (^)(void))actionsWithoutAnimation;

// iOS4.0之后
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;

动画效果处理块，多参数
</code></pre>

<p>(NSTimeInterval)duration :动画时间</p>

<p>(NSTimeInterval)delay:延迟时间
(UIViewAnimationOptions)options 动画参数</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, UIViewAnimationOptions) {
    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt;  0,
    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt;  1, // turn on user interaction while animating
    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt;  2, // start all views from current value, not initial value
    UIViewAnimationOptionRepeat                    = 1 &lt;&lt;  3, // repeat animation indefinitely
    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt;  4, // if repeat, run animation back and forth
    UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt;  5, // ignore nested duration
    UIViewAnimationOptionOverrideInheritedCurve    = 1 &lt;&lt;  6, // ignore nested curve
    UIViewAnimationOptionAllowAnimatedContent      = 1 &lt;&lt;  7, // animate contents (applies to transitions only)
    UIViewAnimationOptionShowHideTransitionViews   = 1 &lt;&lt;  8, // flip to/from hidden state instead of adding/removing

    UIViewAnimationOptionCurveEaseInOut            = 0 &lt;&lt; 16, // default
    UIViewAnimationOptionCurveEaseIn               = 1 &lt;&lt; 16,
    UIViewAnimationOptionCurveEaseOut              = 2 &lt;&lt; 16,
    UIViewAnimationOptionCurveLinear               = 3 &lt;&lt; 16,

    UIViewAnimationOptionTransitionNone            = 0 &lt;&lt; 20, // default
    UIViewAnimationOptionTransitionFlipFromLeft    = 1 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromRight   = 2 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCurlUp          = 3 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCurlDown        = 4 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCrossDissolve   = 5 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromTop     = 6 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromBottom  = 7 &lt;&lt; 20,
} NS_ENUM_AVAILABLE_IOS(4_0);
</code></pre>

<p>(void))animations :动画效果块</p>

<p>可以设置属性如下：frame\bounds\center\transform\alpha\backgroundColor\contentStretch</p>

<p>completion:(void (^)(BOOL finished))completion
动画结束块</p>

<p>例：</p>

<pre><code>[UIView animateWithDuration: 2.00 delay:3.00 options:UIViewAnimationOptionAllowAnimatedContent
                 animations:^{
                         insertDemoTwo.alpha = 0.1;
                         insertDemoOne.alpha = 1.0;
                                        }
                 completion:^(BOOL finished) {
                     [UIView animateWithDuration:3.00
                                      animations:^{
                                          insertDemoTwo.center = CGPointMake(500.0, 470.0);
                                          insertDemoOne.center = CGPointMake(140.0, 100.0);
                                      }
                      ];


                 }

 ];


// 动画效果处理（无延迟，无参数）iOS4.0之后，默认delay = 0.0,options = 0;
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;
</code></pre>

<p>例：</p>

<pre><code>[UIView animateWithDuration:3.00
                 animations:^{
                     insertDemoOne.alpha = 1.0;
                     insertDemoTwo.alpha = 0.1;
                 }
                 completion:^(BOOL finished) {
                     insertDemoTwo.center = CGPointMake(500.0, 470.0);
                     insertDemoOne.center = CGPointMake(140.0, 100.0);                    
                     }
 ];

//动画效果处理简单版 iOS4.0之后（delay = 0.0,options = 0,completion = NULL）
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations;

+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

// 过渡动画效果块，iOS4.0
+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;
</code></pre>

<p>例：</p>

<pre><code>[UIView transitionWithView:insertDemoOne duration: 1.0 options:UIViewAnimationOptionTransitionFlipFromLeft
                                     animations:^{
                                         [insertDemoTwo removeFromSuperview];
                                         [insertDemoOne addSubview:insertDemoTwo];
                                     }
                                     completion:^(BOOL finished) {
                                         insertDemoOne.backgroundColor = [UIColor brownColor];
                                     }];

// 视图之间切换的过渡动画效果块，iOS4
+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion;


+ (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray *)views options:(UIViewAnimationOptions)options animations:(void (^)(void))parallelAnimations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);
</code></pre>

<p><strong>7、手势类</strong></p>

<p>// 手势识别器（iOS3.2）
@property(nonatomic,copy) NSArray *gestureRecognizers;</p>

<pre><code>UIKit 中UIGestureRecognizer类的子类系列如下：
UITapGestureRecognizer – “轻击”手势。可以配置为“单击”和“连击”的识别。
UIPinchGestureRecognizer –“捏合”手势。该手势通常用于缩放视图或改变可视组件的大小。
UIPanGestureRecognizer – “平移”手势。识别拖拽或移动动作。
UISwipeGestureRecognizer – “轻扫”手势。当用户从屏幕上划过时识别为该手势。可以指定该动作的方向（上、下、左、右）。
UIRotationGestureRecognizer – “转动”手势。用户两指在屏幕上做相对环形运动。
UILongPressGestureRecognizer – “长按”手势。使用1指或多指触摸屏幕并保持一定时间。
</code></pre>

<p>// 绑定手势到视图（iOS3.2）</p>

<pre><code>- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer; 
</code></pre>

<p>//从视图中移除手势 (iOS3.2)</p>

<pre><code>- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer;
</code></pre>

<p>//手势识别处理方式在gesture recognizer视图转出《UIGestureRecognizerStatePossible》状态时调用，如果返回NO,则转换到《UIGestureRecognizerStateFailed》;如果返回YES,则继续识别触摸序列.(默认情况下为YES)。(iOS6.0)</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
</code></pre>

<p><strong>8、移动效果类</strong></p>

<ul>
<li>(void)addMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);</li>
</ul>


<p>/*! Stops applying <code>effect</code> to the receiver. Any affected presentation values will animate to</p>

<pre><code>their post-removal values using the present UIView animation context. */
</code></pre>

<ul>
<li>(void)removeMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);</li>
</ul>


<p><strong>9、基于布局约束类(iOS6.0)</strong></p>

<p>// 视图布局约束</p>

<pre><code>- (NSArray *)constraints;
</code></pre>

<p>// 视图布局上添加一个约束</p>

<pre><code>- (void)addConstraint:(NSLayoutConstraint *)constraint;
</code></pre>

<p>// 视图布局上添加多个约束</p>

<pre><code>- (void)addConstraints:(NSArray *)constraints;
</code></pre>

<p>// 移除视力布局上的一个约束</p>

<pre><code>- (void)removeConstraint:(NSLayoutConstraint *)constraint;
</code></pre>

<p>// 移除视图布局上的多个约束</p>

<pre><code>- (void)removeConstraints:(NSArray *)constraints;
</code></pre>

<p><strong>10、基于布局的约束core方法(iOS 6.0)</strong></p>

<p>// 调用新的视图布局自动触发，更新视图布局上的约束</p>

<pre><code>- (void)updateConstraintsIfNeeded;
</code></pre>

<p>// 更新自定义视图布局约束</p>

<pre><code>- (void)updateConstraints; 
</code></pre>

<p>// 判断视图布局是否需要更新约束</p>

<pre><code>- (BOOL)needsUpdateConstraints;
</code></pre>

<p>// 设置视图布局是否需要更新约束</p>

<pre><code>- (void)setNeedsUpdateConstraints;
</code></pre>

<p><strong>11、基于约束的兼容性（iOS 6.0）</strong></p>

<p>// 标示是否自动遵循视图布局约束，默认为YES</p>

<pre><code>- (BOOL)translatesAutoresizingMaskIntoConstraints; 
</code></pre>

<p>// 设置是否自动遵循视图布局约束</p>

<pre><code>- (void)setTranslatesAutoresizingMaskIntoConstraints:(BOOL)flag;
</code></pre>

<p>// 返回是遵循自定义视图布局约束</p>

<pre><code>+ (BOOL)requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);
</code></pre>

<p><strong>12、层次布局的约束（iOS 6.0）</strong></p>

<p>// 返回矩形对于指定视图框架</p>

<pre><code>- (CGRect)alignmentRectForFrame:(CGRect)frame;
</code></pre>

<p>// 返回框架对于指定视图矩形</p>

<pre><code>- (CGRect)frameForAlignmentRect:(CGRect)alignmentRect;
</code></pre>

<p>// 返回自定义视图大小</p>

<pre><code>- (UIEdgeInsets)alignmentRectInsets;
</code></pre>

<p>// 如果超出约束范围，自动生成基线限制，以满足视图需求</p>

<pre><code>- (UIView *)viewForBaselineLayout;
</code></pre>

<p>// 返回放大的视图布局轴线</p>

<pre><code>- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 设置放大的视图布局的轴线</p>

<pre><code>- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 返回缩小的视图布局的轴线</p>

<pre><code>- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 设置缩小的视图布局轴线</p>

<pre><code>- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p><strong>13、设备大小布局约束(iOS 6.0)</strong></p>

<p>// 满足约束视图布局的大小</p>

<pre><code>- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize;
</code></pre>

<p><strong>14、布局调度(iOS 6.0)</strong></p>

<p>// 返回影响视图布局限制的轴线</p>

<pre><code>- (NSArray *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 返回视图布局约束是否影响指定视图，主要用于调试约束布局，结合exerciseAmbiguityInLayout。</p>

<pre><code>- (BOOL)hasAmbiguousLayout;
</code></pre>

<p>// 随机改变不同效值布局视图，主要用于调试基于约束布局的视图</p>

<pre><code>- (void)exerciseAmbiguityInLayout; 
</code></pre>

<p><strong>15、状态恢复(iOS 6.0)</strong></p>

<p>// 标志是否支持保存，恢复视图状态信息</p>

<pre><code>@property (nonatomic, copy) NSString *restorationIdentifier;
</code></pre>

<p>// 保存视图状态相关信息</p>

<pre><code>- (void) encodeRestorableStateWithCoder:(NSCoder *)coder;
</code></pre>

<p>// 恢复和保存视图相关信息</p>

<pre><code>- (void) decodeRestorableStateWithCoder:(NSCoder *)coder; 
</code></pre>

<p><strong>16、快照 （iOS7.0）</strong></p>

<p>我们有时候可能需要取UIView对象的快照，有几个原因，您可能希望从动画性能改进上去分享您的应用程序的屏幕截图。现有的方法面临几个问题：</p>

<pre><code>1代码不简单
2复杂的渲染选项，比如层面罩的难再生
3OpenGL层需要特殊的事例代码
4快照处理十分慢
</code></pre>

<p>事实上,真的没有任何通用的“快照”代码可以应付所有可能的场景。
但是IOS7将会改变，UIView和UIScreen会有一些新的方法，为各种用例提供简单的快照功能。</p>

<p>动画快照
我们可能经常想对一个视图进行动画处理，但是视图的动画太复杂，要么是动画太密集，要么就是需要额外的代码来控制正确的行为。
例如附带的项目，我们创建一个UIView的子类，它只是简单的添加一些子视图，并旋转来生成一个有趣的几何排列。</p>

<p>// 调用snapshotViewAfterScreenUpdates：方法去创建复杂视图的快照。方法返回一个UIView，来呈现被调用的视图的界面。用这个方法去获取视图快照非常有效，比制作位图要快的多。
当获得视图快照后，我们把它添加到容器视图上，并移除实际的复杂视图。然后可以动画处理快照视图了：</p>

<pre><code>- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;

- (UIView *)resizableSnapshotViewFromRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates withCapInsets:(UIEdgeInsets)capInsets;
- (BOOL)drawViewHierarchyInRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[利用Octopress在Github搭建一个博客]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/26/octopress/"/>
    <updated>2013-12-26T23:59:57+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/26/octopress</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/26/OctopressAndGithub.png" alt="image" /></p>

<p><strong>引言</strong></p>

<p><a href="http://http://octopress.org/">Octopress</a>是利用<a href="http://http://github.com/mojombo/jekyll">Jekyll</a>博客引擎开发的一个博客系统，生成的静态页面能够很好的在<em>github page</em>上展现。号称是hacker专属的一个博客系统(A blogging framework for hackers.)<!--more--></p>

<p>从自己开始使用Octopress搭建博客到正在写博客，中间差不多花了我三个星期，在这三个星期中，我走了很多的弯路，使用Octopress搭建博客的错误我相信我已经遇到80～90%了，所以想写一篇使用Octopress在Github上怎么搭建博客，一来为了与其他人分享，令想利用Octopress搭建博客的人少走一些弯路，另一方面也是自己对这方面的知识一个积累，首先我说一下我的在mac系统环境下搭建的，本文需要读者熟悉一些shell命令，并掌握基本的git操作。</p>

<p><strong>目录</strong></p>

<pre><code>1、搭建环境
2、安装Octopress
3、配置Octopress
4、将博客部署到GitHub上
5、开始写博客
</code></pre>

<p><strong>1、搭建环境</strong></p>

<p>Octopress需要Ruby环境，RVM(Ruby Version Manager)负责安装和管理Ruby的环境。所以我们先在终端输入如下命令，来安装RVM：</p>

<pre><code>1、curl -L https://get.rvm.io | bash -s stable --ruby
</code></pre>

<p>先查看Ruby的版本号，在终端依次运行如下命令：</p>

<pre><code>ruby -v
</code></pre>

<p>如果ruby的版本号大于1.9.3，那么就不用安装了，如果小于1.9.3那就需要安装Ruby</p>

<p>接着是安装<code>Ruby 2.0.0</code>,在终端依次运行如下命令：</p>

<pre><code>1、rvm install 1.9.3
2、rvm use 1.9.3
3、rvm rubygems latest
</code></pre>

<p>完成上面的操作之后，运行ruby &mdash;v应该可以看到ruby 2.0.0环境已经安装好了。</p>

<p>参考：<code>Installing Ruby With RVM</code></p>

<p>在安装Octopress时还需要make命令，所以还会用到command_line_tools，所以还需要下载Xcode，打开Xcode,到Xcode->preferences->Downloads，里面有一个command_line_tools点击下载。</p>

<p>2、安装Octopress</p>

<p>在安装Octopress之前，请确保你的电脑上已经安装有git了，在终端输入git &mdash;version，如果安装了可以看到电脑中的git版本(一般情况下，mac系统现在都已经自带git了)，如果没有显示相关内容，请先安装git。</p>

<p>git安装之后，利用git命令将<code>octopress</code>从<code>github上clone</code>到本机，如下命令：</p>

<pre><code>1、git clone git://github.com/imathis/octopress.git octopress
2、cd octopress    # If you use RVM, You'll be asked if you trust the .rvmrc file (say yes).
</code></pre>

<p>接着安装相关依赖项：</p>

<pre><code>1、gem install bundler
3、bundle install
</code></pre>

<p>最后安装默认的<code>Octopress</code>主题。</p>

<pre><code>1、rake install
</code></pre>

<p>如果执行<code>rake install</code>报如下错误：<code>You have already activated rake 0.9.6, but your Gemfile requires rake 0.9.2.2. Using bundle exec may solve this.</code></p>

<p>解决办法：打开<code>Gemfile</code>文件，把<code>gem 'rake', '~&gt; 0.9.0'</code>修改成<code>gem 'rake', '~&gt; 0.9.6'</code></p>

<p>参考： <code>Octopress Setup</code></p>

<p><strong>3、配置Octopress</strong></p>

<p><code>Octopress</code>的作者已经尽量让配置简化了。大多数情况下只需要配置<code>_config.yml</code>和<code>Rakefile</code>文件即可。其中Rakefile是跟博客部署相关，一般情况下并不需要修改这个文件，除非使用了<code>rsync</code>。</p>

<p><code>config.yml</code>是博客重要的一个配置文件，在<code>config.yml</code>文件中有三大配置项：<code>Main Configs</code>、<code>Jekyll &amp; Plugins</code>和<code>3rd Party Settings</code>。</p>

<p>一般，该文件中其中<code>url</code>是必须要填写的，这里的<code>url</code>是在<code>github</code>上创建的一个仓库地址，具体请看第四步中创建的地址。另外再修改一下<code>title</code>、<code>subtitle</code>和<code>author</code>，根据需求，在开启一些第三方组件服务。</p>

<pre><code>url: beyondabel.github.io     #网站地址 
title: abel之家               #网站标题 
subtitle: 天行健，君子以自强不息.地势坤，君子以厚德载物.     #网站副标题 
author: abel                      #网站作者，通常显示在页尾和每篇文章的尾部 
simple_search: http://google.com/search   # 搜索引擎 
description:             #网站的描述，出现在HTML页面中的 meta 中的 description
</code></pre>

<p>更多内容，请看这里的内容：<a href="http://octopress.org/docs/configuring/">Configuring Octopress</a></p>

<p><strong>4、将博客部署到GitHub上</strong></p>

<p><code>Github</code>的<code>Page service</code>可以免费托管博客，并且还可以自定义域名。</p>

<p>首先需要在GitHub上创建一个仓库，并将仓库名称按照这样的方式进行命名：<code>username.github.com</code>或<code>organization.github.com</code>。等后面配置完毕之后，我们就可以在浏览器中使用页面地址<code>http://username.github.com</code>来访问我们的博客。一般来说，我们希望在将博客的源码放到source分支下，并把生成的内容提交到master分支。</p>

<p>创建好仓库之后，我们需要利用octopress的一个配置rake任务来自动配置上面创建的仓库：可以让我们方便的部署<code>GitHub page</code>。在终端输入如下命令：</p>

<pre><code>1、$ rake setup_github_pages
</code></pre>

<p>上面的命令会做一些事情(详细介绍看下面给出的参考链接)。其中最主要的就是创建一个_deploy目录，目录用来存放部署到master分支的内容。期间会要求你输入仓库的url，根据提示，进行输入即可。
完成上面的命令之后，我们就可以生成博客并真正的部署到仓库中了。执行如下命令：</p>

<pre><code>1、rake generate
2、rake deploy
</code></pre>

<p>上面的命令首先生成博客文件，并将生成的博客文件拷贝到<code>_deploy/</code>目录下，然后将这些内容添加到git中，并commit和push到仓库的master分支。</p>

<p>现在可以访问<code>http://username.github.io</code>了。注意：有时候可能会有延时，要等几分钟才能打开。
至此，我们的博客已经完成基本的部署。</p>

<p>如果在部署到仓库之前，需要先预览一下博客，可以在终端输入<code>rake preview</code>命令，然后就能在浏览器中进行本地预览访问了：<code>http://127.0.0.1:4000/</code>或<code>http://localhost:4000/</code>，效果跟仓库中的一样。
参考：<code>Deploying to Github Pages</code></p>

<p>如果本地访问时出现了404错误，请关注一下你生成的文件是否直接在public目录下，如果不在，请修改一下<code>config.rb</code>文件，使<code>http_path = "/"</code>。如果访问<code>http://username.github.com</code>上出现了404错误，看一下你的<code>repositories</code>是否有内容，如果有，请你再次确认你的<code>repositories</code>的名称是否是<code>username.github.io</code>,如果不是，那么请用<code>http://username.github.io/[your repositories name]</code>，如果还是不行，请关注一下，你的账号是否使用邮箱激活了，如果没有，请先激活，然后删除这个<code>repositories</code>重新再来。</p>

<p><strong>5、开始写博客</strong></p>

<p><code>Octopress</code>为我们提供了一些task来创建博文和页面。博文必须存储在<code>source/_posts</code>目录下，并且需要按照Jekyll的命名规范对文章进行命名：<code>YYYY-MM-DD-post-title.markdown</code>。文章的名字会被当做url的一部分，而其中的日期用于对博文的区分和排序。</p>

<p>通过<code>Octopress</code>提供的<code>task</code>可以正确的按照命名规范创建一个博文，并且在博文中会附带常用的一些yaml元数据。只需要在终端输入如下命令：</p>

<pre><code>1、rake new_post["title"]
</code></pre>

<p>其中<code>title</code>为博文的文件名，创建出来的文件默认是<code>markdown</code>格式。上面的命令会创建出这样一个文件：<code>source/_posts/2013-08-03-title.markdown</code>。打开这个文件，可以看到里面有如下一些内容了(告诉Jekyll博客引擎如何处理博文和页面)：</p>

<pre><code>---
layout: post
title: "title"
date: 2013-12-26 16:36
comments: true
categories: 
---
</code></pre>

<p>接着我们就可以在这个文件中写我们的博文啦。完成之后，我们可以预览和部署博文。下面是创建并部署博文的一个完整过程：</p>

<pre><code>1、$ rake new_post["New Post"]
2、$ rake generate
3、$ rake deploy
</code></pre>

<p>参考：<a href="http://octopress.org/docs/blogging/">Blogging Basics</a></p>

<p>到此，我们使用Octopress在Github上博客就搭建好了，这中间如果遇到什么问题，可以给我留言。接下来，我将带给大家如何更换博客样式，如何添加评论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS时间相关各种技巧]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/24/ios-time/"/>
    <updated>2013-12-24T22:33:47+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/24/ios-time</id>
    <content type="html"><![CDATA[<p><strong>一、通过自带的日历得到年月日、时间、以及星期</strong></p>

<!--more-->


<pre><code>NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];
NSDate *now;
NSDateComponents *comps = [[NSDateComponents alloc] init];
NSInteger unitFlags = NSYearCalendarUnit | NSMonthCalendarUnit | NSDayCalendarUnit | NSWeekdayCalendarUnit | 
                                     NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;
now=[NSDate date];
comps = [calendar components:unitFlags fromDate:now];
week = [comps weekday];    
month = [comps month];
day = [comps day];
hour = [comps hour];
min = [comps minute];
sec = [comps second];
</code></pre>

<p><strong>二、世界标准时间UTC /GMT 转为当前系统时区对应的时间</strong></p>

<pre><code>- (NSDate *)getNowDateFromatAnDate:(NSDate *)anyDate
{
    //设置源日期时区
    NSTimeZone* sourceTimeZone = [NSTimeZone timeZoneWithAbbreviation:@"UTC"];//或GMT
    //设置转换后的目标日期时区
    NSTimeZone* destinationTimeZone = [NSTimeZone localTimeZone];
    //得到源日期与世界标准时间的偏移量
    NSInteger sourceGMTOffset = [sourceTimeZone secondsFromGMTForDate:anyDate];
    //目标日期与本地时区的偏移量
    NSInteger destinationGMTOffset = [destinationTimeZone secondsFromGMTForDate:anyDate];
    //得到时间偏移量的差值
    NSTimeInterval interval = destinationGMTOffset - sourceGMTOffset;
    //转为现在时间
    NSDate* destinationDateNow = [[[NSDate alloc] initWithTimeInterval:interval sinceDate:anyDate] autorelease];
    return destinationDateNow;
}
</code></pre>

<p><strong>三、NSString格式转化为NSDate</strong></p>

<pre><code>- (NSDate *)stringToDate:(NSString *)strdate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatteralloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];// NSString的时间格式
    NSDate *retdate = [dateFormatter dateFromString:strdate];
    [dateFormatter release];
    return retdate;
}
</code></pre>

<p><strong>四、NSDate转化为NSString</strong></p>

<pre><code>- (NSString *)dateToString:(NSDate *)date
{
    NSDateFormatter *dateFormatter = [[NSDateFormatteralloc] init];
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSString *strDate = [dateFormatter stringFromDate:date];
    [dateFormatter release];
    return strDate;
}
</code></pre>

<p><strong>五、将本地日期字符串转为UTC日期字符串</strong></p>

<pre><code>//本地日期格式:2013-08-03 12:53:51
//可自行指定输入输出格式
-(NSString *)getUTCFormateLocalDate:(NSString *)localDate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //输入格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];

    NSDate *dateFormatted = [dateFormatter dateFromString:localDate];
    NSTimeZone *timeZone = [NSTimeZone timeZoneWithName:@"UTC"];
    [dateFormatter setTimeZone:timeZone];
    //输出格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    NSString *dateString = [dateFormatter stringFromDate:dateFormatted];
    [dateFormatter release];
    return dateString;
}
</code></pre>

<p><strong>六、将UTC日期字符串转为本地时间字符串</strong></p>

<pre><code>//输入的UTC日期格式2013-08-03T04:53:51+0000
-(NSString *)getLocalDateFormateUTCDate:(NSString *)utcDate
{
    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
    //输入格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd'T'HH:mm:ssZ"];
    NSTimeZone *localTimeZone = [NSTimeZone localTimeZone];
    [dateFormatter setTimeZone:localTimeZone];

    NSDate *dateFormatted = [dateFormatter dateFromString:utcDate];
    //输出格式
    [dateFormatter setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
    NSString *dateString = [dateFormatter stringFromDate:dateFormatted];
    [dateFormatter release];
    return dateString;
}
</code></pre>

<p><strong>七、iOS开发之格式化日期时间</strong></p>

<p>字符说明</p>

<p>(:)时间分隔符。在某些区域设置中，可以使用其他字符表示时间分隔符。时间分隔符在格式化时间值时分隔小时、分钟和秒。格式化输出中用作时间分隔符的实际字符由您的应用程序的当前区域性值确定。</p>

<p>(/)日期分隔符。在某些区域设置中，可以使用其他字符表示日期分隔符。日期分隔符在格式化日期值时分隔日、月和年。格式化输出中用作日期分隔符的实际字符由您的应用程序的当前区域性确定。</p>

<p>(%)用于表明不论尾随什么字母，随后字符都应该以单字母格式读取。也用于表明单字母格式应以用户定义格式读取。有关更多详细信息，请参见下面的内容。</p>

<p>D将日显示为不带前导零的数字（如 1）。如果这是用户定义的数字格式中的唯一字符，请使用 %D。</p>

<p>DD将日显示为带前导零的数字（如 01）。</p>

<p>EEE将日显示为缩写形式（例如 SUN）。</p>

<p>EEEE将日显示为全名（例如 SUNDAY）。</p>

<p>M将月份显示为不带前导零的数字（如一月表示为 1）。如果这是用户定义的数字格式中的唯一字符，请使用 %M。</p>

<p>MM将月份显示为带前导零的数字（例如 01/12/01）。</p>

<p>MMM将月份显示为缩写形式（例如 JAN）。</p>

<p>MMMM将月份显示为完整月份名（例如 JANUARY）。</p>

<p>GG显示时代/纪元字符串（例如 A.D.）</p>

<p>H使用 12 小时制将小时显示为不带前导零的数字（例如 1:15:15 PM）。如果这是用户定义的数字格式中的唯一字符，请使用 %H。</p>

<p>HH使用 12 小时制将小时显示为带前导零的数字（例如 01:15:15 PM）。</p>

<p>H使用 24 小时制将小时显示为不带前导零的数字（例如 1:15:15）。如果这是用户定义的数字格式中的唯一字符，请使用 %H。</p>

<p>HH使用 24 小时制将小时显示为带前导零的数字（例如 01:15:15）。</p>

<p>M将分钟显示为不带前导零的数字（例如 12:1:15）。如果这是用户定义的数字格式中的唯一字符，请使用 %M。</p>

<p>MM将分钟显示为带前导零的数字（例如 12:01:15）。</p>

<p>S将秒显示为不带前导零的数字（例如 12:15:5）。如果这是用户定义的数字格式中的唯一字符，请使用 %S。</p>

<p>SS将秒显示为带前导零的数字（例如 12:15:05）。</p>

<p>F显示秒的小数部分。例如，FF 将精确显示到百分之一秒，而 FFFF 将精确显示到万分之一秒。用户定义格式中最多可使用七个 F 符号。如果这是用户定义的数字格式中的唯一字符，请使用 %F。</p>

<p>T使用 12 小时制，并对中午之前的任一小时显示大写的 A，对中午到 11:59 P.M 之间的任一小时显示大写的 P。如果这是用户定义的数字格式中的唯一字符，请使用 %T。</p>

<p>TT对于使用 12 小时制的区域设置，对中午之前任一小时显示大写的 AM，对中午到 11:59 P.M 之间的任一小时显示大写的 PM。对于使用 24 小时制的区域设置，不显示任何字符。</p>

<p>Y将年份 (0-9) 显示为不带前导零的数字。如果这是用户定义的数字格式中的唯一字符，请使用 %Y。</p>

<p>YY以带前导零的两位数字格式显示年份（如果适用）。</p>

<p>YYY以四位数字格式显示年份。</p>

<p>YYYY以四位数字格式显示年份。</p>

<p>Z显示不带前导零的时区偏移量（如 -8）。如果这是用户定义的数字格式中的唯一字符，请使用 %Z。</p>

<p>ZZ显示带前导零的时区偏移量（例如 -08）</p>

<p>ZZZ显示完整的时区偏移量（例如 -08:00）</p>

<p>格式显示</p>

<pre><code>M/D/YY    12/7/58
D-MMM    7-DEC
D-MMMM-YY     7-DECEMBER-58
D MMMM      7 DECEMBER
MMMM YY    DECEMBER 58
HH:MM TT     08:50 PM
H:MM:SS T     8:50:35 P
H:MM    20:50
H:MM:SS    20:50:35
M/D/YYYY H:MM     12/7/1958 20:50   
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的博客搬家啦～]]></title>
    <link href="http://beyondabel.github.io/blog/2013/12/01/my-new-blog/"/>
    <updated>2013-12-01T23:37:45+08:00</updated>
    <id>http://beyondabel.github.io/blog/2013/12/01/my-new-blog</id>
    <content type="html"><![CDATA[<p><img src="http://beyondabel.github.io/images/2013/12/01/my-new-blog.png" alt="image" /></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;我是一个非常喜欢折腾的程序猿，之前我一直在CSDN上写博文，但由于一些种种的原因，后来放弃了CSDN,之后一直都有搭建个人站点的想法,在网上搜索了如何搭建个人站点,网上有很多的人建议用Octopress+Github,转而开始用Octopress搭建博客<!--more-->，从开始弄Octopress到成功在Github上发布博文已经差不多一个月了，虽然网上有太多关于得用Octopress搭建Github博客的博文，但对于一个小白的我使用Octopress搭建Github博客过程的坚苦也只有自己知道，所以在下一篇博文中我将会记录我使用Octopress搭建Github博客的点点滴滴。</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;搭建博客的主要原因一是可以与大家分享交流，二是可以总结一下自己。
使用Octopress+Github与CSDN、百度、新郎、博客园相比，它更自由，可以自定义自己的时尚元素，有一些我非常喜欢的style.如果想使用Octopress+Github搭建博客，将会经历如下步骤：</p>

<p>1.首先，注册一个github账号。</p>

<p>2.配置环境</p>

<p>3.下载Octopress包</p>

<p>4.配置Octopress</p>

<p>5.绑定Github账号</p>

<p>6.把Octopress提交到Github</p>

<p>如果想用域名可以访问的话，还需要经历如下的步骤：</p>

<p>7.域名注册</p>

<p>8.购买虚拟主机</p>

<p>9.域名与虚拟主机中的IP进行绑定。</p>

<p>到此，博客就基本搭建好了～</p>
]]></content>
  </entry>
  
</feed>
