<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UIView及子类控件 | Abel's Den]]></title>
  <link href="http://beyondabel.github.io/blog/categories/uiviewji-zi-lei-kong-jian/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2014-03-10T10:35:10+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISwitch详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/11/uiswitch/"/>
    <updated>2014-01-11T12:34:31+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/11/uiswitch</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISwitch继承于UIControl（有关UIControl请参照<a href="/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）,您可以使用UISwitch类来创建和管理使用开/关按钮。例如，在对选项，如飞行模式和蓝牙设置应用程序。这些对象被称为交换机。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS5新增
3、iOS6新增
</code></pre>

<p><strong>1、基本属性及方法</strong>
// 开关是否打开</p>

<pre><code>BOOL on;
</code></pre>

<p>// 这个frame会被忽略，他会强制设置大小</p>

<pre><code>- (id)initWithFrame:(CGRect)frame;
</code></pre>

<p>// 打开/关闭调用函数(animated：是否使用动画)</p>

<pre><code>- (void)setOn:(BOOL)on animated:(BOOL)animated;
</code></pre>

<p><strong>2、iOS5新增</strong></p>

<p>// 开关打开时颜色</p>

<pre><code>UIColor *onTintColor;
</code></pre>

<p><strong>3、iOS6新增</strong>
// 背影颜色</p>

<pre><code>UIColor *tintColor;
</code></pre>

<p>// 开关的圆形滑钮的颜色</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 开关打开时自定义图片</p>

<pre><code>UIImage *onImage;
</code></pre>

<p>// 开关关闭时自定义图片</p>

<pre><code>UIImage *offImage;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISlider详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/11/uislider/"/>
    <updated>2014-01-11T12:34:24+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/11/uislider</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISlider继承于UIControl（有关UIControl请参照<a href="/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。UISlider对象是用来从一个连续的数值范围内选择单个值的可视化控制。滑块总是显示为水平条形图。一个指标，注意到滑块的当前值，并且可以由用户进行移动来改变该设置。</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、设置初始值
2、改变UISlider的外观
3、供子类重写的方法
</code></pre>

<p><strong>1、设置初始值</strong></p>

<p>// 指定初始值</p>

<pre><code>float value;
</code></pre>

<p>// 指定可变最小值</p>

<pre><code>float minimumValue;
</code></pre>

<p>// 指定可变最大值</p>

<pre><code>float maximumValue;
</code></pre>

<p><strong>2、改变UISlider的外观</strong></p>

<p>//  设置滑轮左边图片</p>

<pre><code>UIImage *minimumValueImage;
</code></pre>

<p>// 设置滑轮右边图片</p>

<pre><code>UIImage *maximumValueImage;
</code></pre>

<p>//  （默认YES）</p>

<pre><code>BOOL continuous;
</code></pre>

<p>//  滑轮左边颜色如果设置了左边的图片就不会显示（iOS 5.0）</p>

<pre><code>UIColor *minimumTrackTintColor;
</code></pre>

<p>// 滑轮右边颜色如果设置了右边的图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *maximumTrackTintColor;
</code></pre>

<p>// 设置了滑轮的颜色如果设置了滑轮的样式图片就不会显示(iOS 5.0)</p>

<pre><code>UIColor *thumbTintColor;
</code></pre>

<p>// 动态设置滑动值</p>

<pre><code>- (void)setValue:(float)value animated:(BOOL)animated;
</code></pre>

<p>// 定制自己的滑块图片</p>

<pre><code>- (void)setThumbImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置左边的图片</p>

<pre><code>- (void)setMinimumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>// 设置右边的图片</p>

<pre><code>- (void)setMaximumTrackImage:(UIImage *)image forState:(UIControlState)state;
</code></pre>

<p>//  根据状态返回滑动图片</p>

<pre><code>- (UIImage *)thumbImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态左边的图片</p>

<pre><code>- (UIImage *)minimumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 根据状态右边的图片</p>

<pre><code>- (UIImage *)maximumTrackImageForState:(UIControlState)state;
</code></pre>

<p>// 当前的滑动图片（只读）</p>

<pre><code>UIImage* currentThumbImage;
</code></pre>

<p>// 当前左边的图片（只读）</p>

<pre><code>UIImage* currentMinimumTrackImage;
</code></pre>

<p>// 当前右边的图片（只读）</p>

<pre><code>UIImage* currentMaximumTrackImage;
</code></pre>

<p><strong>3、供子类重写的方法</strong></p>

<p>// 以下四种方法用于子类覆盖,用来自定义thumb、track的CGRect</p>

<pre><code>- (CGRect)minimumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)maximumValueImageRectForBounds:(CGRect)bounds;
- (CGRect)trackRectForBounds:(CGRect)bounds;
- (CGRect)thumbRectForBounds:(CGRect)bounds trackRect:(CGRect)rect value:(float)value;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UISegmentedControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/10/uisegmentedcontrol/"/>
    <updated>2014-01-10T12:34:00+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/10/uisegmentedcontrol</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UISegmentedControl对象是一个水平控制使多个区段，每个区段用作离散的按钮。分段控件提供了一次小型的手段组合在一起的一些控制。</p>

<p>UISegmentedControl继承于UIControl（有关UIControl请参照<a href="/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）.</p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、基本属性及方法
2、iOS 5.0新增
</code></pre>

<p><strong>1、基本属性及方法</strong></p>

<p>// 初始化UISegmentedControl（items可以是NSString类型或者UIImages）</p>

<pre><code>- (id)initWithItems:(NSArray *)items;
</code></pre>

<p>//设置样式 （该样式只在ios2.0~7.0有效果）</p>

<pre><code>UISegmentedControlStyle segmentedControlStyle;
</code></pre>

<p>//设置在点击后是否恢复原样（默认是NO）</p>

<pre><code>BOOL momentary;
</code></pre>

<p>// 设置总选项数</p>

<pre><code>NSUInteger numberOfSegments;
</code></pre>

<p>//是否根据segment的内容改变segment的宽度 (只使用ios5.0，默认为NO)</p>

<pre><code>BOOL apportionsSegmentWidthsByContent;
</code></pre>

<p>//在指定的索引插入一个选项并设置题目</p>

<pre><code>- (void)insertSegmentWithTitle:(NSString *)title atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//在指定的索引插入一个选项并设置图片</p>

<pre><code>- (void)insertSegmentWithImage:(UIImage *)image  atIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除指定索引的选项</p>

<pre><code>- (void)removeSegmentAtIndex:(NSUInteger)segment animated:(BOOL)animated;
</code></pre>

<p>//移除所有的选项</p>

<pre><code>- (void)removeAllSegments;
</code></pre>

<p>//设置指定索引题目</p>

<pre><code>- (void)setTitle:(NSString *)title forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的标题</p>

<pre><code>- (NSString *)titleForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引的图片</p>

<pre><code>- (void)setImage:(UIImage *)image forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的图片</p>

<pre><code>- (UIImage *)imageForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项的宽度（默认是0）</p>

<pre><code>- (void)setWidth:(CGFloat)width forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取指定索引选项的宽度</p>

<pre><code>- (CGFloat)widthForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置选项中图片等的左上角的位置</p>

<pre><code>- (void)setContentOffset:(CGSize)offset forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//获取选项中图片等的左上角的位置</p>

<pre><code>- (CGSize)contentOffsetForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置指定索引选项不可选</p>

<pre><code>- (void)setEnabled:(BOOL)enabled forSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//判断指定索引选项是否可选</p>

<pre><code>- (BOOL)isEnabledForSegmentAtIndex:(NSUInteger)segment;
</code></pre>

<p>//设置默认选项索引</p>

<pre><code>NSInteger selectedSegmentIndex; 
</code></pre>

<p>//设置UISegmentedControl的颜色</p>

<pre><code>UIColor *tintColor; 
</code></pre>

<p><strong>2、iOS 5.0新增</strong></p>

<p>//设置在某个状态下的背景图片</p>

<pre><code>- (void)setBackgroundImage:(UIImage *)backgroundImage forState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics;
</code></pre>

<p>//获取在某个状态下的背景图片</p>

<pre><code>- (UIImage *)backgroundImageForState:(UIControlState)state barMetrics:(UIBarMetrics)barMetrics   
</code></pre>

<p>//设置分割线背景图片</p>

<pre><code>- (void)setDividerImage:(UIImage *)dividerImage forLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMetCT
</code></pre>

<p>//获取分割线背景图片</p>

<pre><code>- (UIImage *)dividerImageForLeftSegmentState:(UIControlState)leftState rightSegmentState:(UIControlState)rightState barMetrics:(UIBarMetrics)barMeE 
</code></pre>

<p>//设置文字显示样式</p>

<pre><code>- (void)setTitleTextAttributes:(NSDictionary *)attributes forState:(UIControlState)state;
</code></pre>

<p>//获取文字显示样式</p>

<pre><code>- (NSDictionary *)titleTextAttributesForState:(UIControlState)state;
</code></pre>

<p>//设置选项中内容的调整位置</p>

<pre><code>- (void)setContentPositionAdjustment:(UIOffset)adjustment forSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics; 
</code></pre>

<p>//获取选项中内容的调整位置</p>

<pre><code>- (UIOffset)contentPositionAdjustmentForSegmentType:(UISegmentedControlSegment)leftCenterRightOrAlone barMetrics:(UIBarMetrics)barMetrics;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIPageControl详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/09/uipagecontrol/"/>
    <updated>2014-01-09T12:33:46+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/09/uipagecontrol</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>UIPageControl继承于UIControl（有关UIControl请参照<a href="/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。您可以使用UIPageControl类来创建和管理页面控件。一个页面控件显示一个水平一系列的点，每个对应一个页面应用程序的文档（或其他数据模型实体）中。当前浏览的页面是由一个白色的圆点表示。</p>

<p>当用户点击一个页面控件移动到下一页或上一页，控制处理由委托发送UIControlEventValueChanged事件。然后委托可以评估当前属性来确定要显示的页面。网页控制在任何一个方向前进只有一个页面。</p>

<!--more-->


<h3>目录</h3>

<p>&mdash;-1、基本属性及方法
2、iOS6.0新增</p>

<h3>1、基本属性及方法</h3>

<p>// 指定页面个数（默认为0）</p>

<pre><code>NSInteger numberOfPages;
</code></pre>

<p>// 当前选中的页面（默认为0，范围为0 ～ numberOfPages-1）</p>

<pre><code>NSInteger currentPage;
</code></pre>

<p>// 如果在numberOfPages为1的情况下隐藏指示器，可以将hideForSinglePage的值设为YES。默认情况下，即使只有一个页面，指示器也会显示进来。</p>

<pre><code>BOOL hidesForSinglePage;
</code></pre>

<p>// 如果你希望直到有时间执行完你的操作之后，才更新当前指示器当前指示页，可以将 defersCurrentPageDisPlay 设为YES。这样的话你必须调用控件的 updateCurentPageDisPlay 来更新当前页</p>

<pre><code>BOOL defersCurrentPageDisplay;
</code></pre>

<p>// 更新当前页</p>

<pre><code>- (void)updateCurrentPageDisplay;
</code></pre>

<p>// 返回接受者的边界大小，与容纳被给的页面数有关</p>

<pre><code>- (CGSize)sizeForNumberOfPages:(NSInteger)pageCount;
</code></pre>

<h3>2、iOS6.0新增</h3>

<p>// 未选中的点的颜色</p>

<pre><code>UIColor *pageIndicatorTintColor;
</code></pre>

<p>// 当前点颜色</p>

<pre><code>UIColor *currentPageIndicatorTintColor;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS组件之UIDatePicker详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/09/uidatepicker/"/>
    <updated>2014-01-09T12:33:27+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/09/uidatepicker</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>该的UIDatePicker类实现使用多个车轮转动，以允许用户选择日期和时间的对象。UIDatePicker iPhone的例子是定时器和时钟应用程序的闹钟（设置闹钟）窗格。您也可以使用日期选择器作为一个倒数计时器。</p>

<p>如果配置正确，一个的UIDatePicker对象发送一个动作消息，当一个用户完成旋转的轮子之一更改日期或时间，相关的控制事件是UIControlEventValueChanged 。一个的UIDatePicker对象呈现倒数计时，但没有实现它，应用程序必须设立的NSTimer对象，并为他们倒计数更新秒。</p>

<p>UIDatePicker不是从UIPickerView的继承，而是继承于UIControl（有关UIControl请参照<a href="/blog/2014/01/06/uicontrol/">《iOS组件之UIControl详解》</a>）。，但它管理的自定义选择器视图对象作为一个子视图。</p>

<!--more-->


<pre><code>typedef enum {
    //根据区域设置,显示小时,分钟,并指定AM/PM(例如:6|53|PM)
    UIDatePickerModeTime,
    //根据区域设置,显示月,日,年(例如:November|15|2007)
    UIDatePickerModeDate, 
    //根据区域设置,显示日期(星期,月,日),小时,分钟,并指定AM/PM(例如:Wed Nov 15|6|53|PM)
    UIDatePickerModeDateAndTime,
    //显示小时,分钟(例如:1|53)  
    UIDatePickerModeCountDownTimer
} UIDatePickerMode;
</code></pre>

<p>// 设置UIDatePicker的显示模式(默认为UIDatePickerModeDateAndTime)</p>

<pre><code>UIDatePickerMode datePickerMode; 
</code></pre>

<p>//设置为语言显示</p>

<pre><code>NSLocale   *locale;   
</code></pre>

<p>// 设置日历</p>

<pre><code>NSCalendar *calendar;
</code></pre>

<p>// 设置时区</p>

<pre><code>NSTimeZone *timeZone; 
</code></pre>

<p>// 设置当前显示时间</p>

<pre><code>NSDate *date;
</code></pre>

<p>//如果animated为YES,时间轮会自动显示新的时间</p>

<pre><code>- (void)setDate:(NSDate *)date animated:(BOOL)animated;        
</code></pre>

<p>// 设置显示最小时间</p>

<pre><code>NSDate *minimumDate;
</code></pre>

<p>// 设置显示最大时间（此处为当前时间）</p>

<pre><code>NSDate *maximumDate;
</code></pre>

<p>//用于UIDatePickerModeCountDownTimer,否则忽略.默认为0.0.最大限制为23:59 (86,399秒)</p>

<pre><code>NSTimeInterval countDownDuration;
</code></pre>

<p>//设置分钟之间的间隔.间隔必须均匀的分为60.默认为1.最小为1,最大为30</p>

<pre><code>NSInteger      minuteInterval;
</code></pre>
]]></content>
  </entry>
  
</feed>
