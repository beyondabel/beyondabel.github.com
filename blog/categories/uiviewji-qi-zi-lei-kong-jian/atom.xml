<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: UIView及其子类控件 | Abel之家]]></title>
  <link href="http://beyondabel.github.io/blog/categories/uiviewji-qi-zi-lei-kong-jian/atom.xml" rel="self"/>
  <link href="http://beyondabel.github.io/"/>
  <updated>2014-01-06T11:24:52+08:00</updated>
  <id>http://beyondabel.github.io/</id>
  <author>
    <name><![CDATA[Abel]]></name>
    <email><![CDATA[abel_tu@163.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS组件之UILabel详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/06/uilabel/"/>
    <updated>2014-01-06T09:57:41+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/06/uilabel</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/01/06/uilabel.png" alt="image" /></p>

<p><strong>引言</strong></p>

<!--more-->


<p><strong>目录</strong></p>

<pre><code>1、属性
2、方法
</code></pre>

<p><strong>1、属性</strong></p>

<p>// UILabel显示内容</p>

<pre><code>NSString           *text;
</code></pre>

<p>// 文字字体(默认为系统字体，大小17)</p>

<pre><code>UIFont             *font;
</code></pre>

<p>// 字体颜色</p>

<pre><code>UIColor            *textColor;
</code></pre>

<p>// 阴影颜色（默认没有阴影）</p>

<pre><code>UIColor            *shadowColor;
</code></pre>

<p>// 阴影大小（默认为（0，-1））</p>

<pre><code>CGSize             shadowOffset; 
</code></pre>

<p>// 文字对齐模式（默认是居左）</p>

<pre><code>NSTextAlignment    textAlignment;
</code></pre>

<p>//  设置单词折行方式（默认NSLineBreakByTruncatingTail）</p>

<pre><code> NSLineBreakMode    lineBreakMode; 
</code></pre>

<p>// 文字显示属性(iOS6.0)</p>

<pre><code>NSAttributedString *attributedText;
</code></pre>

<p>// 文字高亮时的颜色</p>

<pre><code>UIColor *highlightedTextColor; 
</code></pre>

<p>// 是否支持高亮（默认为NO）</p>

<pre><code>BOOL     highlighted;          // default is NO
</code></pre>

<p>// 是否允许接收触摸事件(默认为NO)</p>

<pre><code>BOOL userInteractionEnabled;  // default is NO
</code></pre>

<p>// 文本是否可变(默认YES)</p>

<pre><code>BOOL enabled;                 // default is YES. changes how the label is drawn
</code></pre>

<p>// 设置label可以显示多少行(0表示多行，默认为1)</p>

<pre><code>NSInteger numberOfLines;
</code></pre>

<p>// 文本文字是否自适应大小(默认为NO)</p>

<pre><code>BOOL adjustsFontSizeToFitWidth;         // default is NO
</code></pre>

<p>//</p>

<pre><code>BOOL adjustsLetterSpacingToFitWidth NS_DEPRECATED_IOS(6_0,7_0); // deprecated - hand tune by using NSKernAttributeName to affect tracking
</code></pre>

<p>// 最小字体，行数为1时有效（默认为0.0 iOS2.0 &ndash; iOS6.0）</p>

<pre><code>CGFloat minimumFontSize;
</code></pre>

<p>// 控制文本的基线位置，只有文本行数为1是有效（默认为UIBaselineAdjustmentAlignBaselines）</p>

<pre><code>UIBaselineAdjustment baselineAdjustment;
//有三种方式
typedef enum {
    UIBaselineAdjustmentAlignBaselines = 0, 默认值文本最上端于label中线对齐
    UIBaselineAdjustmentAlignCenters,//文本中线于label中线对齐
    UIBaselineAdjustmentNone,//文本最低端与label中线对齐
} UIBaselineAdjustment;
</code></pre>

<p>// 设置最小字体,与minimumFontSize相同（iOS6.0）</p>

<pre><code>CGFloat minimumScaleFactor; 
</code></pre>

<p>// 优先选择标签布局的最大宽度(iOS 6.0)</p>

<pre><code>CGFloat preferredMaxLayoutWidth;    
</code></pre>

<p><strong>2、方法</strong></p>

<p>// 不可直接调用,需要子类重载,第二参数为0时没有行数限制</p>

<pre><code>- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines;
</code></pre>

<p>// 不可直接调用,需要子类重载</p>

<pre><code>- (void)drawTextInRect:(CGRect)rect;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[视图鼻祖之UIView详解]]></title>
    <link href="http://beyondabel.github.io/blog/2014/01/04/uiview/"/>
    <updated>2014-01-04T21:04:48+08:00</updated>
    <id>http://beyondabel.github.io/blog/2014/01/04/uiview</id>
    <content type="html"><![CDATA[<p><strong>引言</strong></p>

<p>UIView表示屏幕上的一块矩形区域，它在App中占有绝对重要的地位，因为iOS中几乎所有可视化控件都是UIView的子类。负责渲染区域的内容，并且响应该区域内发生的触摸事件</p>

<p><strong>目录</strong></p>

<pre><code>1、UIView家族
2、UIView的基本属性
3、几何方法类
4、控制级别类
5、渲染类
6、动画类
7、手势类
8、移动效果类
9、基于布局约束类(iOS6.0)
10、基于布局的约束core方法(iOS 6.0)
11、基于约束的兼容性（iOS 6.0）
12、层次布局的约束（iOS 6.0）
13、设备大小布局约束(iOS 6.0)
14、布局调度(iOS 6.0)
15、状态恢复(iOS 6.0)
16、快照 （iOS7.0）
</code></pre>

<!--more-->


<p><strong>1、UIView家族</strong></p>

<p>下图就是视图的内层次</p>

<p><img src="/images/2014/01/04/uiview.png" alt="image" /></p>

<p><strong>2、UIView的基本属性</strong></p>

<pre><code>BOOL userInteractionEnabled;  // UIView是否接受events事件，默认为YES
NSInteger tag;                // 用于做标识所用，默认为0
CALayer  *layer;              // Core Animation layer有关，在常用方法中再详细讲解

CGRect            frame;    // UIView在父视图中的位置

CGRect            bounds;  // UIView相对自己的位置
CGPoint           center;      // UIView的中心点. animatable
CGAffineTransform transform;   // 线性代数里面讲的矩阵变换，这个是恒等变换,一般用来旋转，缩放
CGFloat contentScaleFactor;修改contentScaleFactor可以让UIView的渲染精度提高，这样即使在CGAffineTransform放大之后仍然能保持锐利。

BOOL multipleTouchEnabled;   // 是否允许多点触摸
BOOL       exclusiveTouch;         // default is NO
UIColor   backgroundColor;  // UIView的背影颜色
BOOL hidden;  // UIView是否隐藏
CGFloat  alpha; // 为0时完全透明，为1时完全不透明。

BOOL clipsToBounds; //在类的层次结构中，如果clipsTobounds设为YES,超出superView的部分subview就不会显示，否则会做显示， 默认情况下是NO。

BOOL opaque;   //这是一个优化属性，如果该值为YES, 那么绘图在绘制该视图的时候把整个视图当作不透明对待。这样，绘图系统在执行绘图过程中会优化一些操作并提升系统性能；如果是设置为NO, 绘图系统将其和其他内容平等对待，不去做优化操作。为了性能方面的考量，默认被置为YES(意味着‘优化’)。

UIView  *superview;// 父视图
NSArray *subviews;// 子视图
</code></pre>

<p>注：*frame和center都是相对于父视图的，bounds是相对于自身的。当view完全透明和隐藏时不能响应事件。</p>

<p>*opaque和alpha 是有关系的。 一个不透明视图需要整个边界里面的内容都是不透明的。基于这个原因，opaque设置为YES，要求对应的alpha必须为1.0。如果一个UIView实例opaque被设置为YES, 而同时它又没有完全填充它的边界(bounds),或者它包含了整个或部分的透明的内容视图，那么将会导致未知的结果。
因此，如果视图部分或全部支持透明，那么你必须把opaque这个值设置为NO.</p>

<p><strong>3、几何方法类</strong></p>

<pre><code>// hitTest主要用途是用来寻找那个视图是被触摸了
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;   
// 如果我们不想让某个视图响应事件，让此方法返回NO就行了。默认为YES
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event;
</code></pre>

<p>举个例子，建立一个TestView里面重载hitTest和pointInside方法：</p>

<pre><code>- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    [super hitTest:point withEvent:event];
    return self;
}  

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    NSLog(@"view pointInside");
    return YES;
}  
</code></pre>

<p>然后在TestView中增加一个子视图TestSecondView也重载这两个方法</p>

<pre><code>- (UIView*)hitTest:(CGPoint)point withEvent:(UIEvent *)event{
    [super hitTest:point withEvent:event]; 
    return self;  
}  

- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event{
    NSLog(@"second view pointInside");
    return YES; 
}  
</code></pre>

<p>这里注意[super hitTest:point withEvent:event];必须要包括，否则hitTest无法调用父类的方法，这样就没法 使用PointInside:withEvent:进行判断，那么就没法进行子视图的遍历。当去掉这个语句的时候，触摸事件就不可能进到子视图中了，除非你在方法中直接返回子视图的对象。这样你在调试的过程中就会发现，每次你点击一个view都会先进入到这个view的父视图中的hitTest方法，然后 调用super的hitTest方法之后就会查找pointInside是否返回YES如果是，则就把消息传递个子视图处理，子视图用同样的方法递归查找 自己的子视图。所以从这里调试分析看，hitTest方法这种递归调用的方式就一目了然了。</p>

<pre><code>// 将像素point由point所在视图转换到目标视图view中，返回在目标视图view中的像素值
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView *)view;
// 将像素point从view中转换到当前视图中，返回在当前视图中的像素值
- (CGPoint)convertPoint:(CGPoint)point fromView:(UIView *)view;

// 将rect由rect所在视图转换到目标视图view中，返回在目标视图view中的rect
- (CGRect)convertRect:(CGRect)rect toView:(UIView *)view;
// 将rect从view中转换到当前视图中，返回在当前视图中的rect
- (CGRect)convertRect:(CGRect)rect fromView:(UIView *)view;
</code></pre>

<p><strong>4、控制级别类</strong></p>

<pre><code>// 把视图从父类移除
- (void)removeFromSuperview;
// 添加子视图到某个位置
- (void)insertSubview:(UIView *)view atIndex:(NSInteger)index;
// 更改子视图的位置
- (void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2;

// 添加子视图
- (void)addSubview:(UIView *)view;
// 把view放在siblingSubview下面
- (void)insertSubview:(UIView *)view belowSubview:(UIView *)siblingSubview;
// 把view放在siblingSubview上面
- (void)insertSubview:(UIView *)view aboveSubview:(UIView *)siblingSubview;
</code></pre>

<p>注：1、addSubview:和insertSubview: atIndex:的区别：</p>

<pre><code>  [view addSubView:oneView] == [view insertSubview:oneView atIndex:view.subviews.cout];

// 将view显示在最前面（要将一个view显示在最前面，只要调用其父视图的bringSubviewToFront：方法）
- (void)bringSubviewToFront:(UIView *)view;
// 将view推送到背后
- (void)sendSubviewToBack:(UIView *)view;
// 当加入视图完成后调用  
- (void)didAddSubview:(UIView *)subview;
// 将移除子视图会调用
- (void)willRemoveSubview:(UIView *)subview;

// 通知即将移动到新的父视图中
- (void)willMoveToSuperview:(UIView *)newSuperview;
// 通知已经到新父视图
- (void)didMoveToSuperview;
// 通知即将已移动到新的窗口
- (void)willMoveToWindow:(UIWindow *)newWindow;
// 通知已经移动新的窗口
- (void)didMoveToWindow;

// 判断一个视图是否在父视图层中
- (BOOL)isDescendantOfView:(UIView *)view;  // returns YES for self.
// 获取标记的子视图
- (UIView *)viewWithTag:(NSInteger)tag;     // recursive search. includes self

// Allows you to perform layout before the drawing cycle happens. -layoutIfNeeded forces layout early
// 标记为需要重新布局，异步调用layoutIfNeeded刷新布局，不立即刷新，
// 但layoutSubviews一定会被调用
- (void)setNeedsLayout;
// 如果有需要刷新的标记，立即调用layoutSubviews进行布局
//（如果没有标记，不会调用layoutSubviews）
- (void)layoutIfNeeded;

// 重新布局
- (void)layoutSubviews; 
</code></pre>

<p><strong>5、渲染类</strong></p>

<pre><code>// 重写此方法，执行重绘
- (void)drawRect:(CGRect)rect;

// 标记为需要重绘，异步调用drawRect
- (void)setNeedsDisplay;
// 标记为需要局部重绘
- (void)setNeedsDisplayInRect:(CGRect)rect;
</code></pre>

<p>注：drawRect是对receiver的重绘。setNeedDisplay在receiver标上一个需要被重新绘图的标记，在下一个draw周期自动重绘，iphone device的刷新频率是60hz，也就是1/60秒后重绘</p>

<p><strong>6、动画类</strong></p>

<pre><code>// 开始一个动画
+ (void)beginAnimations:(NSString *)animationID context:(void *)context; 
// 执行动画,类似数据库的事务处理
+ (void)commitAnimations; 
// 设置动画代理，默认为nil
+ (void)setAnimationDelegate:(id)delegate; 

// 当动画执行开始时，执行selector方法，默认为NULL
+ (void)setAnimationWillStartSelector:(SEL)selector;
// 当动画执行结束时，执行selector方法
+ (void)setAnimationDidStopSelector:(SEL)selector; 

// 设置动画时间，时间参数为double类型，默认0.2
+ (void)setAnimationDuration:(NSTimeInterval)duration;
// 设置动画延迟时间
+ (void)setAnimationDelay:(NSTimeInterval)delay;  
// 设置在动画块内部动画内部动画属性改变的开始时间
+ (void)setAnimationStartDate:(NSDate *)startDate;
// 设置动画的旋转曲度变化，默认为UIViewAnimationCurveEaseInOut
//值定义在UIViewAnimationCurve结构体中。
//typedef NS_ENUM(NSInteger, UIViewAnimationCurve) { //动画曲线
    // slow at beginning and end 缓慢开始，中间加速，然后减速到结束
//  UIViewAnimationCurveEaseInOut,   
    // slow at beginning  缓慢开始，加速到结束     
//  UIViewAnimationCurveEaseIn,    
    // slow at end  加速开始，加速到结束        
//  UIViewAnimationCurveEaseOut, 
    //正常速度          
//  UIViewAnimationCurveLinear  
//};
+ (void)setAnimationCurve:(UIViewAnimationCurve)curve; 

// 设置动画在动画模块中的重复次数
+ (void)setAnimationRepeatCount:(float)repeatCount;                 
// 设置动画块中的动画效果是否自动重复播放
+ (void)setAnimationRepeatAutoreverses:(BOOL)repeatAutoreverses;    
// 设置动画是否从当前状态开始播放，默认为NO. 
+ (void)setAnimationBeginsFromCurrentState:(BOOL)fromCurrentState;  

// 在动画设置过渡效果
+ (void)setAnimationTransition:(UIViewAnimationTransition)transition forView:(UIView *)view cache:(BOOL)cache;

transition
把一个过渡效果应用到视图中。值定义在UIViewAnimationTransition结构体中。
typedef NS_ENUM(NSInteger, UIViewAnimationTransition) {
    UIViewAnimationTransitionNone, 没有过渡
    UIViewAnimationTransitionFlipFromLeft,  翻转视图从左到右
    UIViewAnimationTransitionFlipFromRight, 翻转视图从右到左
    UIViewAnimationTransitionCurlUp, 从上卷动
    UIViewAnimationTransitionCurlDown, 从下卷动
};
view
    需要过渡的视图对象。

cache
如果是YES，那么在开始和结束图片视图渲染一次并在动画中创建帧；否则，视图将会在每一帧都渲染。例如缓存，你不需要在视图转变中不停的更新，你只需要等到转换完成再去更新视图。
1、开始一个动画块。
2、在容器视图中设置转换。
3、在容器视图中移除子视图。
4、在容器视图中添加子视图。
5、结束动画块。

// 设置是否开启动画，默认YES,开启
+ (void)setAnimationsEnabled:(BOOL)enabled;
// 验证动画是否开启，YES开启，NO关闭
+ (BOOL)areAnimationsEnabled;               
// iOS7之后替代 setAnimationsEnabled
+ (void)performWithoutAnimation:(void (^)(void))actionsWithoutAnimation;

// iOS4.0之后
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;

动画效果处理块，多参数
</code></pre>

<p>(NSTimeInterval)duration :动画时间</p>

<p>(NSTimeInterval)delay:延迟时间
(UIViewAnimationOptions)options 动画参数</p>

<pre><code>typedef NS_OPTIONS(NSUInteger, UIViewAnimationOptions) {
    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt;  0,
    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt;  1, // turn on user interaction while animating
    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt;  2, // start all views from current value, not initial value
    UIViewAnimationOptionRepeat                    = 1 &lt;&lt;  3, // repeat animation indefinitely
    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt;  4, // if repeat, run animation back and forth
    UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt;  5, // ignore nested duration
    UIViewAnimationOptionOverrideInheritedCurve    = 1 &lt;&lt;  6, // ignore nested curve
    UIViewAnimationOptionAllowAnimatedContent      = 1 &lt;&lt;  7, // animate contents (applies to transitions only)
    UIViewAnimationOptionShowHideTransitionViews   = 1 &lt;&lt;  8, // flip to/from hidden state instead of adding/removing

    UIViewAnimationOptionCurveEaseInOut            = 0 &lt;&lt; 16, // default
    UIViewAnimationOptionCurveEaseIn               = 1 &lt;&lt; 16,
    UIViewAnimationOptionCurveEaseOut              = 2 &lt;&lt; 16,
    UIViewAnimationOptionCurveLinear               = 3 &lt;&lt; 16,

    UIViewAnimationOptionTransitionNone            = 0 &lt;&lt; 20, // default
    UIViewAnimationOptionTransitionFlipFromLeft    = 1 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromRight   = 2 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCurlUp          = 3 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCurlDown        = 4 &lt;&lt; 20,
    UIViewAnimationOptionTransitionCrossDissolve   = 5 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromTop     = 6 &lt;&lt; 20,
    UIViewAnimationOptionTransitionFlipFromBottom  = 7 &lt;&lt; 20,
} NS_ENUM_AVAILABLE_IOS(4_0);
</code></pre>

<p>(void))animations :动画效果块</p>

<p>可以设置属性如下：frame\bounds\center\transform\alpha\backgroundColor\contentStretch</p>

<p>completion:(void (^)(BOOL finished))completion
动画结束块</p>

<p>例：</p>

<pre><code>[UIView animateWithDuration: 2.00 delay:3.00 options:UIViewAnimationOptionAllowAnimatedContent
                 animations:^{
                         insertDemoTwo.alpha = 0.1;
                         insertDemoOne.alpha = 1.0;
                                        }
                 completion:^(BOOL finished) {
                     [UIView animateWithDuration:3.00
                                      animations:^{
                                          insertDemoTwo.center = CGPointMake(500.0, 470.0);
                                          insertDemoOne.center = CGPointMake(140.0, 100.0);
                                      }
                      ];


                 }

 ];


// 动画效果处理（无延迟，无参数）iOS4.0之后，默认delay = 0.0,options = 0;
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;
</code></pre>

<p>例：</p>

<pre><code>[UIView animateWithDuration:3.00
                 animations:^{
                     insertDemoOne.alpha = 1.0;
                     insertDemoTwo.alpha = 0.1;
                 }
                 completion:^(BOOL finished) {
                     insertDemoTwo.center = CGPointMake(500.0, 470.0);
                     insertDemoOne.center = CGPointMake(140.0, 100.0);                    
                     }
 ];

//动画效果处理简单版 iOS4.0之后（delay = 0.0,options = 0,completion = NULL）
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations;

+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);

// 过渡动画效果块，iOS4.0
+ (void)transitionWithView:(UIView *)view duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion;
</code></pre>

<p>例：</p>

<pre><code>[UIView transitionWithView:insertDemoOne duration: 1.0 options:UIViewAnimationOptionTransitionFlipFromLeft
                                     animations:^{
                                         [insertDemoTwo removeFromSuperview];
                                         [insertDemoOne addSubview:insertDemoTwo];
                                     }
                                     completion:^(BOOL finished) {
                                         insertDemoOne.backgroundColor = [UIColor brownColor];
                                     }];

// 视图之间切换的过渡动画效果块，iOS4
+ (void)transitionFromView:(UIView *)fromView toView:(UIView *)toView duration:(NSTimeInterval)duration options:(UIViewAnimationOptions)options completion:(void (^)(BOOL finished))completion;


+ (void)performSystemAnimation:(UISystemAnimation)animation onViews:(NSArray *)views options:(UIViewAnimationOptions)options animations:(void (^)(void))parallelAnimations completion:(void (^)(BOOL finished))completion NS_AVAILABLE_IOS(7_0);
</code></pre>

<p><strong>7、手势类</strong></p>

<p>// 手势识别器（iOS3.2）
@property(nonatomic,copy) NSArray *gestureRecognizers;</p>

<pre><code>UIKit 中UIGestureRecognizer类的子类系列如下：
UITapGestureRecognizer – “轻击”手势。可以配置为“单击”和“连击”的识别。
UIPinchGestureRecognizer –“捏合”手势。该手势通常用于缩放视图或改变可视组件的大小。
UIPanGestureRecognizer – “平移”手势。识别拖拽或移动动作。
UISwipeGestureRecognizer – “轻扫”手势。当用户从屏幕上划过时识别为该手势。可以指定该动作的方向（上、下、左、右）。
UIRotationGestureRecognizer – “转动”手势。用户两指在屏幕上做相对环形运动。
UILongPressGestureRecognizer – “长按”手势。使用1指或多指触摸屏幕并保持一定时间。
</code></pre>

<p>// 绑定手势到视图（iOS3.2）</p>

<pre><code>- (void)addGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer; 
</code></pre>

<p>//从视图中移除手势 (iOS3.2)</p>

<pre><code>- (void)removeGestureRecognizer:(UIGestureRecognizer*)gestureRecognizer;
</code></pre>

<p>//手势识别处理方式在gesture recognizer视图转出《UIGestureRecognizerStatePossible》状态时调用，如果返回NO,则转换到《UIGestureRecognizerStateFailed》;如果返回YES,则继续识别触摸序列.(默认情况下为YES)。(iOS6.0)</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer;
</code></pre>

<p><strong>8、移动效果类</strong></p>

<ul>
<li>(void)addMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);</li>
</ul>


<p>/*! Stops applying <code>effect</code> to the receiver. Any affected presentation values will animate to</p>

<pre><code>their post-removal values using the present UIView animation context. */
</code></pre>

<ul>
<li>(void)removeMotionEffect:(UIMotionEffect *)effect NS_AVAILABLE_IOS(7_0);</li>
</ul>


<p><strong>9、基于布局约束类(iOS6.0)</strong></p>

<p>// 视图布局约束</p>

<pre><code>- (NSArray *)constraints;
</code></pre>

<p>// 视图布局上添加一个约束</p>

<pre><code>- (void)addConstraint:(NSLayoutConstraint *)constraint;
</code></pre>

<p>// 视图布局上添加多个约束</p>

<pre><code>- (void)addConstraints:(NSArray *)constraints;
</code></pre>

<p>// 移除视力布局上的一个约束</p>

<pre><code>- (void)removeConstraint:(NSLayoutConstraint *)constraint;
</code></pre>

<p>// 移除视图布局上的多个约束</p>

<pre><code>- (void)removeConstraints:(NSArray *)constraints;
</code></pre>

<p><strong>10、基于布局的约束core方法(iOS 6.0)</strong></p>

<p>// 调用新的视图布局自动触发，更新视图布局上的约束</p>

<pre><code>- (void)updateConstraintsIfNeeded;
</code></pre>

<p>// 更新自定义视图布局约束</p>

<pre><code>- (void)updateConstraints; 
</code></pre>

<p>// 判断视图布局是否需要更新约束</p>

<pre><code>- (BOOL)needsUpdateConstraints;
</code></pre>

<p>// 设置视图布局是否需要更新约束</p>

<pre><code>- (void)setNeedsUpdateConstraints;
</code></pre>

<p><strong>11、基于约束的兼容性（iOS 6.0）</strong></p>

<p>// 标示是否自动遵循视图布局约束，默认为YES</p>

<pre><code>- (BOOL)translatesAutoresizingMaskIntoConstraints; 
</code></pre>

<p>// 设置是否自动遵循视图布局约束</p>

<pre><code>- (void)setTranslatesAutoresizingMaskIntoConstraints:(BOOL)flag;
</code></pre>

<p>// 返回是遵循自定义视图布局约束</p>

<pre><code>+ (BOOL)requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);
</code></pre>

<p><strong>12、层次布局的约束（iOS 6.0）</strong></p>

<p>// 返回矩形对于指定视图框架</p>

<pre><code>- (CGRect)alignmentRectForFrame:(CGRect)frame;
</code></pre>

<p>// 返回框架对于指定视图矩形</p>

<pre><code>- (CGRect)frameForAlignmentRect:(CGRect)alignmentRect;
</code></pre>

<p>// 返回自定义视图大小</p>

<pre><code>- (UIEdgeInsets)alignmentRectInsets;
</code></pre>

<p>// 如果超出约束范围，自动生成基线限制，以满足视图需求</p>

<pre><code>- (UIView *)viewForBaselineLayout;
</code></pre>

<p>// 返回放大的视图布局轴线</p>

<pre><code>- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 设置放大的视图布局的轴线</p>

<pre><code>- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 返回缩小的视图布局的轴线</p>

<pre><code>- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 设置缩小的视图布局轴线</p>

<pre><code>- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p><strong>13、设备大小布局约束(iOS 6.0)</strong></p>

<p>// 满足约束视图布局的大小</p>

<pre><code>- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize;
</code></pre>

<p><strong>14、布局调度(iOS 6.0)</strong></p>

<p>// 返回影响视图布局限制的轴线</p>

<pre><code>- (NSArray *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis;
</code></pre>

<p>// 返回视图布局约束是否影响指定视图，主要用于调试约束布局，结合exerciseAmbiguityInLayout。</p>

<pre><code>- (BOOL)hasAmbiguousLayout;
</code></pre>

<p>// 随机改变不同效值布局视图，主要用于调试基于约束布局的视图</p>

<pre><code>- (void)exerciseAmbiguityInLayout; 
</code></pre>

<p><strong>15、状态恢复(iOS 6.0)</strong></p>

<p>// 标志是否支持保存，恢复视图状态信息</p>

<pre><code>@property (nonatomic, copy) NSString *restorationIdentifier;
</code></pre>

<p>// 保存视图状态相关信息</p>

<pre><code>- (void) encodeRestorableStateWithCoder:(NSCoder *)coder;
</code></pre>

<p>// 恢复和保存视图相关信息</p>

<pre><code>- (void) decodeRestorableStateWithCoder:(NSCoder *)coder; 
</code></pre>

<p><strong>16、快照 （iOS7.0）</strong></p>

<p>我们有时候可能需要取UIView对象的快照，有几个原因，您可能希望从动画性能改进上去分享您的应用程序的屏幕截图。现有的方法面临几个问题：</p>

<pre><code>1代码不简单
2复杂的渲染选项，比如层面罩的难再生
3OpenGL层需要特殊的事例代码
4快照处理十分慢
</code></pre>

<p>事实上,真的没有任何通用的“快照”代码可以应付所有可能的场景。
但是IOS7将会改变，UIView和UIScreen会有一些新的方法，为各种用例提供简单的快照功能。</p>

<p>动画快照
我们可能经常想对一个视图进行动画处理，但是视图的动画太复杂，要么是动画太密集，要么就是需要额外的代码来控制正确的行为。
例如附带的项目，我们创建一个UIView的子类，它只是简单的添加一些子视图，并旋转来生成一个有趣的几何排列。</p>

<p>// 调用snapshotViewAfterScreenUpdates：方法去创建复杂视图的快照。方法返回一个UIView，来呈现被调用的视图的界面。用这个方法去获取视图快照非常有效，比制作位图要快的多。
当获得视图快照后，我们把它添加到容器视图上，并移除实际的复杂视图。然后可以动画处理快照视图了：</p>

<pre><code>- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates;

- (UIView *)resizableSnapshotViewFromRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates withCapInsets:(UIEdgeInsets)capInsets;
- (BOOL)drawViewHierarchyInRect:(CGRect)rect afterScreenUpdates:(BOOL)afterUpdates;
</code></pre>
]]></content>
  </entry>
  
</feed>
